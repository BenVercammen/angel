main = main::main;
library from "org-dartlang-app:///example/main.dart" as main {
  import "dart:async";
  import "dart:isolate";
  import "package:angel_framework/angel_framework.dart";
  import "package:angel_production/angel_production.dart";
  import "package:pub_sub/pub_sub.dart" as pub_sub;
  static method main(core::List<core::String> args) → dynamic
    return new run::Runner::•("example", main::configureServer).{run::Runner::run}(args);
  static method configureServer(ser::Angel app) → asy::Future<dynamic> async {
    cli::Client client = app.{rou::Routable::container}.{con::Container::make}<cli::Client>();
    core::String greeting = "Hello! This is the default greeting.";
    cli::ClientSubscription onGreetingChanged = await client.{cli::Client::subscribe}("greeting_changed");
    onGreetingChanged.{asy::Stream::cast}<core::String>().{asy::Stream::listen}((core::String newGreeting) → void => greeting = newGreeting);
    app.{rou2::Router::get}("/", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → core::String => "Hello, production world!");
    app.{rou2::Router::get}("/greeting", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → core::String => greeting);
    app.{rou2::Router::get}("/change_greeting/:newGreeting", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → core::String {
      greeting = req.{req::RequestContext::params}.{core::Map::[]}("newGreeting") as core::String;
      client.{cli::Client::publish}("greeting_changed", greeting);
      return "Changed greeting -> ${greeting}";
    });
    app.{rou2::Router::get}("/crash", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → core::String {
      asy::Timer::•(const core::Duration::•(seconds: 3), iso::Isolate::current.{iso::Isolate::kill});
      return "Crashing in 3s...";
    });
  }
}
library angel_framework from "package:angel_framework/angel_framework.dart" as ang {
  export "package:angel_framework/src/core/core.dart";
  export "package:angel_framework/src/http/http.dart";
}
library from "package:angel_production/angel_production.dart" as ang2 {
  export "package:angel_production/src/instance_info.dart";
  export "package:angel_production/src/options.dart";
  export "package:angel_production/src/runner.dart";
}
library from "package:pub_sub/pub_sub.dart" as pub {
  export "package:pub_sub/src/protocol/protocol.dart";
}
library from "package:angel_framework/src/core/core.dart" as core2 {
  export "package:angel_framework/src/core/anonymous_service.dart";
  export "package:angel_framework/src/core/hooked_service.dart";
  export "package:angel_framework/src/core/map_service.dart";
  export "package:angel_framework/src/core/metadata.dart";
  export "package:angel_framework/src/core/request_context.dart";
  export "package:angel_framework/src/core/response_context.dart";
  export "package:angel_framework/src/core/routable.dart";
  export "package:angel_framework/src/core/server.dart";
  export "package:angel_framework/src/core/service.dart";
  export "package:angel_framework/src/core/typed_service.dart";
}
library angel_framework.http from "package:angel_framework/src/http/http.dart" as http {
  import "dart:async";
  import "dart:io";
  export "package:angel_http_exception/angel_http_exception.dart";
  export "package:angel_model/angel_model.dart";
  export "package:angel_route/angel_route.dart";
  export "package:body_parser/body_parser.dart";
  export "package:angel_framework/src/http/angel_http.dart";
  export "package:angel_framework/src/http/controller.dart";
  export "package:angel_framework/src/http/http_request_context.dart";
  export "package:angel_framework/src/http/http_response_context.dart";
  static method startShared(dynamic address, core::int port) → asy::Future<_ht::HttpServer>
    return _ht::HttpServer::bind(let final dynamic #t1 = address in #t1.==(null) ?{dynamic} "127.0.0.1" : #t1, let final core::int #t2 = port in #t2.==(null) ?{core::int} 0 : #t2, shared: true);
  static method startSharedSecure(io::SecurityContext securityContext) → (dynamic, core::int) → asy::Future<_ht::HttpServer> {
    return (dynamic address, core::int port) → asy::Future<_ht::HttpServer> => _ht::HttpServer::bindSecure(let final dynamic #t3 = address in #t3.==(null) ?{dynamic} "127.0.0.1" : #t3, let final core::int #t4 = port in #t4.==(null) ?{core::int} 0 : #t4, securityContext, shared: true);
  }
}
library from "package:angel_production/src/instance_info.dart" as ins {
  class InstanceInfo extends core::Object {
    final field core::int id;
    const constructor •({core::int id = null}) → void
      : ins::InstanceInfo::id = id, super core::Object::•()
      ;
  }
}
library from "package:angel_production/src/options.dart" as opt {
  import "dart:io";
  import "package:args/args.dart";
  class RunnerOptions extends core::Object {
    static final field arg::ArgParser argParser = let final arg::ArgParser #t5 = arg::ArgParser::•() in let final dynamic #t6 = #t5.{arg::ArgParser::addFlag}("help", abbr: "h", help: "Print this help information.", negatable: false) in let final dynamic #t7 = #t5.{arg::ArgParser::addFlag}("respawn", help: "Automatically respawn crashed application instances.", defaultsTo: true, negatable: true) in let final dynamic #t8 = #t5.{arg::ArgParser::addFlag}("use-zone", negatable: false, help: "Create a new Zone for each request.") in let final dynamic #t9 = #t5.{arg::ArgParser::addOption}("address", abbr: "a", defaultsTo: "127.0.0.1", help: "The address to listen on.") in let final dynamic #t10 = #t5.{arg::ArgParser::addOption}("concurrency", abbr: "j", defaultsTo: io::Platform::numberOfProcessors.{core::int::toString}(), help: "The number of isolates to spawn.") in let final dynamic #t11 = #t5.{arg::ArgParser::addOption}("port", abbr: "p", defaultsTo: "3000", help: "The port to listen on.") in #t5;
    final field core::String hostname;
    final field core::int concurrency;
    final field core::int port;
    final field core::bool useZone;
    final field core::bool respawn;
    constructor •({core::String hostname = "127.0.0.1", core::int port = 3000, core::int concurrency = 1, core::bool useZone = false, core::bool respawn = true}) → void
      : opt::RunnerOptions::hostname = hostname, opt::RunnerOptions::port = port, opt::RunnerOptions::concurrency = concurrency, opt::RunnerOptions::useZone = useZone, opt::RunnerOptions::respawn = respawn, super core::Object::•()
      ;
    static factory fromArgResults(arg2::ArgResults argResults) → opt::RunnerOptions {
      return new opt::RunnerOptions::•(hostname: argResults.{arg2::ArgResults::[]}("address") as core::String, port: core::int::parse(argResults.{arg2::ArgResults::[]}("port") as core::String), concurrency: core::int::parse(argResults.{arg2::ArgResults::[]}("concurrency") as core::String), useZone: argResults.{arg2::ArgResults::[]}("use-zone") as core::bool, respawn: argResults.{arg2::ArgResults::[]}("respawn") as core::bool);
    }
  }
}
library from "package:angel_production/src/runner.dart" as run {
  import "dart:async";
  import "dart:io";
  import "dart:isolate";
  import "package:angel_container/angel_container.dart";
  import "package:angel_framework/angel_framework.dart";
  import "package:args/args.dart";
  import "package:io/ansi.dart";
  import "package:io/io.dart";
  import "package:logging/logging.dart";
  import "package:pub_sub/isolate.dart" as pub_sub;
  import "package:pub_sub/pub_sub.dart" as pub_sub;
  import "package:angel_production/src/instance_info.dart";
  import "package:angel_production/src/options.dart";
  class Runner extends core::Object {
    final field core::String name;
    final field (ser::Angel) → asy::FutureOr<dynamic> configureServer;
    final field ref::Reflector reflector;
    static const field core::String asciiArt = "____________   ________________________ \n___    |__  | / /_  ____/__  ____/__  / \n__  /| |_   |/ /_  / __ __  __/  __  /  \n_  ___ |  /|  / / /_/ / _  /___  _  /___\n/_/  |_/_/ |_/  ____/  /_____/  /_____/\n                                        \n";
    constructor •(core::String name, (ser::Angel) → asy::FutureOr<dynamic> configureServer, {ref::Reflector reflector = const emp::EmptyReflector::•()}) → void
      : run::Runner::name = name, run::Runner::configureServer = configureServer, run::Runner::reflector = reflector, super core::Object::•()
      ;
    static method handleLogRecord(log::LogRecord record) → void {
      ans::AnsiCode code = run::Runner::chooseLogColor(record.{log::LogRecord::level});
      if(record.{log::LogRecord::error}.{core::Object::==}(null))
        core::print(code.{ans::AnsiCode::wrap}(record.{log::LogRecord::toString}()));
      if(!record.{log::LogRecord::error}.{core::Object::==}(null)) {
        core::Object err = record.{log::LogRecord::error};
        if(err is ang3::AngelHttpException && !err{ang3::AngelHttpException}.{ang3::AngelHttpException::statusCode}.{core::num::==}(500))
          return;
        core::print(code.{ans::AnsiCode::wrap}(record.{log::LogRecord::toString}().{core::String::+}("\n")));
        core::print(code.{ans::AnsiCode::wrap}(err.{core::Object::toString}()));
        if(!record.{log::LogRecord::stackTrace}.{core::Object::==}(null)) {
          core::print(code.{ans::AnsiCode::wrap}(record.{log::LogRecord::stackTrace}.{core::StackTrace::toString}()));
        }
      }
    }
    static method chooseLogColor(log::Level level) → ans::AnsiCode {
      if(level.{log::Level::==}(log::Level::SHOUT))
        return ans::backgroundRed;
      else
        if(level.{log::Level::==}(log::Level::SEVERE))
          return ans::red;
        else
          if(level.{log::Level::==}(log::Level::WARNING))
            return ans::yellow;
          else
            if(level.{log::Level::==}(log::Level::INFO))
              return ans::cyan;
            else
              if(level.{log::Level::==}(log::Level::FINER) || level.{log::Level::==}(log::Level::FINEST))
                return ans::lightGray;
      return ans::resetAll;
    }
    method spawnIsolate(core::int id, opt::RunnerOptions options, iso::SendPort pubSubSendPort) → asy::Future<dynamic> {
      return this.{run::Runner::_spawnIsolate}(id, asy::Completer::•<dynamic>(), options, pubSubSendPort);
    }
    method _spawnIsolate(core::int id, asy::Completer<dynamic> c, opt::RunnerOptions options, iso::SendPort pubSubSendPort) → asy::Future<dynamic> {
      iso::ReceivePort onLogRecord = new iso::_ReceivePort::•();
      iso::ReceivePort onExit = new iso::_ReceivePort::•();
      iso::ReceivePort onError = new iso::_ReceivePort::•();
      run::_RunnerArgs runnerArgs = new run::_RunnerArgs::•(this.{run::Runner::name}, this.{run::Runner::configureServer}, options, this.{run::Runner::reflector}, onLogRecord.{iso::ReceivePort::sendPort}, pubSubSendPort);
      run::_RunnerArgsWithId argsWithId = new run::_RunnerArgsWithId::•(id, runnerArgs);
      iso::Isolate::spawn<run::_RunnerArgsWithId>(run::Runner::isolateMain, argsWithId, onExit: onExit.{iso::ReceivePort::sendPort}, onError: onError.{iso::ReceivePort::sendPort}, errorsAreFatal: true && false).{asy::Future::then}<dynamic>((iso::Isolate isolate) → core::Null {}).{asy::Future::catchError}(c.{asy::Completer::completeError});
      onLogRecord.{iso::ReceivePort::listen}((dynamic msg) → void => run::Runner::handleLogRecord(msg as log::LogRecord));
      onError.{iso::ReceivePort::listen}((dynamic msg) → core::Null {
        if(msg is core::List<dynamic>) {
          dynamic e = msg{core::List<dynamic>}.{core::List::[]}(0);
          core::StackTrace st = new core::_StringStackTrace::•(msg{core::List<dynamic>}.{core::List::[]}(1).{core::Object::toString}());
          run::Runner::handleLogRecord(new log::LogRecord::•(log::Level::SEVERE, "Fatal error", runnerArgs.{run::_RunnerArgs::loggerName}, e, st));
        }
        else {
          run::Runner::handleLogRecord(new log::LogRecord::•(log::Level::SEVERE, "Fatal error", runnerArgs.{run::_RunnerArgs::loggerName}, msg));
        }
      });
      onExit.{iso::ReceivePort::listen}((dynamic _) → core::Null {
        if(options.{opt::RunnerOptions::respawn}) {
          run::Runner::handleLogRecord(new log::LogRecord::•(log::Level::WARNING, "Instance #${id} at ${new core::DateTime::now()}. Respawning immediately...", runnerArgs.{run::_RunnerArgs::loggerName}));
          this.{run::Runner::_spawnIsolate}(id, c, options, pubSubSendPort);
        }
        else {
          c.{asy::Completer::complete}();
        }
      });
      return c.{asy::Completer::future}.{asy::Future::whenComplete}(onExit.{iso::ReceivePort::close}).{asy::Future::whenComplete}(onError.{iso::ReceivePort::close}).{asy::Future::whenComplete}(onLogRecord.{iso::ReceivePort::close});
    }
    method run(core::List<core::String> args) → asy::Future<dynamic> async {
      ser2::Server server;
      try
        try {
          arg2::ArgResults argResults = opt::RunnerOptions::argParser.{arg::ArgParser::parse}(args);
          opt::RunnerOptions options = opt::RunnerOptions::fromArgResults(argResults);
          core::print(ans::darkGray.{ans::AnsiCode::wrap}(run::Runner::asciiArt.{core::String::trim}().{core::String::+}("\n\n").{core::String::+}("A batteries-included, full-featured, full-stack framework in Dart.").{core::String::+}("\n\n").{core::String::+}("https://angel-dart.github.io\n")));
          if(argResults.{arg2::ArgResults::[]}("help").{core::Object::==}(true)) {
            let final io::Stdout #t12 = io::stdout in let final dynamic #t13 = #t12.{io::_StdSink::writeln}("Options:") in let final dynamic #t14 = #t12.{io::_StdSink::writeln}(opt::RunnerOptions::argParser.{arg::ArgParser::usage}) in #t12;
            return;
          }
          core::print("Starting `${this.{run::Runner::name}}` application...");
          core::print("Arguments: ${args}...\n");
          ser3::IsolateAdapter adapter = new ser3::IsolateAdapter::•();
          server = new ser2::Server::•(<ada::Adapter>[adapter]);
          for (core::int i = 0; i.{core::num::<}(io::Platform::numberOfProcessors); i = i.{core::num::+}(1)) {
            server.{ser2::Server::registerClient}(new cli2::ClientInfo::•("client${i}"));
          }
          server.{ser2::Server::start}();
          await asy::Future::wait<dynamic>(core::List::generate<asy::Future<dynamic>>(options.{opt::RunnerOptions::concurrency}, (core::int id) → asy::Future<dynamic> => this.{run::Runner::spawnIsolate}(id, options, adapter.{ser3::IsolateAdapter::receivePort}.{iso::ReceivePort::sendPort})));
        }
        on arg3::ArgParserException catch(final arg3::ArgParserException e) {
          let final io::Stdout #t15 = io::stderr in let final dynamic #t16 = #t15.{io::_StdSink::writeln}(e.{core::FormatException::message}) in let final dynamic #t17 = #t15.{io::_StdSink::writeln}() in let final dynamic #t18 = #t15.{io::_StdSink::writeln}("Options:") in let final dynamic #t19 = #t15.{io::_StdSink::writeln}(opt::RunnerOptions::argParser.{arg::ArgParser::usage}) in #t15;
          io::exitCode = exi::ExitCode::usage.{exi::ExitCode::code};
        }
        on dynamic catch(final dynamic e) {
          let final io::Stdout #t20 = io::stderr in let final dynamic #t21 = #t20.{io::_StdSink::writeln}("fatal error: ${e}") in #t20;
          io::exitCode = 1;
        }
      finally {
        let final ser2::Server #t22 = server in #t22.==(null) ?{asy::Future<dynamic>} null : #t22.{ser2::Server::close}();
      }
    }
    static method isolateMain(run::_RunnerArgsWithId argsWithId) → void {
      run::_RunnerArgs args = argsWithId.{run::_RunnerArgsWithId::args};
      log::hierarchicalLoggingEnabled = true;
      asy::Zone zone = asy::Zone::current.{asy::Zone::fork}(specification: new asy::_ZoneSpecification::•(print: (asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, core::String msg) → core::Null {
        args.{run::_RunnerArgs::loggingSendPort}.{iso::SendPort::send}(new log::LogRecord::•(log::Level::INFO, msg, args.{run::_RunnerArgs::loggerName}));
      }));
      zone.{asy::Zone::run}<asy::Future<core::Null>>(() → asy::Future<core::Null> async {
        cli3::IsolateClient client = new cli3::IsolateClient::•("client${argsWithId.{run::_RunnerArgsWithId::id}}", args.{run::_RunnerArgs::pubSubSendPort});
        ser::Angel app = let final ser::Angel #t23 = new ser::Angel::•(reflector: args.{run::_RunnerArgs::reflector}) in let final dynamic #t24 = #t23.{rou::Routable::container}.{con::Container::registerSingleton}<cli::Client>(client) in let final dynamic #t25 = #t23.{rou::Routable::container}.{con::Container::registerSingleton}<ins::InstanceInfo>(new ins::InstanceInfo::•(id: argsWithId.{run::_RunnerArgsWithId::id})) in #t23;
        app.{ser::Angel::shutdownHooks}.{core::List::add}((ser::Angel _) → asy::Future<dynamic> => client.{cli3::IsolateClient::close}());
        await app.{ser::Angel::configure}(args.{run::_RunnerArgs::configureServer});
        if(app.{ser::Angel::logger}.{core::Object::==}(null)) {
          app.{ser::Angel::logger} = let final log::Logger #t26 = log::Logger::•(args.{run::_RunnerArgs::loggerName}) in let final dynamic #t27 = #t26.{log::Logger::onRecord}.{asy::Stream::listen}(run::Runner::handleLogRecord) in #t26;
        }
        ang4::AngelHttp http = ang4::AngelHttp::custom(app, http::startShared, useZone: args.{run::_RunnerArgs::options}.{opt::RunnerOptions::useZone});
        _ht::HttpServer server = await http.{ang4::AngelHttp::startServer}(args.{run::_RunnerArgs::options}.{opt::RunnerOptions::hostname}, args.{run::_RunnerArgs::options}.{opt::RunnerOptions::port});
        core::Uri url = core::_Uri::•(scheme: "http", host: server.{_ht::HttpServer::address}.{io::InternetAddress::address}, port: server.{_ht::HttpServer::port});
        core::print("Instance #${argsWithId.{run::_RunnerArgsWithId::id}} listening at ${url}");
      });
    }
  }
  class _RunnerArgsWithId extends core::Object {
    final field core::int id;
    final field run::_RunnerArgs args;
    constructor •(core::int id, run::_RunnerArgs args) → void
      : run::_RunnerArgsWithId::id = id, run::_RunnerArgsWithId::args = args, super core::Object::•()
      ;
  }
  class _RunnerArgs extends core::Object {
    final field core::String name;
    final field (ser::Angel) → asy::FutureOr<dynamic> configureServer;
    final field opt::RunnerOptions options;
    final field ref::Reflector reflector;
    final field iso::SendPort loggingSendPort;
    final field iso::SendPort pubSubSendPort;
    constructor •(core::String name, (ser::Angel) → asy::FutureOr<dynamic> configureServer, opt::RunnerOptions options, ref::Reflector reflector, iso::SendPort loggingSendPort, iso::SendPort pubSubSendPort) → void
      : run::_RunnerArgs::name = name, run::_RunnerArgs::configureServer = configureServer, run::_RunnerArgs::options = options, run::_RunnerArgs::reflector = reflector, run::_RunnerArgs::loggingSendPort = loggingSendPort, run::_RunnerArgs::pubSubSendPort = pubSubSendPort, super core::Object::•()
      ;
    get loggerName() → core::String
      return this.{run::_RunnerArgs::name};
  }
}
library from "package:pub_sub/src/protocol/protocol.dart" as pro {
  export "package:pub_sub/src/protocol/client/sync_client.dart";
  export "package:pub_sub/src/protocol/server/sync_server.dart";
}
library from "package:angel_framework/src/core/anonymous_service.dart" as ano {
  import "dart:async";
  import "package:angel_framework/src/core/service.dart";
  class AnonymousService extends ser4::Service {
    field ([core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> _index = null;
    field (core::Object, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> _read = null;
    field (core::Object, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> _create = null;
    field (core::Object, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> _remove = null;
    field (core::Object, core::Object, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> _modify = null;
    field (core::Object, core::Object, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> _update = null;
    constructor •({([core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> index = null, (dynamic, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> read = null, (dynamic, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> create = null, (dynamic, dynamic, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> modify = null, (dynamic, dynamic, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> update = null, (dynamic, [core::Map<dynamic, dynamic>]) → asy::FutureOr<dynamic> remove = null}) → void
      : super ser4::Service::•() {
      this.{ano::AnonymousService::_index} = index;
      this.{ano::AnonymousService::_read} = read;
      this.{ano::AnonymousService::_create} = create;
      this.{ano::AnonymousService::_modify} = modify;
      this.{ano::AnonymousService::_update} = update;
      this.{ano::AnonymousService::_remove} = remove;
    }
    @core::override
    method index([core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic>
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => !this.{ano::AnonymousService::_index}.{core::Object::==}(null) ?{asy::FutureOr<dynamic>} this.{ano::AnonymousService::_index}(params) : super.{ser4::Service::index}(params));
    @core::override
    method read(dynamic id, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic>
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => !this.{ano::AnonymousService::_read}.{core::Object::==}(null) ?{asy::FutureOr<dynamic>} this.{ano::AnonymousService::_read}(id, params) : super.{ser4::Service::read}(id, params));
    @core::override
    method create(dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic>
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => !this.{ano::AnonymousService::_create}.{core::Object::==}(null) ?{asy::FutureOr<dynamic>} this.{ano::AnonymousService::_create}(data, params) : super.{ser4::Service::create}(data, params));
    @core::override
    method modify(dynamic id, dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic>
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => !this.{ano::AnonymousService::_modify}.{core::Object::==}(null) ?{asy::FutureOr<dynamic>} this.{ano::AnonymousService::_modify}(id, data, params) : super.{ser4::Service::modify}(id, data, params));
    @core::override
    method update(dynamic id, dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic>
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => !this.{ano::AnonymousService::_update}.{core::Object::==}(null) ?{asy::FutureOr<dynamic>} this.{ano::AnonymousService::_update}(id, data, params) : super.{ser4::Service::update}(id, data, params));
    @core::override
    method remove(dynamic id, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic>
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => !this.{ano::AnonymousService::_remove}.{core::Object::==}(null) ?{asy::FutureOr<dynamic>} this.{ano::AnonymousService::_remove}(id, params) : super.{ser4::Service::remove}(id, params));
  }
}
library angel_framework.core.hooked_service from "package:angel_framework/src/core/hooked_service.dart" as hoo {
  import "dart:async";
  import "package:angel_framework/src/util.dart";
  import "package:angel_framework/src/core/request_context.dart";
  import "package:angel_framework/src/core/response_context.dart";
  import "package:angel_framework/src/core/routable.dart";
  import "package:angel_framework/src/core/metadata.dart";
  import "package:angel_framework/src/core/server.dart";
  import "package:angel_framework/src/core/service.dart";
  typedef HookedServiceEventListener = (hoo::HookedServiceEvent) → dynamic;
  class HookedService extends ser4::Service {
    final field core::List<asy::StreamController<hoo::HookedServiceEvent>> _ctrl = <asy::StreamController<hoo::HookedServiceEvent>>[];
    final field ser4::Service inner;
    final field hoo::HookedServiceEventDispatcher beforeIndexed = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher beforeRead = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher beforeCreated = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher beforeModified = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher beforeUpdated = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher beforeRemoved = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher afterIndexed = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher afterRead = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher afterCreated = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher afterModified = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher afterUpdated = new hoo::HookedServiceEventDispatcher::•();
    final field hoo::HookedServiceEventDispatcher afterRemoved = new hoo::HookedServiceEventDispatcher::•();
    constructor •(ser4::Service inner) → void
      : hoo::HookedService::inner = inner, super ser4::Service::•() {
      if(!this.{hoo::HookedService::inner}.{ser4::Service::app}.{core::Object::==}(null))
        this.{ser4::Service::app} = this.{hoo::HookedService::inner}.{ser4::Service::app};
    }
    method _getRequest(core::Map<dynamic, dynamic> params) → req::RequestContext<dynamic> {
      if(params.{core::Object::==}(null))
        return null;
      return params.{core::Map::[]}("__requestctx") as req::RequestContext<dynamic>;
    }
    method _getResponse(core::Map<dynamic, dynamic> params) → res::ResponseContext<dynamic> {
      if(params.{core::Object::==}(null))
        return null;
      return params.{core::Map::[]}("__responsectx") as res::ResponseContext<dynamic>;
    }
    method _stripReq(core::Map<dynamic, dynamic> params) → core::Map<dynamic, dynamic> {
      if(params.{core::Object::==}(null))
        return params;
      else
        return params.{core::Map::keys}.{core::Iterable::where}((dynamic key) → core::bool => !key.{core::Object::==}("__requestctx") && !key.{core::Object::==}("__responsectx")).{core::Iterable::fold}<core::Map<dynamic, dynamic>>(<dynamic, dynamic>{}, (core::Map<dynamic, dynamic> map, dynamic key) → core::Map<dynamic, dynamic> => let final core::Map<dynamic, dynamic> #t28 = map in let final dynamic #t29 = #t28.{core::Map::[]=}(key, params.{core::Map::[]}(key)) in #t28);
    }
    @core::override
    method close() → asy::Future<dynamic> {
      this.{hoo::HookedService::_ctrl}.{core::Iterable::forEach}((asy::StreamController<hoo::HookedServiceEvent> c) → void => c.{asy::StreamController::close}());
      this.{hoo::HookedService::beforeIndexed}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::beforeRead}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::beforeCreated}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::beforeModified}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::beforeUpdated}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::beforeRemoved}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::afterIndexed}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::afterRead}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::afterCreated}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::afterModified}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::afterUpdated}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::afterRemoved}.{hoo::HookedServiceEventDispatcher::_close}();
      this.{hoo::HookedService::inner}.{ser4::Service::close}();
      return asy::Future::value<dynamic>();
    }
    method addHooks(ser::Angel app) → void {
      met::Hooks hooks = util::getAnnotation(this.{hoo::HookedService::inner}, met::Hooks, app.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Hooks;
      core::List<(hoo::HookedServiceEvent) → dynamic> before = <(hoo::HookedServiceEvent) → dynamic>[];
      core::List<(hoo::HookedServiceEvent) → dynamic> after = <(hoo::HookedServiceEvent) → dynamic>[];
      if(!hooks.{core::Object::==}(null)) {
        before.{core::List::addAll}(hooks.{met::Hooks::before});
        after.{core::List::addAll}(hooks.{met::Hooks::after});
      }
      function applyListeners(core::Function fn, hoo::HookedServiceEventDispatcher dispatcher, [core::bool isAfter = null]) → void {
        met::Hooks hooks = util::getAnnotation(fn, met::Hooks, app.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Hooks;
        final core::List<(hoo::HookedServiceEvent) → dynamic> listeners = let final core::List<(hoo::HookedServiceEvent) → dynamic> #t30 = <(hoo::HookedServiceEvent) → dynamic>[] in let final dynamic #t31 = #t30.{core::List::addAll}(isAfter.{core::Object::==}(true) ?{core::List<(hoo::HookedServiceEvent) → dynamic>} after : before) in #t30;
        if(!hooks.{core::Object::==}(null))
          listeners.{core::List::addAll}(isAfter.{core::Object::==}(true) ?{core::List<(hoo::HookedServiceEvent) → dynamic>} hooks.{met::Hooks::after} : hooks.{met::Hooks::before});
        listeners.{core::Iterable::forEach}(dispatcher.{hoo::HookedServiceEventDispatcher::listen});
      }
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::index}, this.{hoo::HookedService::beforeIndexed});
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::read}, this.{hoo::HookedService::beforeRead});
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::create}, this.{hoo::HookedService::beforeCreated});
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::modify}, this.{hoo::HookedService::beforeModified});
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::update}, this.{hoo::HookedService::beforeUpdated});
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::remove}, this.{hoo::HookedService::beforeRemoved});
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::index}, this.{hoo::HookedService::afterIndexed}, true);
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::read}, this.{hoo::HookedService::afterRead}, true);
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::create}, this.{hoo::HookedService::afterCreated}, true);
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::modify}, this.{hoo::HookedService::afterModified}, true);
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::update}, this.{hoo::HookedService::afterUpdated}, true);
      applyListeners.call(this.{hoo::HookedService::inner}.{ser4::Service::remove}, this.{hoo::HookedService::afterRemoved}, true);
    }
    get bootstrappers() → core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>
      return let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t32 = core::List::from<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>(super.{ser4::Service::bootstrappers}) in let final dynamic #t33 = #t32.{core::List::add}((req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → core::bool {
        let final core::Map<dynamic, dynamic> #t34 = req.{req::RequestContext::serviceParams} in let final dynamic #t35 = #t34.{core::Map::[]=}("__requestctx", req) in let final dynamic #t36 = #t34.{core::Map::[]=}("__responsectx", res) in #t34;
        return true;
      }) in #t32;
    method addRoutes([ser4::Service s = null]) → void {
      super.{ser4::Service::addRoutes}(let final ser4::Service #t37 = s in #t37.==(null) ?{ser4::Service} this.{hoo::HookedService::inner} : #t37);
    }
    method before(core::Iterable<core::String> eventNames, (hoo::HookedServiceEvent) → dynamic listener) → void {
      eventNames.{core::Iterable::map}<hoo::HookedServiceEventDispatcher>((core::String name) → hoo::HookedServiceEventDispatcher {
        switch(name) {
          #L1:
          case hoo::HookedServiceEvent::indexed:
            {
              return this.{hoo::HookedService::beforeIndexed};
            }
          #L2:
          case hoo::HookedServiceEvent::read:
            {
              return this.{hoo::HookedService::beforeRead};
            }
          #L3:
          case hoo::HookedServiceEvent::created:
            {
              return this.{hoo::HookedService::beforeCreated};
            }
          #L4:
          case hoo::HookedServiceEvent::modified:
            {
              return this.{hoo::HookedService::beforeModified};
            }
          #L5:
          case hoo::HookedServiceEvent::updated:
            {
              return this.{hoo::HookedService::beforeUpdated};
            }
          #L6:
          case hoo::HookedServiceEvent::removed:
            {
              return this.{hoo::HookedService::beforeRemoved};
            }
          #L7:
          default:
            {
              throw new core::ArgumentError::•("Invalid service method: ${name}");
            }
        }
      }).{core::Iterable::forEach}((hoo::HookedServiceEventDispatcher dispatcher) → void => dispatcher.{hoo::HookedServiceEventDispatcher::listen}(listener));
    }
    method after(core::Iterable<core::String> eventNames, (hoo::HookedServiceEvent) → dynamic listener) → void {
      eventNames.{core::Iterable::map}<hoo::HookedServiceEventDispatcher>((core::String name) → hoo::HookedServiceEventDispatcher {
        switch(name) {
          #L8:
          case hoo::HookedServiceEvent::indexed:
            {
              return this.{hoo::HookedService::afterIndexed};
            }
          #L9:
          case hoo::HookedServiceEvent::read:
            {
              return this.{hoo::HookedService::afterRead};
            }
          #L10:
          case hoo::HookedServiceEvent::created:
            {
              return this.{hoo::HookedService::afterCreated};
            }
          #L11:
          case hoo::HookedServiceEvent::modified:
            {
              return this.{hoo::HookedService::afterModified};
            }
          #L12:
          case hoo::HookedServiceEvent::updated:
            {
              return this.{hoo::HookedService::afterUpdated};
            }
          #L13:
          case hoo::HookedServiceEvent::removed:
            {
              return this.{hoo::HookedService::afterRemoved};
            }
          #L14:
          default:
            {
              throw new core::ArgumentError::•("Invalid service method: ${name}");
            }
        }
      }).{core::Iterable::forEach}((hoo::HookedServiceEventDispatcher dispatcher) → void => dispatcher.{hoo::HookedServiceEventDispatcher::listen}(listener));
    }
    method beforeAll((hoo::HookedServiceEvent) → dynamic listener) → void {
      this.{hoo::HookedService::beforeIndexed}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::beforeRead}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::beforeCreated}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::beforeModified}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::beforeUpdated}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::beforeRemoved}.{hoo::HookedServiceEventDispatcher::listen}(listener);
    }
    method afterAll((hoo::HookedServiceEvent) → dynamic listener) → void {
      this.{hoo::HookedService::afterIndexed}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::afterRead}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::afterCreated}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::afterModified}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::afterUpdated}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::afterRemoved}.{hoo::HookedServiceEventDispatcher::listen}(listener);
    }
    method beforeAllStream() → asy::Stream<hoo::HookedServiceEvent> {
      asy::StreamController<hoo::HookedServiceEvent> ctrl = asy::StreamController::•<hoo::HookedServiceEvent>();
      this.{hoo::HookedService::_ctrl}.{core::List::add}(ctrl);
      this.{hoo::HookedService::before}(hoo::HookedServiceEvent::all, ctrl.{asy::StreamController::add});
      return ctrl.{asy::StreamController::stream};
    }
    method afterAllStream() → asy::Stream<hoo::HookedServiceEvent> {
      asy::StreamController<hoo::HookedServiceEvent> ctrl = asy::StreamController::•<hoo::HookedServiceEvent>();
      this.{hoo::HookedService::_ctrl}.{core::List::add}(ctrl);
      this.{hoo::HookedService::before}(hoo::HookedServiceEvent::all, ctrl.{asy::StreamController::add});
      return ctrl.{asy::StreamController::stream};
    }
    method beforeStream(core::Iterable<core::String> eventNames) → asy::Stream<hoo::HookedServiceEvent> {
      asy::StreamController<hoo::HookedServiceEvent> ctrl = asy::StreamController::•<hoo::HookedServiceEvent>();
      this.{hoo::HookedService::_ctrl}.{core::List::add}(ctrl);
      this.{hoo::HookedService::before}(eventNames, ctrl.{asy::StreamController::add});
      return ctrl.{asy::StreamController::stream};
    }
    method afterStream(core::Iterable<core::String> eventNames) → asy::Stream<hoo::HookedServiceEvent> {
      asy::StreamController<hoo::HookedServiceEvent> ctrl = asy::StreamController::•<hoo::HookedServiceEvent>();
      this.{hoo::HookedService::_ctrl}.{core::List::add}(ctrl);
      this.{hoo::HookedService::after}(eventNames, ctrl.{asy::StreamController::add});
      return ctrl.{asy::StreamController::stream};
    }
    method beforeModify((hoo::HookedServiceEvent) → dynamic listener) → void {
      this.{hoo::HookedService::beforeCreated}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::beforeModified}.{hoo::HookedServiceEventDispatcher::listen}(listener);
      this.{hoo::HookedService::beforeUpdated}.{hoo::HookedServiceEventDispatcher::listen}(listener);
    }
    @core::override
    method index([core::Map<dynamic, dynamic> _params = null]) → asy::Future<dynamic> {
      core::Map<dynamic, dynamic> params = this.{hoo::HookedService::_stripReq}(_params);
      return this.{hoo::HookedService::beforeIndexed}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(false, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::indexed, params: params)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent before) → asy::Future<dynamic> {
        if(before.{hoo::HookedServiceEvent::_canceled}) {
          return this.{hoo::HookedService::beforeIndexed}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::indexed, params: params, result: before.{hoo::HookedServiceEvent::result})).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        }
        return this.{hoo::HookedService::inner}.{ser4::Service::index}(params).{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> {
          return this.{hoo::HookedService::afterIndexed}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::indexed, params: params, result: result)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        });
      });
    }
    @core::override
    method read(dynamic id, [core::Map<dynamic, dynamic> _params = null]) → asy::Future<dynamic> {
      core::Map<dynamic, dynamic> params = this.{hoo::HookedService::_stripReq}(_params);
      return this.{hoo::HookedService::beforeRead}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(false, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::read, id: id, params: params)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent before) → asy::Future<dynamic> {
        if(before.{hoo::HookedServiceEvent::_canceled}) {
          return this.{hoo::HookedService::beforeRead}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::read, id: id, params: params, result: before.{hoo::HookedServiceEvent::result})).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        }
        return this.{hoo::HookedService::inner}.{ser4::Service::read}(id, params).{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> {
          return this.{hoo::HookedService::afterRead}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::read, id: id, params: params, result: result)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        });
      });
    }
    @core::override
    method create(dynamic data, [core::Map<dynamic, dynamic> _params = null]) → asy::Future<dynamic> {
      core::Map<dynamic, dynamic> params = this.{hoo::HookedService::_stripReq}(_params);
      return this.{hoo::HookedService::beforeCreated}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(false, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::created, data: data, params: params)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent before) → asy::Future<dynamic> {
        if(before.{hoo::HookedServiceEvent::_canceled}) {
          return this.{hoo::HookedService::beforeCreated}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::created, data: data, params: params, result: before.{hoo::HookedServiceEvent::result})).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        }
        return this.{hoo::HookedService::inner}.{ser4::Service::create}(data, params).{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> {
          return this.{hoo::HookedService::afterCreated}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::created, data: data, params: params, result: result)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        });
      });
    }
    @core::override
    method modify(dynamic id, dynamic data, [core::Map<dynamic, dynamic> _params = null]) → asy::Future<dynamic> {
      core::Map<dynamic, dynamic> params = this.{hoo::HookedService::_stripReq}(_params);
      return this.{hoo::HookedService::beforeModified}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(false, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::modified, id: id, data: data, params: params)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent before) → asy::Future<dynamic> {
        if(before.{hoo::HookedServiceEvent::_canceled}) {
          return this.{hoo::HookedService::beforeModified}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::modified, id: id, data: data, params: params, result: before.{hoo::HookedServiceEvent::result})).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        }
        return this.{hoo::HookedService::inner}.{ser4::Service::modify}(id, data, params).{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> {
          return this.{hoo::HookedService::afterModified}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::created, id: id, data: data, params: params, result: result)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        });
      });
    }
    @core::override
    method update(dynamic id, dynamic data, [core::Map<dynamic, dynamic> _params = null]) → asy::Future<dynamic> {
      core::Map<dynamic, dynamic> params = this.{hoo::HookedService::_stripReq}(_params);
      return this.{hoo::HookedService::beforeUpdated}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(false, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::updated, id: id, data: data, params: params)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent before) → asy::Future<dynamic> {
        if(before.{hoo::HookedServiceEvent::_canceled}) {
          return this.{hoo::HookedService::beforeUpdated}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::updated, id: id, data: data, params: params, result: before.{hoo::HookedServiceEvent::result})).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        }
        return this.{hoo::HookedService::inner}.{ser4::Service::update}(id, data, params).{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> {
          return this.{hoo::HookedService::afterUpdated}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::updated, id: id, data: data, params: params, result: result)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        });
      });
    }
    @core::override
    method remove(dynamic id, [core::Map<dynamic, dynamic> _params = null]) → asy::Future<dynamic> {
      core::Map<dynamic, dynamic> params = this.{hoo::HookedService::_stripReq}(_params);
      return this.{hoo::HookedService::beforeRemoved}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(false, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::removed, id: id, params: params)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent before) → asy::Future<dynamic> {
        if(before.{hoo::HookedServiceEvent::_canceled}) {
          return this.{hoo::HookedService::beforeRemoved}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::removed, id: id, params: params, result: before.{hoo::HookedServiceEvent::result})).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        }
        return this.{hoo::HookedService::inner}.{ser4::Service::remove}(id, params).{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> {
          return this.{hoo::HookedService::afterRemoved}.{hoo::HookedServiceEventDispatcher::_emit}(new hoo::HookedServiceEvent::•(true, this.{hoo::HookedService::_getRequest}(_params), this.{hoo::HookedService::_getResponse}(_params), this.{hoo::HookedService::inner}, hoo::HookedServiceEvent::removed, id: id, params: params, result: result)).{asy::Future::then}<dynamic>((hoo::HookedServiceEvent after) → dynamic => after.{hoo::HookedServiceEvent::result});
        });
      });
    }
    method fire(core::String eventName, dynamic result, [(hoo::HookedServiceEvent) → dynamic callback = null]) → asy::Future<hoo::HookedServiceEvent> {
      hoo::HookedServiceEventDispatcher dispatcher;
      #L15:
      switch(eventName) {
        #L16:
        case hoo::HookedServiceEvent::indexed:
          {
            dispatcher = this.{hoo::HookedService::afterIndexed};
            break #L15;
          }
        #L17:
        case hoo::HookedServiceEvent::read:
          {
            dispatcher = this.{hoo::HookedService::afterRead};
            break #L15;
          }
        #L18:
        case hoo::HookedServiceEvent::created:
          {
            dispatcher = this.{hoo::HookedService::afterCreated};
            break #L15;
          }
        #L19:
        case hoo::HookedServiceEvent::modified:
          {
            dispatcher = this.{hoo::HookedService::afterModified};
            break #L15;
          }
        #L20:
        case hoo::HookedServiceEvent::updated:
          {
            dispatcher = this.{hoo::HookedService::afterUpdated};
            break #L15;
          }
        #L21:
        case hoo::HookedServiceEvent::removed:
          {
            dispatcher = this.{hoo::HookedService::afterRemoved};
            break #L15;
          }
        #L22:
        default:
          {
            throw new core::ArgumentError::•("Invalid service event name: '${eventName}'");
          }
      }
      hoo::HookedServiceEvent ev = new hoo::HookedServiceEvent::•(true, null, null, this, eventName);
      return this.{hoo::HookedService::fireEvent}(dispatcher, ev, callback);
    }
    method fireEvent(hoo::HookedServiceEventDispatcher dispatcher, hoo::HookedServiceEvent event, [(hoo::HookedServiceEvent) → dynamic callback = null]) → asy::Future<hoo::HookedServiceEvent> {
      asy::Future<dynamic> f;
      if(!callback.{core::Object::==}(null) && !(let final hoo::HookedServiceEvent #t38 = event in #t38.==(null) ?{core::bool} null : #t38.{hoo::HookedServiceEvent::_canceled}).{core::Object::==}(true))
        f = asy::Future::sync<dynamic>(() → dynamic => callback.call(event));
      f.{core::Object::==}(null) ?{asy::Future<dynamic>} f = asy::Future::value<dynamic>() : null;
      return f.{asy::Future::then}<hoo::HookedServiceEvent>((dynamic _) → asy::Future<hoo::HookedServiceEvent> => dispatcher.{hoo::HookedServiceEventDispatcher::_emit}(event));
    }
  }
  class HookedServiceEvent extends core::Object {
    static const field core::String indexed = "indexed";
    static const field core::String read = "read";
    static const field core::String created = "created";
    static const field core::String modified = "modified";
    static const field core::String updated = "updated";
    static const field core::String removed = "removed";
    static const field core::List<core::String> all = const <core::String>[hoo::HookedServiceEvent::indexed, hoo::HookedServiceEvent::read, hoo::HookedServiceEvent::created, hoo::HookedServiceEvent::modified, hoo::HookedServiceEvent::updated, hoo::HookedServiceEvent::removed];
    field core::bool _canceled = false;
    field core::String _eventName;
    field dynamic _id = null;
    field core::bool _isAfter;
    field dynamic data;
    field core::Map<dynamic, dynamic> _params = null;
    field req::RequestContext<dynamic> _request;
    field res::ResponseContext<dynamic> _response;
    field dynamic result;
    field ser4::Service service;
    constructor •(core::bool _isAfter, req::RequestContext<dynamic> _request, res::ResponseContext<dynamic> _response, ser4::Service service, core::String _eventName, {dynamic id = null, dynamic data = null, core::Map<dynamic, dynamic> params = null, dynamic result = null}) → void
      : hoo::HookedServiceEvent::_isAfter = _isAfter, hoo::HookedServiceEvent::_request = _request, hoo::HookedServiceEvent::_response = _response, hoo::HookedServiceEvent::service = service, hoo::HookedServiceEvent::_eventName = _eventName, hoo::HookedServiceEvent::data = data, hoo::HookedServiceEvent::result = result, super core::Object::•() {
      this.{hoo::HookedServiceEvent::_id} = id;
      this.{hoo::HookedServiceEvent::_params} = let final core::Map<dynamic, dynamic> #t39 = params in #t39.==(null) ?{core::Map<dynamic, dynamic>} <dynamic, dynamic>{} : #t39;
    }
    method cancel([dynamic result = null]) → void {
      this.{hoo::HookedServiceEvent::_canceled} = true;
      this.{hoo::HookedServiceEvent::result} = let final dynamic #t40 = result in #t40.==(null) ?{dynamic} this.{hoo::HookedServiceEvent::result} : #t40;
    }
    method getService(core::Pattern path) → ser4::Service
      return this.{hoo::HookedServiceEvent::service}.{ser4::Service::app}.{rou::Routable::service}(path);
    get eventName() → core::String
      return this.{hoo::HookedServiceEvent::_eventName};
    get id() → dynamic
      return this.{hoo::HookedServiceEvent::_id};
    get isAfter() → core::bool
      return this.{hoo::HookedServiceEvent::_isAfter}.{core::Object::==}(true);
    get isBefore() → core::bool
      return !this.{hoo::HookedServiceEvent::isAfter};
    get params() → core::Map<dynamic, dynamic>
      return this.{hoo::HookedServiceEvent::_params};
    get request() → req::RequestContext<dynamic>
      return this.{hoo::HookedServiceEvent::_request};
    get response() → res::ResponseContext<dynamic>
      return this.{hoo::HookedServiceEvent::_response};
  }
  class HookedServiceEventDispatcher extends core::Object {
    final field core::List<asy::StreamController<hoo::HookedServiceEvent>> _ctrl = <asy::StreamController<hoo::HookedServiceEvent>>[];
    final field core::List<(hoo::HookedServiceEvent) → dynamic> listeners = <(hoo::HookedServiceEvent) → dynamic>[];
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    method _close() → void {
      this.{hoo::HookedServiceEventDispatcher::_ctrl}.{core::Iterable::forEach}((asy::StreamController<hoo::HookedServiceEvent> c) → void => c.{asy::StreamController::close}());
      this.{hoo::HookedServiceEventDispatcher::listeners}.{core::List::clear}();
    }
    method _emit(hoo::HookedServiceEvent event) → asy::Future<hoo::HookedServiceEvent> {
      if((let final hoo::HookedServiceEvent #t41 = event in #t41.==(null) ?{core::bool} null : #t41.{hoo::HookedServiceEvent::_canceled}).{core::Object::==}(true) || event.{core::Object::==}(null) || this.{hoo::HookedServiceEventDispatcher::listeners}.{core::Iterable::isEmpty})
        return asy::Future::value<hoo::HookedServiceEvent>(event);
      asy::Future<hoo::HookedServiceEvent> f = asy::Future::value<hoo::HookedServiceEvent>(event);
      for ((hoo::HookedServiceEvent) → dynamic listener in this.{hoo::HookedServiceEventDispatcher::listeners}) {
        f = f.{asy::Future::then}<hoo::HookedServiceEvent>((hoo::HookedServiceEvent event) → asy::FutureOr<hoo::HookedServiceEvent> {
          if(event.{hoo::HookedServiceEvent::_canceled})
            return event;
          return asy::Future::sync<dynamic>(() → dynamic => listener.call(event)).{asy::Future::then}<hoo::HookedServiceEvent>((dynamic _) → hoo::HookedServiceEvent => event);
        });
      }
      return f;
    }
    method asStream() → asy::Stream<hoo::HookedServiceEvent> {
      asy::StreamController<hoo::HookedServiceEvent> ctrl = asy::StreamController::•<hoo::HookedServiceEvent>();
      this.{hoo::HookedServiceEventDispatcher::_ctrl}.{core::List::add}(ctrl);
      this.{hoo::HookedServiceEventDispatcher::listen}(ctrl.{asy::StreamController::add});
      return ctrl.{asy::StreamController::stream};
    }
    method listen((hoo::HookedServiceEvent) → dynamic listener) → void {
      this.{hoo::HookedServiceEventDispatcher::listeners}.{core::List::add}(listener);
    }
  }
}
library from "package:angel_framework/src/core/map_service.dart" as map {
  import "dart:async";
  import "package:angel_http_exception/angel_http_exception.dart";
  import "package:angel_framework/src/core/service.dart";
  class MapService extends ser4::Service {
    final field core::bool allowRemoveAll;
    final field core::bool allowQuery;
    final field core::bool autoIdAndDateFields;
    final field core::bool autoSnakeCaseNames;
    final field core::List<core::Map<core::String, dynamic>> items = <core::Map<core::String, dynamic>>[];
    constructor •({core::bool allowRemoveAll = false, core::bool allowQuery = true, core::bool autoIdAndDateFields = true, core::bool autoSnakeCaseNames = true}) → void
      : map::MapService::allowRemoveAll = allowRemoveAll, map::MapService::allowQuery = allowQuery, map::MapService::autoIdAndDateFields = autoIdAndDateFields, map::MapService::autoSnakeCaseNames = autoSnakeCaseNames, super ser4::Service::•()
      ;
    get createdAtKey() → core::String
      return this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "createdAt" : "created_at";
    get updatedAtKey() → core::String
      return this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "updatedAt" : "updated_at";
    method _matchesId(dynamic id) → (core::Map<dynamic, dynamic>) → core::bool {
      return (core::Map<dynamic, dynamic> item) → core::bool {
        if(item.{core::Map::[]}("id").{core::Object::==}(null))
          return false;
        else
          if(!this.{map::MapService::autoIdAndDateFields}.{core::Object::==}(false))
            return item.{core::Map::[]}("id").{core::Object::==}(let final dynamic #t42 = id in #t42.==(null) ?{core::String} null : #t42.{core::Object::toString}());
          else
            return item.{core::Map::[]}("id").{core::Object::==}(id);
      };
    }
    @core::override
    method index([core::Map<dynamic, dynamic> params = null]) → asy::Future<core::List<dynamic>> {
      if(this.{map::MapService::allowQuery}.{core::Object::==}(false) || params.{core::Object::==}(null) || !(params.{core::Map::[]}("query") is core::Map<dynamic, dynamic>))
        return asy::Future::value<core::List<dynamic>>(this.{map::MapService::items});
      else {
        core::Map<dynamic, dynamic> query = params.{core::Map::[]}("query") as{TypeError} core::Map<dynamic, dynamic>;
        return asy::Future::value<core::List<dynamic>>(this.{map::MapService::items}.{core::Iterable::where}((core::Map<core::String, dynamic> item) → core::bool {
          for (dynamic key in query.{core::Map::keys}) {
            if(!item.{core::Map::containsKey}(key))
              return false;
            else
              if(!item.{core::Map::[]}(key).{core::Object::==}(query.{core::Map::[]}(key)))
                return false;
          }
          return true;
        }).{core::Iterable::toList}());
      }
    }
    @core::override
    method read(dynamic id, [core::Map<dynamic, dynamic> params = null]) → asy::Future<core::Map<dynamic, dynamic>> {
      return asy::Future::value<core::Map<dynamic, dynamic>>(this.{map::MapService::items}.{core::Iterable::firstWhere}(this.{map::MapService::_matchesId}(id), orElse: () → <BottomType>=> throw ang3::AngelHttpException::notFound(message: "No record found for ID ${id}")));
    }
    @core::override
    method create(dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<core::Map<dynamic, dynamic>> {
      if(!(data is core::Map<dynamic, dynamic>))
        throw ang3::AngelHttpException::badRequest(message: "MapService does not support `create` with ${data.{core::Object::runtimeType}}.");
      core::String now = new core::DateTime::now().{core::DateTime::toIso8601String}();
      core::Map<dynamic, dynamic> result = data as core::Map<dynamic, dynamic>;
      if(this.{map::MapService::autoIdAndDateFields}.{core::Object::==}(true)) {
        let final core::Map<dynamic, dynamic> #t43 = result in let final dynamic #t44 = #t43.{core::Map::[]=}("id", this.{map::MapService::items}.{core::List::length}.{core::int::toString}()) in let final dynamic #t45 = #t43.{core::Map::[]=}(this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "createdAt" : "created_at", now) in let final dynamic #t46 = #t43.{core::Map::[]=}(this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "updatedAt" : "updated_at", now) in #t43;
      }
      this.{map::MapService::items}.{core::List::add}(this.{map::MapService::_foldStringDynamic}(result));
      return asy::Future::value<core::Map<dynamic, dynamic>>(result);
    }
    method _foldStringDynamic(core::Map<dynamic, dynamic> map) → core::Map<core::String, dynamic> {
      return map.{core::Object::==}(null) ?{core::Map<core::String, dynamic>} null : map.{core::Map::keys}.{core::Iterable::fold}<core::Map<core::String, dynamic>>(<core::String, dynamic>{}, (core::Map<core::String, dynamic> out, dynamic k) → core::Map<core::String, dynamic> => let final core::Map<core::String, dynamic> #t47 = out in let final dynamic #t48 = #t47.{core::Map::[]=}(k.{core::Object::toString}(), map.{core::Map::[]}(k)) in #t47);
    }
    @core::override
    method modify(dynamic id, dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<core::Map<dynamic, dynamic>> {
      if(!(data is core::Map<dynamic, dynamic>))
        throw ang3::AngelHttpException::badRequest(message: "MapService does not support `modify` with ${data.{core::Object::runtimeType}}.");
      if(!this.{map::MapService::items}.{core::Iterable::any}(this.{map::MapService::_matchesId}(id)))
        return this.{map::MapService::create}(data, params);
      return this.{map::MapService::read}(id).{asy::Future::then}<core::Map<dynamic, dynamic>>((core::Map<dynamic, dynamic> item) → asy::Future<core::Map<dynamic, dynamic>> {
        core::Map<dynamic, dynamic> result = let final core::Map<dynamic, dynamic> #t49 = item in let final dynamic #t50 = #t49.{core::Map::addAll}(data as core::Map<dynamic, dynamic>) in #t49;
        if(this.{map::MapService::autoIdAndDateFields}.{core::Object::==}(true))
          let final core::Map<dynamic, dynamic> #t51 = result in let final dynamic #t52 = #t51.{core::Map::[]=}(this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "updatedAt" : "updated_at", new core::DateTime::now().{core::DateTime::toIso8601String}()) in #t51;
        return asy::Future::value<core::Map<dynamic, dynamic>>(result);
      });
    }
    @core::override
    method update(dynamic id, dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<core::Map<dynamic, dynamic>> {
      if(!(data is core::Map<dynamic, dynamic>))
        throw ang3::AngelHttpException::badRequest(message: "MapService does not support `update` with ${data.{core::Object::runtimeType}}.");
      if(!this.{map::MapService::items}.{core::Iterable::any}(this.{map::MapService::_matchesId}(id)))
        return this.{map::MapService::create}(data, params);
      return this.{map::MapService::read}(id).{asy::Future::then}<core::Map<dynamic, dynamic>>((core::Map<dynamic, dynamic> old) → asy::Future<core::Map<dynamic, dynamic>> {
        if(!this.{map::MapService::items}.{core::List::remove}(old))
          throw ang3::AngelHttpException::notFound(message: "No record found for ID ${id}");
        core::Map<dynamic, dynamic> result = data as core::Map<dynamic, dynamic>;
        if(this.{map::MapService::autoIdAndDateFields}.{core::Object::==}(true)) {
          let final core::Map<dynamic, dynamic> #t53 = result in let final dynamic #t54 = #t53.{core::Map::[]=}("id", let final dynamic #t55 = id in #t55.==(null) ?{core::String} null : #t55.{core::Object::toString}()) in let final dynamic #t56 = #t53.{core::Map::[]=}(this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "createdAt" : "created_at", old.{core::Map::[]}(this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "createdAt" : "created_at")) in let final dynamic #t57 = #t53.{core::Map::[]=}(this.{map::MapService::autoSnakeCaseNames}.{core::Object::==}(false) ?{core::String} "updatedAt" : "updated_at", new core::DateTime::now().{core::DateTime::toIso8601String}()) in #t53;
        }
        this.{map::MapService::items}.{core::List::add}(this.{map::MapService::_foldStringDynamic}(result));
        return asy::Future::value<core::Map<dynamic, dynamic>>(result);
      });
    }
    @core::override
    method remove(dynamic id, [core::Map<dynamic, dynamic> params = null]) → asy::Future<core::Map<dynamic, dynamic>> {
      if(id.{core::Object::==}(null) || id.{core::Object::==}("null") && (this.{map::MapService::allowRemoveAll}.{core::Object::==}(true) || !(let final core::Map<dynamic, dynamic> #t58 = params in #t58.==(null) ?{core::bool} null : #t58.{core::Map::containsKey}("provider")).{core::Object::==}(true))) {
        this.{map::MapService::items}.{core::List::clear}();
        return asy::Future::value<core::Map<dynamic, dynamic>>(<dynamic, dynamic>{});
      }
      return this.{map::MapService::read}(id, params).{asy::Future::then}<core::Map<dynamic, dynamic>>((core::Map<dynamic, dynamic> result) → core::Map<dynamic, dynamic> {
        if(this.{map::MapService::items}.{core::List::remove}(result))
          return result;
        else
          throw ang3::AngelHttpException::notFound(message: "No record found for ID ${id}");
      });
    }
  }
}
library angel_framework.http.metadata from "package:angel_framework/src/core/metadata.dart" as met {
  import "package:angel_http_exception/angel_http_exception.dart";
  import "package:angel_framework/src/core/hooked_service.dart";
  import "package:angel_framework/src/core/request_context.dart";
  import "package:angel_framework/src/core/routable.dart";
  class Middleware extends core::Object {
    final field core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlers;
    const constructor •(core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlers) → void
      : met::Middleware::handlers = handlers, super core::Object::•()
      ;
  }
  class Hooks extends core::Object {
    final field core::List<(hoo::HookedServiceEvent) → dynamic> before;
    final field core::List<(hoo::HookedServiceEvent) → dynamic> after;
    const constructor •({core::List<(hoo::HookedServiceEvent) → dynamic> before = const <(hoo::HookedServiceEvent) → dynamic>[], core::List<(hoo::HookedServiceEvent) → dynamic> after = const <(hoo::HookedServiceEvent) → dynamic>[]}) → void
      : met::Hooks::before = before, met::Hooks::after = after, super core::Object::•()
      ;
  }
  class Expose extends core::Object {
    final field core::String method;
    final field core::String path;
    final field core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> middleware;
    final field core::String as;
    final field core::List<core::String> allowNull;
    const constructor •(core::String path, {core::String method = "GET", core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> middleware = const <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[], core::String as = null, core::List<core::String> allowNull = const <core::String>[]}) → void
      : met::Expose::path = path, met::Expose::method = method, met::Expose::middleware = middleware, met::Expose::as = as, met::Expose::allowNull = allowNull, super core::Object::•()
      ;
  }
  class Parameter extends core::Object {
    final field core::String cookie;
    final field core::String header;
    final field core::String session;
    final field core::String query;
    final field dynamic match;
    final field dynamic defaultValue;
    final field core::bool required;
    const constructor •({core::String cookie = null, core::String query = null, core::String header = null, core::String session = null, dynamic match = null, dynamic defaultValue = null, core::bool required = null}) → void
      : met::Parameter::cookie = cookie, met::Parameter::query = query, met::Parameter::header = header, met::Parameter::session = session, met::Parameter::match = match, met::Parameter::defaultValue = defaultValue, met::Parameter::required = required, super core::Object::•()
      ;
    get error() → dynamic {
      if((let final core::String #t59 = this.{met::Parameter::cookie} in #t59.==(null) ?{core::bool} null : #t59.{core::String::isNotEmpty}).{core::Object::==}(true))
        return ang3::AngelHttpException::badRequest(message: "Missing required cookie \"${this.{met::Parameter::cookie}}\".");
      if((let final core::String #t60 = this.{met::Parameter::header} in #t60.==(null) ?{core::bool} null : #t60.{core::String::isNotEmpty}).{core::Object::==}(true))
        return ang3::AngelHttpException::badRequest(message: "Missing required header \"${this.{met::Parameter::header}}\".");
      if((let final core::String #t61 = this.{met::Parameter::query} in #t61.==(null) ?{core::bool} null : #t61.{core::String::isNotEmpty}).{core::Object::==}(true))
        return ang3::AngelHttpException::badRequest(message: "Missing required query parameter \"${this.{met::Parameter::query}}\".");
      if((let final core::String #t62 = this.{met::Parameter::session} in #t62.==(null) ?{core::bool} null : #t62.{core::String::isNotEmpty}).{core::Object::==}(true))
        return new core::StateError::•("Session does not contain required key \"${this.{met::Parameter::session}}\".");
    }
    method getValue(req::RequestContext<dynamic> req) → dynamic {
      if((let final core::String #t63 = this.{met::Parameter::cookie} in #t63.==(null) ?{core::bool} null : #t63.{core::String::isNotEmpty}).{core::Object::==}(true))
        return let final core::String #t64 = let final _ht::Cookie #t65 = req.{req::RequestContext::cookies}.{core::Iterable::firstWhere}((_ht::Cookie c) → core::bool => c.{_ht::Cookie::name}.{core::String::==}(this.{met::Parameter::cookie})) in #t65.==(null) ?{core::String} null : #t65.{_ht::Cookie::value} in #t64.==(null) ?{dynamic} this.{met::Parameter::defaultValue} : #t64;
      if((let final core::String #t66 = this.{met::Parameter::header} in #t66.==(null) ?{core::bool} null : #t66.{core::String::isNotEmpty}).{core::Object::==}(true))
        return let final core::String #t67 = req.{req::RequestContext::headers}.{_ht::HttpHeaders::value}(this.{met::Parameter::header}) in #t67.==(null) ?{dynamic} this.{met::Parameter::defaultValue} : #t67;
      if((let final core::String #t68 = this.{met::Parameter::session} in #t68.==(null) ?{core::bool} null : #t68.{core::String::isNotEmpty}).{core::Object::==}(true))
        return let final dynamic #t69 = req.{req::RequestContext::session}.{core::Map::[]}(this.{met::Parameter::session}) in #t69.==(null) ?{dynamic} this.{met::Parameter::defaultValue} : #t69;
      if((let final core::String #t70 = this.{met::Parameter::query} in #t70.==(null) ?{core::bool} null : #t70.{core::String::isNotEmpty}).{core::Object::==}(true))
        return let final core::String #t71 = req.{req::RequestContext::uri}.{core::Uri::queryParameters}.{core::Map::[]}(this.{met::Parameter::query}) in #t71.==(null) ?{dynamic} this.{met::Parameter::defaultValue} : #t71;
      return this.{met::Parameter::defaultValue};
    }
  }
  class Header extends met::Parameter {
    const constructor •(core::String header, {dynamic match = null, dynamic defaultValue = null, core::bool required = true}) → void
      : super met::Parameter::•(header: header, match: match, defaultValue: defaultValue, required: required)
      ;
  }
  class Session extends met::Parameter {
    const constructor •(core::String session, {dynamic match = null, dynamic defaultValue = null, core::bool required = true}) → void
      : super met::Parameter::•(session: session, match: match, defaultValue: defaultValue, required: required)
      ;
  }
  class Query extends met::Parameter {
    const constructor •(core::String query, {dynamic match = null, dynamic defaultValue = null, core::bool required = true}) → void
      : super met::Parameter::•(query: query, match: match, defaultValue: defaultValue, required: required)
      ;
  }
  class CookieValue extends met::Parameter {
    const constructor •(core::String cookie, {dynamic match = null, dynamic defaultValue = null, core::bool required = true}) → void
      : super met::Parameter::•(cookie: cookie, match: match, defaultValue: defaultValue, required: required)
      ;
  }
}
library angel_framework.http.request_context from "package:angel_framework/src/core/request_context.dart" as req {
  import "dart:async";
  import "dart:io";
  import "package:angel_container/angel_container.dart";
  import "package:body_parser/body_parser.dart";
  import "package:http_parser/http_parser.dart";
  import "package:meta/meta.dart";
  import "package:path/path.dart" as p;
  import "package:angel_framework/src/core/metadata.dart";
  import "package:angel_framework/src/core/response_context.dart";
  import "package:angel_framework/src/core/routable.dart";
  import "package:angel_framework/src/core/server.dart";
  abstract class RequestContext<RawRequest extends core::Object = dynamic> extends core::Object {
    field core::String _acceptHeaderCache = null;
    field core::String _extensionCache = null;
    field core::bool _acceptsAllCache = null;
    field bod::BodyParseResult _body = null;
    field core::Map<dynamic, dynamic> _provisionalQuery = null;
    final field core::Map<dynamic, dynamic> serviceParams = <dynamic, dynamic>{};
    field ser::Angel app = null;
    field core::Map<core::String, dynamic> params = <core::String, dynamic>{};
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get rawRequest() → req::RequestContext::RawRequest;
    abstract get cookies() → core::List<_ht::Cookie>;
    abstract get headers() → _ht::HttpHeaders;
    abstract get hostname() → core::String;
    abstract get container() → con::Container;
    get ip() → core::String
      return this.{req::RequestContext::remoteAddress}.{io::InternetAddress::address};
    abstract get method() → core::String;
    abstract get originalMethod() → core::String;
    abstract get contentType() → med::MediaType;
    abstract get path() → core::String;
    abstract get remoteAddress() → io::InternetAddress;
    abstract get session() → _ht::HttpSession;
    abstract get uri() → core::Uri;
    abstract get xhr() → core::bool;
    get extension() → core::String
      return let final core::String #t72 = this.{req::RequestContext::_extensionCache} in #t72.{core::String::==}(null) ?{core::String} this.{req::RequestContext::_extensionCache} = path::extension(this.{req::RequestContext::uri}.{core::Uri::path}) : #t72;
    method accepts(dynamic contentType, {core::bool strict = false}) → core::bool {
      core::String contentTypeString = contentType is med::MediaType ?{core::String} contentType{med::MediaType}.{med::MediaType::mimeType} : let final dynamic #t73 = contentType in #t73.==(null) ?{core::String} null : #t73.{core::Object::toString}();
      if(contentTypeString.{core::String::==}(null))
        throw new core::ArgumentError::•("RequestContext.accepts expects the `contentType` parameter to NOT be null.");
      this.{req::RequestContext::_acceptHeaderCache}.{core::String::==}(null) ?{core::String} this.{req::RequestContext::_acceptHeaderCache} = this.{req::RequestContext::headers}.{_ht::HttpHeaders::value}("accept") : null;
      if(this.{req::RequestContext::_acceptHeaderCache}.{core::String::==}(null))
        return false;
      else
        if(!strict.{core::Object::==}(true) && this.{req::RequestContext::_acceptHeaderCache}.{core::String::contains}("*/*"))
          return true;
        else
          return this.{req::RequestContext::_acceptHeaderCache}.{core::String::contains}(contentTypeString);
    }
    get acceptsAll() → core::bool
      return let final core::bool #t74 = this.{req::RequestContext::_acceptsAllCache} in #t74.{core::Object::==}(null) ?{core::bool} this.{req::RequestContext::_acceptsAllCache} = this.{req::RequestContext::accepts}("*/*") : #t74;
    method parseBody() → asy::Future<core::Map<dynamic, dynamic>>
      return this.{req::RequestContext::parse}().{asy::Future::then}<core::Map<dynamic, dynamic>>((bod::BodyParseResult b) → core::Map<core::String, dynamic> => b.{bod::BodyParseResult::body});
    method parseUploadedFiles() → asy::Future<core::List<fil::FileUploadInfo>>
      return this.{req::RequestContext::parse}().{asy::Future::then}<core::List<fil::FileUploadInfo>>((bod::BodyParseResult b) → core::List<fil::FileUploadInfo> => b.{bod::BodyParseResult::files});
    method parseRawRequestBuffer() → asy::Future<core::List<core::int>>
      return this.{req::RequestContext::parse}().{asy::Future::then}<core::List<core::int>>((bod::BodyParseResult b) → core::List<core::int> => b.{bod::BodyParseResult::originalBuffer});
    method parseQuery({core::bool forceParse = false}) → asy::Future<core::Map<core::String, dynamic>> {
      if(this.{req::RequestContext::_body}.{core::Object::==}(null) && !forceParse.{core::Object::==}(true))
        return asy::Future::value<core::Map<core::String, dynamic>>(this.{req::RequestContext::uri}.{core::Uri::queryParameters});
      else
        return this.{req::RequestContext::parse}().{asy::Future::then}<core::Map<core::String, dynamic>>((bod::BodyParseResult b) → core::Map<core::String, dynamic> => b.{bod::BodyParseResult::query});
    }
    method parse() → asy::Future<bod::BodyParseResult> {
      if(!this.{req::RequestContext::_body}.{core::Object::==}(null))
        return asy::Future::value<bod::BodyParseResult>(this.{req::RequestContext::_body});
      else
        this.{req::RequestContext::_provisionalQuery} = null;
      return this.{req::RequestContext::parseOnce}().{asy::Future::then}<bod::BodyParseResult>((bod::BodyParseResult body) → bod::BodyParseResult => this.{req::RequestContext::_body} = body);
    }
    @meta::virtual
    abstract method parseOnce() → asy::Future<bod::BodyParseResult>;
    method close() → asy::Future<dynamic> {
      this.{req::RequestContext::_body} = null;
      this.{req::RequestContext::_acceptsAllCache} = null;
      this.{req::RequestContext::_acceptHeaderCache} = null;
      let final core::Map<dynamic, dynamic> #t75 = this.{req::RequestContext::_provisionalQuery} in #t75.==(null) ?{void} null : #t75.{core::Map::clear}();
      this.{req::RequestContext::serviceParams}.{core::Map::clear}();
      this.{req::RequestContext::params}.{core::Map::clear}();
      return asy::Future::value<dynamic>();
    }
  }
  class InjectionRequest extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_framework-2.0.0-alpha.2/lib/src/core/injection.dart
    final field core::Map<core::String, core::Type> named;
    final field core::List<dynamic> required;
    final field core::List<core::String> optional;
    final field core::Map<core::String, met::Parameter> parameters;
    const constructor constant({core::Map<core::String, core::Type> named = const <core::String, core::Type>{}, core::List<dynamic> required = const <dynamic>[], core::List<core::String> optional = const <core::String>[], core::Map<core::String, met::Parameter> parameters = const <core::String, met::Parameter>{}}) → void
      : req::InjectionRequest::named = named, req::InjectionRequest::required = required, req::InjectionRequest::optional = optional, req::InjectionRequest::parameters = parameters, super core::Object::•()
      ;
    constructor •() → void
      : req::InjectionRequest::named = <core::String, core::Type>{}, req::InjectionRequest::required = <dynamic>[], req::InjectionRequest::optional = <core::String>[], req::InjectionRequest::parameters = <core::String, met::Parameter>{}, super core::Object::•()
      ;
  }
  static const field core::List<core::Type> _primitiveTypes = const <core::Type>[core::String, core::int, core::num, core::double, core::Null]/* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_framework-2.0.0-alpha.2/lib/src/core/injection.dart */;
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_framework-2.0.0-alpha.2/lib/src/core/injection.dart */ ioc(core::Function handler, {core::Iterable<core::String> optional = const <core::String>[]}) → (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> {
    req::InjectionRequest injection;
    (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> contained;
    return (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<core::bool> {
      if(injection.{core::Object::==}(null)) {
        injection = req::preInject(handler, req.{req::RequestContext::app}.{rou::Routable::container}.{con::Container::reflector});
        injection.{req::InjectionRequest::optional}.{core::List::addAll}(let final core::Iterable<core::String> #t76 = optional in #t76.==(null) ?{core::Iterable<core::String>} <core::String>[] : #t76);
        contained = req::handleContained(handler, injection);
      }
      return req.{req::RequestContext::app}.{ser::Angel::executeHandler}(contained, req, res);
    };
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_framework-2.0.0-alpha.2/lib/src/core/injection.dart */ resolveInjection(dynamic requirement, req::InjectionRequest injection, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res, core::bool throwOnUnresolved) → dynamic {
    dynamic propFromApp;
    if(requirement.{core::Object::==}(req::RequestContext<dynamic>)) {
      return req;
    }
    else
      if(requirement.{core::Object::==}(res::ResponseContext<dynamic>)) {
        return res;
      }
      else
        if(requirement is core::String && injection.{req::InjectionRequest::parameters}.{core::Map::containsKey}(requirement{core::String})) {
          met::Parameter param = injection.{req::InjectionRequest::parameters}.{core::Map::[]}(requirement{core::String});
          dynamic value = param.{met::Parameter::getValue}(req);
          if(value.{core::Object::==}(null) && !param.{met::Parameter::required}.{core::Object::==}(false))
            throw param.{met::Parameter::error};
          return value;
        }
        else
          if(requirement is core::String) {
            if(req.{req::RequestContext::params}.{core::Map::containsKey}(requirement{core::String})) {
              return req.{req::RequestContext::params}.{core::Map::[]}(requirement{core::String});
            }
            else
              if(!(propFromApp = req.{req::RequestContext::app}.{ser::Angel::findProperty}(requirement{core::String})).{core::Object::==}(null))
                return propFromApp;
              else
                if(injection.{req::InjectionRequest::optional}.{core::Iterable::contains}(requirement{core::String}))
                  return null;
                else
                  if(throwOnUnresolved) {
                    throw new core::ArgumentError::•("Cannot resolve parameter '${requirement{core::String}}' within handler.");
                  }
          }
          else
            if(requirement is core::List<dynamic> && requirement{core::List<dynamic>}.{core::List::length}.{core::num::==}(2) && requirement{core::List<dynamic>}.{core::Iterable::first} is core::String && requirement{core::List<dynamic>}.{core::Iterable::last} is core::Type) {
              core::String key = requirement{core::List<dynamic>}.{core::Iterable::first} as{TypeError} core::String;
              core::Type type = requirement{core::List<dynamic>}.{core::Iterable::last} as{TypeError} core::Type;
              if(req.{req::RequestContext::params}.{core::Map::containsKey}(key) || req.{req::RequestContext::app}.{ser::Angel::configuration}.{core::Map::containsKey}(key) || req::_primitiveTypes.{core::Iterable::contains}(type)) {
                return req::resolveInjection(key, injection, req, res, throwOnUnresolved);
              }
              else
                return req::resolveInjection(type, injection, req, res, throwOnUnresolved);
            }
            else
              if(requirement is core::Type && !requirement{core::Type}.{core::Object::==}(dynamic)) {
                return req.{req::RequestContext::app}.{rou::Routable::container}.{con::Container::make}<dynamic>(requirement{core::Type});
              }
              else
                if(throwOnUnresolved) {
                  throw new core::ArgumentError::•("${requirement} cannot be injected into a request handler.");
                }
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_framework-2.0.0-alpha.2/lib/src/core/injection.dart */ suitableForInjection(req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res, req::InjectionRequest injection) → core::bool {
    return injection.{req::InjectionRequest::parameters}.{core::Map::values}.{core::Iterable::any}((met::Parameter p) → core::bool {
      if(p.{met::Parameter::match}.{core::Object::==}(null))
        return false;
      dynamic value = p.{met::Parameter::getValue}(req);
      return value.{core::Object::==}(p.{met::Parameter::match});
    });
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_framework-2.0.0-alpha.2/lib/src/core/injection.dart */ handleContained(core::Function handler, req::InjectionRequest injection) → (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> {
    return (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → dynamic {
      if(injection.{req::InjectionRequest::parameters}.{core::Map::isNotEmpty} && injection.{req::InjectionRequest::parameters}.{core::Map::values}.{core::Iterable::any}((met::Parameter p) → core::bool => !p.{met::Parameter::match}.{core::Object::==}(null)) && !req::suitableForInjection(req, res, injection))
        return asy::Future::value<dynamic>(true);
      core::List<dynamic> args = <dynamic>[];
      core::Map<core::Symbol, dynamic> named = <core::Symbol, dynamic>{};
      args.{core::List::addAll}(injection.{req::InjectionRequest::required}.{core::Iterable::map}<dynamic>((dynamic r) → dynamic => req::resolveInjection(r, injection, req, res, true)));
      injection.{req::InjectionRequest::named}.{core::Map::forEach}((core::String k, core::Type v) → core::Null {
        core::Symbol name = new _in::Symbol::•(k);
        named.{core::Map::[]=}(name, req::resolveInjection(<core::Object>[k, v], injection, req, res, false));
      });
      return core::Function::apply(handler, args, named);
    };
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_framework-2.0.0-alpha.2/lib/src/core/injection.dart */ preInject(core::Function handler, ref::Reflector reflector) → req::InjectionRequest {
    req::InjectionRequest injection = new req::InjectionRequest::•();
    ref::ReflectedFunction closureMirror = reflector.{ref::Reflector::reflectFunction}(handler);
    if(closureMirror.{ref::ReflectedFunction::parameters}.{core::Iterable::isEmpty})
      return injection;
    for (ref::ReflectedParameter parameter in closureMirror.{ref::ReflectedFunction::parameters}) {
      core::String name = parameter.{ref::ReflectedParameter::name};
      core::Type type = parameter.{ref::ReflectedParameter::type}.{ref::ReflectedType::reflectedType};
      ref::ReflectedType _Parameter = reflector.{ref::Reflector::reflectType}(met::Parameter);
      met::Parameter p = (let final ref::ReflectedInstance #t77 = parameter.{ref::ReflectedParameter::annotations}.{core::Iterable::firstWhere}((ref::ReflectedInstance m) → core::bool => m.{ref::ReflectedInstance::type}.{ref::ReflectedType::isAssignableTo}(_Parameter), orElse: () → core::Null => null) in #t77.==(null) ?{core::Object} null : #t77.{ref::ReflectedInstance::reflectee}) as met::Parameter;
      if(!p.{core::Object::==}(null)) {
        injection.{req::InjectionRequest::parameters}.{core::Map::[]=}(name, new met::Parameter::•(cookie: p.{met::Parameter::cookie}, header: p.{met::Parameter::header}, query: p.{met::Parameter::query}, session: p.{met::Parameter::session}, match: p.{met::Parameter::match}, defaultValue: p.{met::Parameter::defaultValue}, required: parameter.{ref::ReflectedParameter::isNamed} ?{core::bool} false : !p.{met::Parameter::required}.{core::Object::==}(false)));
      }
      if(!parameter.{ref::ReflectedParameter::isNamed}) {
        if(!parameter.{ref::ReflectedParameter::isRequired})
          injection.{req::InjectionRequest::optional}.{core::List::add}(name);
        if(type.{core::Object::==}(req::RequestContext<dynamic>) || type.{core::Object::==}(res::ResponseContext<dynamic>)) {
          injection.{req::InjectionRequest::required}.{core::List::add}(type);
        }
        else
          if(name.{core::String::==}("req")) {
            injection.{req::InjectionRequest::required}.{core::List::add}(req::RequestContext<dynamic>);
          }
          else
            if(name.{core::String::==}("res")) {
              injection.{req::InjectionRequest::required}.{core::List::add}(res::ResponseContext<dynamic>);
            }
            else
              if(type.{core::Object::==}(dynamic)) {
                injection.{req::InjectionRequest::required}.{core::List::add}(name);
              }
              else {
                injection.{req::InjectionRequest::required}.{core::List::add}(<core::Object>[name, type]);
              }
      }
      else {
        injection.{req::InjectionRequest::named}.{core::Map::[]=}(name, type);
      }
    }
    return injection;
  }
}
library angel_framework.http.response_context from "package:angel_framework/src/core/response_context.dart" as res {
  import "dart:async";
  import "dart:convert";
  import "dart:convert" as c;
  import "dart:io";
  import "package:angel_route/angel_route.dart";
  import "package:file/file.dart";
  import "package:http_parser/http_parser.dart";
  import "package:mime/mime.dart";
  import "package:angel_framework/src/http/http.dart";
  import "package:angel_framework/src/core/request_context.dart";
  import "package:angel_framework/src/core/server.dart";
  abstract class ResponseContext<RawResponse extends core::Object = dynamic> extends core::Object implements asy::StreamSink<core::List<core::int>>, core::StringSink {
    final field core::Map<dynamic, dynamic> properties = <dynamic, dynamic>{};
    final field core::Map<core::String, core::String> _headers = <core::String, core::String>{"server": "angel"};
    field asy::Completer<dynamic> _done = null;
    field core::int _statusCode = 200;
    field ser::Angel app = null;
    field core::bool chunked = null;
    final field core::List<_ht::Cookie> cookies = <_ht::Cookie>[];
    final field core::Map<core::String, con2::Converter<core::List<core::int>, core::List<core::int>>> encoders = <core::String, con2::Converter<core::List<core::int>, core::List<core::int>>>{};
    final field core::Map<core::String, dynamic> renderParams = <core::String, dynamic>{};
    field (dynamic) → core::String serializer = con2::json.{con2::JsonCodec::encode};
    field med::MediaType contentType = new med::MediaType::•("text", "plain");
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get correspondingRequest() → req::RequestContext<dynamic>;
    @core::override
    get done() → asy::Future<dynamic>
      return (let final asy::Completer<dynamic> #t78 = this.{res::ResponseContext::_done} in #t78.==(null) ?{asy::Completer<dynamic>} asy::Completer::•<dynamic>() : #t78).{asy::Completer::future};
    get headers() → core::Map<core::String, core::String>
      return this.{res::ResponseContext::_headers};
    get statusCode() → core::int
      return this.{res::ResponseContext::_statusCode};
    set statusCode(core::int value) → void {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      else
        this.{res::ResponseContext::_statusCode} = let final core::int #t79 = value in #t79.==(null) ?{core::int} 200 : #t79;
    }
    abstract get isOpen() → core::bool;
    abstract get isBuffered() → core::bool;
    abstract get buffer() → io::BytesBuilder;
    abstract get rawResponse() → res::ResponseContext::RawResponse;
    abstract method detach() → asy::FutureOr<res::ResponseContext::RawResponse>;
    static method closed() → core::StateError
      return new core::StateError::•("Cannot modify a closed response.");
    method download(file::File file, {core::String filename = null}) → void {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      this.{res::ResponseContext::headers}.{core::Map::[]=}("Content-Disposition", "attachment; filename=\"${let final core::String #t80 = filename in #t80.==(null) ?{core::String} file.{io::FileSystemEntity::path} : #t80}\"");
      this.{res::ResponseContext::contentType} = med::MediaType::parse(mim::lookupMimeType(file.{io::FileSystemEntity::path}));
      this.{res::ResponseContext::headers}.{core::Map::[]=}("content-length", file.{io::File::lengthSync}().{core::int::toString}());
      if(!this.{res::ResponseContext::isBuffered}) {
        file.{io::File::openRead}().{asy::Stream::pipe}(this);
      }
      else {
        this.{res::ResponseContext::buffer}.{io::BytesBuilder::add}(file.{io::File::readAsBytesSync}());
        this.{res::ResponseContext::close}();
      }
    }
    method close() → asy::Future<dynamic> {
      if(this.{res::ResponseContext::buffer} is res::LockableBytesBuilder) {
        (this.{res::ResponseContext::buffer} as res::LockableBytesBuilder).{res::LockableBytesBuilder::lock}();
      }
      if((let final asy::Completer<dynamic> #t81 = this.{res::ResponseContext::_done} in #t81.==(null) ?{core::bool} null : #t81.{asy::Completer::isCompleted}).{core::Object::==}(false))
        this.{res::ResponseContext::_done}.{asy::Completer::complete}();
      return asy::Future::value<dynamic>();
    }
    method json(dynamic value) → void
      return let final res::ResponseContext<res::ResponseContext::RawResponse> #t82 = this in let final dynamic #t83 = #t82.{res::ResponseContext::contentType} = new med::MediaType::•("application", "json") in let final dynamic #t84 = #t82.{res::ResponseContext::serialize}(value) in #t82;
    method jsonp(dynamic value, {core::String callbackName = "callback", med::MediaType contentType = null}) → void {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      this.{res::ResponseContext::write}("${callbackName}(${this.{res::ResponseContext::serializer}(value)})");
      this.{res::ResponseContext::contentType} = let final med::MediaType #t85 = contentType in #t85.==(null) ?{med::MediaType} new med::MediaType::•("application", "javascript") : #t85;
      this.{res::ResponseContext::close}();
    }
    method render(core::String view, [core::Map<core::String, dynamic> data = null]) → asy::Future<dynamic> {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      return asy::Future::sync<core::String>(() → asy::FutureOr<core::String> => this.{res::ResponseContext::app}.{ser::Angel::viewGenerator}(view, let final core::Map<core::String, dynamic> #t86 = col::LinkedHashMap::from<core::String, dynamic>(this.{res::ResponseContext::renderParams}) in let final dynamic #t87 = #t86.{core::Map::addAll}(let final core::Map<core::String, dynamic> #t88 = data in #t88.==(null) ?{core::Map<core::String, dynamic>} <core::String, dynamic>{} : #t88) in #t86)).{asy::Future::then}<dynamic>((core::String content) → core::Null {
        this.{res::ResponseContext::write}(content);
        this.{res::ResponseContext::contentType} = new med::MediaType::•("text", "html");
        this.{res::ResponseContext::close}();
      });
    }
    method redirect(dynamic url, {core::bool absolute = true, core::int code = 302}) → void {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      let final core::Map<core::String, core::String> #t89 = this.{res::ResponseContext::headers} in let final dynamic #t90 = #t89.{core::Map::[]=}("content-type", "text/html") in let final dynamic #t91 = #t89.{core::Map::[]=}("location", url is core::String ?{core::String} url{core::String} : this.{res::ResponseContext::app}.{rou2::Router::navigate}(url as core::Iterable<dynamic>, absolute: absolute)) in #t89;
      this.{res::ResponseContext::statusCode} = let final core::int #t92 = code in #t92.==(null) ?{core::int} 302 : #t92;
      this.{res::ResponseContext::write}("    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Redirecting...</title>\n        <meta http-equiv=\"refresh\" content=\"0; url=${url}\">\n      </head>\n      <body>\n        <h1>Currently redirecting you...</h1>\n        <br />\n        Click <a href=\"${url}\">here</a> if you are not automatically redirected...\n        <script>\n          window.location = \"${url}\";\n        </script>\n      </body>\n    </html>\n    ");
      this.{res::ResponseContext::close}();
    }
    method redirectTo(core::String name, [core::Map<dynamic, dynamic> params = null, core::int code = null]) → void {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      function _findRoute(rou2::Router<dynamic> r) → rou2::Route<dynamic> {
        for (rou2::Route<dynamic> route in r.{rou2::Router::routes}) {
          if(route is rou2::SymlinkRoute<dynamic>) {
            final rou2::Route<dynamic> m = _findRoute.call(route{rou2::SymlinkRoute<dynamic>}.{rou2::SymlinkRoute::router});
            if(!m.{core::Object::==}(null))
              return m;
          }
          else
            if(route.{rou2::Route::name}.{core::String::==}(name))
              return route;
        }
        return null;
      }
      rou2::Route<dynamic> matched = _findRoute.call(this.{res::ResponseContext::app});
      if(!matched.{core::Object::==}(null)) {
        this.{res::ResponseContext::redirect}(matched.{rou2::Route::makeUri}(params.{core::Map::keys}.{core::Iterable::fold}<core::Map<core::String, dynamic>>(<core::String, dynamic>{}, (core::Map<core::String, dynamic> out, dynamic k) → core::Map<core::String, dynamic> {
          return let final core::Map<core::String, dynamic> #t93 = out in let final dynamic #t94 = #t93.{core::Map::[]=}(k.{core::Object::toString}(), params.{core::Map::[]}(k)) in #t93;
        })), code: code);
        return;
      }
      throw new core::ArgumentError::notNull("Route to redirect to (${name})");
    }
    method redirectToAction(core::String action, [core::Map<dynamic, dynamic> params = null, core::int code = null]) → void {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      core::List<core::String> split = action.{core::String::split}("@");
      if(split.{core::List::length}.{core::num::<}(2))
        throw core::Exception::•("Controller redirects must take the form of 'Controller@action'. You gave: ${action}");
      con3::Controller controller = this.{res::ResponseContext::app}.{ser::Angel::controllers}.{core::Map::[]}(split.{core::List::[]}(0).{core::String::replaceAll}(res::_straySlashes, ""));
      if(controller.{core::Object::==}(null))
        throw core::Exception::•("Could not find a controller named '${split.{core::List::[]}(0)}'");
      rou2::Route<dynamic> matched = controller.{con3::Controller::routeMappings}.{core::Map::[]}(split.{core::List::[]}(1));
      if(matched.{core::Object::==}(null))
        throw core::Exception::•("Controller '${split.{core::List::[]}(0)}' does not contain any action named '${split.{core::List::[]}(1)}'");
      final core::String head = controller.{con3::Controller::findExpose}(this.{res::ResponseContext::app}.{rou::Routable::container}.{con::Container::reflector}).{met::Expose::path}.{core::Object::toString}().{core::String::replaceAll}(res::_straySlashes, "");
      final core::String tail = matched.{rou2::Route::makeUri}(params.{core::Map::keys}.{core::Iterable::fold}<core::Map<core::String, dynamic>>(<core::String, dynamic>{}, (core::Map<core::String, dynamic> out, dynamic k) → core::Map<core::String, dynamic> {
        return let final core::Map<core::String, dynamic> #t95 = out in let final dynamic #t96 = #t95.{core::Map::[]=}(k.{core::Object::toString}(), params.{core::Map::[]}(k)) in #t95;
      })).{core::String::replaceAll}(res::_straySlashes, "");
      this.{res::ResponseContext::redirect}("${head}/${tail}".{core::String::replaceAll}(res::_straySlashes, ""), code: code);
    }
    method sendFile(file::File file) → void {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      this.{res::ResponseContext::contentType} = med::MediaType::parse(mim::lookupMimeType(file.{io::FileSystemEntity::path}));
      this.{res::ResponseContext::buffer}.{io::BytesBuilder::add}(file.{io::File::readAsBytesSync}());
      this.{res::ResponseContext::close}();
    }
    method serialize(dynamic value, {med::MediaType contentType = null}) → core::bool {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      this.{res::ResponseContext::contentType} = let final med::MediaType #t97 = contentType in #t97.==(null) ?{med::MediaType} new med::MediaType::•("application", "json") : #t97;
      core::String text = this.{res::ResponseContext::serializer}(value);
      if(text.{core::String::isEmpty})
        return true;
      this.{res::ResponseContext::write}(text);
      this.{res::ResponseContext::close}();
      return false;
    }
    method streamFile(file::File file) → asy::Future<dynamic> {
      if(!this.{res::ResponseContext::isOpen})
        throw res::ResponseContext::closed();
      this.{res::ResponseContext::contentType} = med::MediaType::parse(mim::lookupMimeType(file.{io::FileSystemEntity::path}));
      return file.{io::File::openRead}().{asy::Stream::pipe}(this);
    }
    abstract method useBuffer() → void;
    @core::override
    abstract method addStream(generic-covariant-impl asy::Stream<core::List<core::int>> stream) → asy::Future<dynamic>;
    @core::override
    method addError(core::Object error, [core::StackTrace stackTrace = null]) → void {
      if((let final asy::Completer<dynamic> #t98 = this.{res::ResponseContext::_done} in #t98.==(null) ?{core::bool} null : #t98.{asy::Completer::isCompleted}).{core::Object::==}(false))
        this.{res::ResponseContext::_done}.{asy::Completer::completeError}(error, stackTrace);
    }
    method write(core::Object value, {con2::Encoding encoding = null}) → void {
      encoding.{core::Object::==}(null) ?{con2::Encoding} encoding = con2::utf8 : null;
      if(!this.{res::ResponseContext::isOpen} && this.{res::ResponseContext::isBuffered})
        throw res::ResponseContext::closed();
      else
        if(!this.{res::ResponseContext::isBuffered}) {
          this.{asy::EventSink::add}(encoding.{con2::Codec::encode}(value.{core::Object::toString}()));
        }
        else {
          this.{res::ResponseContext::buffer}.{io::BytesBuilder::add}(encoding.{con2::Codec::encode}(value.{core::Object::toString}()));
        }
    }
    @core::override
    method writeCharCode(core::int charCode) → void {
      if(!this.{res::ResponseContext::isOpen} && this.{res::ResponseContext::isBuffered})
        throw res::ResponseContext::closed();
      else
        if(!this.{res::ResponseContext::isBuffered})
          this.{asy::EventSink::add}(<core::int>[charCode]);
        else
          this.{res::ResponseContext::buffer}.{io::BytesBuilder::addByte}(charCode);
    }
    @core::override
    method writeln([core::Object obj = ""]) → void {
      this.{res::ResponseContext::write}(obj.{core::Object::toString}());
      this.{res::ResponseContext::write}("\r\n");
    }
    @core::override
    method writeAll(core::Iterable<dynamic> objects, [core::String separator = ""]) → void {
      this.{res::ResponseContext::write}(objects.{core::Iterable::join}(separator));
    }
  }
  abstract class LockableBytesBuilder extends io::BytesBuilder {
    static factory •() → res::LockableBytesBuilder {
      return new res::_LockableBytesBuilderImpl::•();
    }
    abstract method lock() → void;
  }
  class _LockableBytesBuilderImpl extends core::Object implements res::LockableBytesBuilder {
    final field io::BytesBuilder _buf = io::BytesBuilder::•(copy: false);
    field core::bool _closed = false;
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    method _deny() → core::StateError
      return new core::StateError::•("Cannot modified a closed response's buffer.");
    @core::override
    method lock() → void {
      this.{res::_LockableBytesBuilderImpl::_closed} = true;
    }
    @core::override
    method add(core::List<core::int> bytes) → void {
      if(this.{res::_LockableBytesBuilderImpl::_closed})
        throw this.{res::_LockableBytesBuilderImpl::_deny}();
      else
        this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::add}(bytes);
    }
    @core::override
    method addByte(core::int byte) → void {
      if(this.{res::_LockableBytesBuilderImpl::_closed})
        throw this.{res::_LockableBytesBuilderImpl::_deny}();
      else
        this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::addByte}(byte);
    }
    @core::override
    method clear() → void {
      this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::clear}();
    }
    @core::override
    get isEmpty() → core::bool
      return this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::isEmpty};
    @core::override
    get isNotEmpty() → core::bool
      return this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::isNotEmpty};
    @core::override
    get length() → core::int
      return this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::length};
    @core::override
    method takeBytes() → core::List<core::int> {
      return this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::takeBytes}();
    }
    @core::override
    method toBytes() → core::List<core::int> {
      return this.{res::_LockableBytesBuilderImpl::_buf}.{io::BytesBuilder::toBytes}();
    }
  }
  static final field core::RegExp _straySlashes = core::RegExp::•("(^/+)|(/+\$)");
}
library angel_framework.http.routable from "package:angel_framework/src/core/routable.dart" as rou {
  import "dart:async";
  import "package:angel_container/angel_container.dart";
  import "package:angel_route/angel_route.dart";
  import "package:angel_framework/src/util.dart";
  import "package:angel_framework/src/core/hooked_service.dart";
  import "package:angel_framework/src/core/metadata.dart";
  import "package:angel_framework/src/core/request_context.dart";
  import "package:angel_framework/src/core/response_context.dart";
  import "package:angel_framework/src/core/service.dart";
  typedef RequestHandler = (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>;
  class Routable extends rou2::Router<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> {
    final field core::Map<core::Pattern, ser4::Service> _services = <core::Pattern, ser4::Service>{};
    final field core::Map<dynamic, dynamic> configuration = <dynamic, dynamic>{};
    final field con::Container _container;
    field asy::StreamController<ser4::Service> _onService = asy::StreamController::broadcast<ser4::Service>();
    constructor •([ref::Reflector reflector = null]) → void
      : rou::Routable::_container = reflector.{core::Object::==}(null) ?{con::Container} null : new con::Container::•(reflector), super rou2::Router::•()
      ;
    get container() → con::Container
      return this.{rou::Routable::_container};
    method close() → void {
      this.{rou::Routable::_services}.{core::Map::clear}();
      this.{rou::Routable::configuration}.{core::Map::clear}();
      this.{rou::Routable::_onService}.{asy::StreamController::close}();
    }
    get services() → core::Map<core::Pattern, ser4::Service>
      return this.{rou::Routable::_services};
    get onService() → asy::Stream<ser4::Service>
      return this.{rou::Routable::_onService}.{asy::StreamController::stream};
    method service(core::Pattern path) → ser4::Service
      return let final ser4::Service #t99 = this.{rou::Routable::_services}.{core::Map::[]}(path) in #t99.==(null) ?{ser4::Service} this.{rou::Routable::_services}.{core::Map::[]}(path.{core::Object::toString}().{core::String::replaceAll}(rou::_straySlashes, "")) : #t99;
    @core::override
    method addRoute(core::String method, core::String path, generic-covariant-impl (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> handler, {generic-covariant-impl core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> middleware = const <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[]}) → rou2::Route<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> {
      final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlers = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[];
      met::Middleware middlewareDeclaration = util::getAnnotation(handler, met::Middleware, let final con::Container #t100 = this.{rou::Routable::_container} in #t100.==(null) ?{ref::Reflector} null : #t100.{con::Container::reflector}) as{TypeError} met::Middleware;
      if(!middlewareDeclaration.{core::Object::==}(null)) {
        handlers.{core::List::addAll}(middlewareDeclaration.{met::Middleware::handlers});
      }
      final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlerSequence = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[];
      handlerSequence.{core::List::addAll}(let final core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t101 = middleware in #t101.==(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : #t101);
      handlerSequence.{core::List::addAll}(handlers);
      return super.{rou2::Router::addRoute}(method, path.{core::Object::toString}(), handler, middleware: handlerSequence);
    }
    method use(core::String path, ser4::Service service) → hoo::HookedService {
      hoo::HookedService hooked = new hoo::HookedService::•(service);
      this.{rou::Routable::_services}.{core::Map::[]=}(path.{core::Object::toString}().{core::String::trim}().{core::String::replaceAll}(core::RegExp::•("(^/+)|(/+\$)"), ""), hooked);
      hooked.{hoo::HookedService::addRoutes}();
      this.{rou2::Router::mount}(path.{core::Object::toString}(), hooked);
      service.{ser4::Service::onHooked}(hooked);
      this.{rou::Routable::_onService}.{asy::StreamController::add}(hooked);
      return hooked;
    }
  }
  static final field core::RegExp _straySlashes = core::RegExp::•("(^/+)|(/+\$)");
  static method waterfall(core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlers) → (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> {
    return (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
      () → asy::Future<dynamic> runPipeline;
      #L23:
      for ((req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> handler in handlers) {
        if(handler.{core::Object::==}(null))
          break #L23;
        if(runPipeline.{core::Object::==}(null))
          runPipeline = () → asy::Future<dynamic> => asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => handler.call(req, res));
        else {
          () → asy::Future<dynamic> current = runPipeline;
          runPipeline = () → asy::Future<dynamic> => current.call().{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> => !res.{res::ResponseContext::isOpen} ?{asy::Future<dynamic>} asy::Future::value<dynamic>(result) : req.{req::RequestContext::app}.{ser::Angel::executeHandler}(handler, req, res));
        }
      }
      runPipeline.{core::Object::==}(null) ?{() → asy::Future<dynamic>} runPipeline = () → asy::Future<dynamic> => asy::Future::value<dynamic>() : null;
      return runPipeline.call();
    };
  }
}
library angel_framework.http.server from "package:angel_framework/src/core/server.dart" as ser {
  import "dart:async";
  import "dart:collection";
  import "dart:convert";
  import "dart:io";
  import "package:angel_container/angel_container.dart";
  import "package:angel_http_exception/angel_http_exception.dart";
  import "package:angel_route/angel_route.dart";
  import "package:combinator/combinator.dart";
  import "package:http_parser/http_parser.dart";
  import "package:logging/logging.dart";
  import "package:tuple/tuple.dart";
  import "package:angel_framework/src/http/http.dart";
  import "package:angel_framework/src/core/hooked_service.dart";
  import "package:angel_framework/src/core/request_context.dart";
  import "package:angel_framework/src/core/response_context.dart";
  import "package:angel_framework/src/core/routable.dart";
  import "package:angel_framework/src/core/service.dart";
  typedef AngelConfigurer = (ser::Angel) → asy::FutureOr<dynamic>;
  typedef ViewGenerator = (core::String, [core::Map<core::String, dynamic>]) → asy::FutureOr<core::String>;
  class Angel extends rou::Routable {
    static field (core::String, [core::Map<core::String, dynamic>]) → asy::FutureOr<core::String> noViewEngineConfigured = (core::String view, [core::Map<dynamic, dynamic> data = null]) → core::String => "No view engine has been configured yet.";
    final field core::List<ser::Angel> _children = <ser::Angel>[];
    final field core::Map<core::String, tup::Tuple3<core::List<dynamic>, core::Map<core::String, dynamic>, com::ParseResult<core::Map<core::String, dynamic>>>> handlerCache = col::HashMap::•<core::String, tup::Tuple3<core::List<dynamic>, core::Map<core::String, dynamic>, com::ParseResult<core::Map<core::String, dynamic>>>>();
    field rou2::Router<dynamic> _flattened = null;
    field ang4::AngelHttp _http = null;
    field core::bool _isProduction = null;
    field ser::Angel _parent = null;
    final field core::Map<core::String, con2::Converter<core::List<core::int>, core::List<core::int>>> encoders = <core::String, con2::Converter<core::List<core::int>, core::List<core::int>>>{};
    final field core::Map<dynamic, req::InjectionRequest> _preContained = <dynamic, req::InjectionRequest>{};
    field (dynamic) → core::String serializer;
    field core::bool allowMethodOverrides = true;
    final field core::Map<core::Pattern, con3::Controller> _controllers = <core::Pattern, con3::Controller>{};
    field log::Logger logger;
    final field core::List<(ser::Angel) → asy::FutureOr<dynamic>> startupHooks = <(ser::Angel) → asy::FutureOr<dynamic>>[];
    final field core::List<(ser::Angel) → asy::FutureOr<dynamic>> shutdownHooks = <(ser::Angel) → asy::FutureOr<dynamic>>[];
    final field core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> responseFinalizers = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[];
    final field core::Map<dynamic, dynamic> configuration = <dynamic, dynamic>{};
    field core::bool eagerParseRequestBodies = false;
    field core::bool keepRawRequestBuffers = false;
    field (core::String, [core::Map<core::String, dynamic>]) → asy::FutureOr<core::String> viewGenerator = ser::Angel::noViewEngineConfigured;
    field (ang3::AngelHttpException, req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → dynamic errorHandler = (ang3::AngelHttpException e, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → core::Null {
      if(!req.{req::RequestContext::accepts}("text/html", strict: true) && (req.{req::RequestContext::accepts}("application/json") || req.{req::RequestContext::accepts}("application/javascript"))) {
        res.{res::ResponseContext::json}(e.{ang3::AngelHttpException::toJson}());
        return;
      }
      res.{res::ResponseContext::contentType} = new med::MediaType::•("text", "html", <core::String, core::String>{"charset": "utf8"});
      res.{res::ResponseContext::statusCode} = e.{ang3::AngelHttpException::statusCode};
      res.{res::ResponseContext::write}("<!DOCTYPE html><html><head><title>${e.{ang3::AngelHttpException::message}}</title>");
      res.{res::ResponseContext::write}("</head><body><h1>${e.{ang3::AngelHttpException::message}}</h1><ul>");
      for (core::String error in e.{ang3::AngelHttpException::errors}) {
        res.{res::ResponseContext::write}("<li>${error}</li>");
      }
      res.{res::ResponseContext::write}("</ul></body></html>");
      res.{res::ResponseContext::close}();
    };
    constructor •({ref::Reflector reflector = const emp::EmptyReflector::•(), log::Logger logger = null, core::bool eagerParseRequestBodies = false, core::bool allowMethodOverrides = true, core::bool keepRawRequestBuffers = false, (dynamic) → core::String serializer = null, (core::String, [core::Map<core::String, dynamic>]) → asy::FutureOr<core::String> viewGenerator = null}) → void
      : ser::Angel::logger = logger, ser::Angel::eagerParseRequestBodies = eagerParseRequestBodies, ser::Angel::allowMethodOverrides = allowMethodOverrides, ser::Angel::keepRawRequestBuffers = keepRawRequestBuffers, ser::Angel::serializer = serializer, ser::Angel::viewGenerator = viewGenerator, super rou::Routable::•(reflector) {
      this.{ser::Angel::bootstrapContainer}();
      this.{ser::Angel::viewGenerator}.{core::Object::==}(null) ?{(core::String, [core::Map<core::String, dynamic>]) → asy::FutureOr<core::String>} this.{ser::Angel::viewGenerator} = ser::Angel::noViewEngineConfigured : null;
      this.{ser::Angel::serializer}.{core::Object::==}(null) ?{(core::Object) → core::String} this.{ser::Angel::serializer} = con2::json.{con2::JsonCodec::encode} : null;
    }
    get preContained() → core::Map<dynamic, req::InjectionRequest>
      return this.{ser::Angel::_preContained};
    get optimizedRouter() → rou2::Router<dynamic>
      return let final rou2::Router<dynamic> #t102 = this.{ser::Angel::_flattened} in #t102.==(null) ?{rou2::Router<dynamic>} this : #t102;
    get children() → core::List<ser::Angel>
      return core::List::unmodifiable<ser::Angel>(this.{ser::Angel::_children});
    get controllers() → core::Map<core::Pattern, con3::Controller>
      return this.{ser::Angel::_controllers};
    get isProduction() → core::bool {
      return let final core::bool #t103 = this.{ser::Angel::_isProduction} in #t103.{core::Object::==}(null) ?{core::bool} this.{ser::Angel::_isProduction} = io::Platform::environment.{core::Map::[]}("ANGEL_ENV").{core::String::==}("production") : #t103;
    }
    get parent() → ser::Angel
      return this.{ser::Angel::_parent};
    @core::override
    method addRoute(core::String method, core::String path, generic-covariant-impl (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> handler, {generic-covariant-impl core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> middleware = const <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[]}) → rou2::Route<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> {
      if(!this.{ser::Angel::_flattened}.{core::Object::==}(null)) {
        let final log::Logger #t104 = this.{ser::Angel::logger} in #t104.==(null) ?{void} null : #t104.{log::Logger::warning}("WARNING: You added a route (${method} ${path}) to the router, after it had been optimized.");
        let final log::Logger #t105 = this.{ser::Angel::logger} in #t105.==(null) ?{void} null : #t105.{log::Logger::warning}("This route will be ignored, and no requests will ever reach it.");
      }
      return super.{rou::Routable::addRoute}(method, path, handler, middleware: let final core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t106 = middleware in #t106.==(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : #t106);
    }
    @core::override
    method mount(core::String path, generic-covariant-impl rou2::Router<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> router) → rou2::SymlinkRoute<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> {
      if(!this.{ser::Angel::_flattened}.{core::Object::==}(null)) {
        let final log::Logger #t107 = this.{ser::Angel::logger} in #t107.==(null) ?{void} null : #t107.{log::Logger::warning}("WARNING: You added mounted a child router (${path}) on the router, after it had been optimized.");
        let final log::Logger #t108 = this.{ser::Angel::logger} in #t108.==(null) ?{void} null : #t108.{log::Logger::warning}("This route will be ignored, and no requests will ever reach it.");
      }
      if(router is ser::Angel) {
        router{ser::Angel}.{ser::Angel::_parent} = this;
        this.{ser::Angel::_children}.{core::List::add}(router{ser::Angel});
      }
      return super.{rou2::Router::mount}(path.{core::Object::toString}(), router);
    }
    method bootstrapContainer() → void {
      if(!this.{core::Object::runtimeType}.{core::Object::==}(ser::Angel)) {
        this.{rou::Routable::container}.{con::Container::registerSingleton}<ser::Angel>(this);
      }
      this.{rou::Routable::container}.{con::Container::registerSingleton}<ser::Angel>(this);
      this.{rou::Routable::container}.{con::Container::registerSingleton}<rou::Routable>(this);
      this.{rou::Routable::container}.{con::Container::registerSingleton}<rou2::Router<dynamic>>(this);
    }
    method close() → asy::Future<dynamic> {
      asy::Future::forEach<ser4::Service>(this.{rou::Routable::services}.{core::Map::values}, (ser4::Service service) → core::Null {
        service.{ser4::Service::close}();
      });
      super.{rou::Routable::close}();
      this.{ser::Angel::viewGenerator} = ser::Angel::noViewEngineConfigured;
      this.{ser::Angel::_preContained}.{core::Map::clear}();
      this.{ser::Angel::handlerCache}.{core::Map::clear}();
      this.{ser::Angel::encoders}.{core::Map::clear}();
      this.{ser::Angel::_children}.{core::List::clear}();
      this.{ser::Angel::_parent} = null;
      this.{ser::Angel::logger} = null;
      this.{ser::Angel::startupHooks}.{core::List::clear}();
      this.{ser::Angel::shutdownHooks}.{core::List::clear}();
      this.{ser::Angel::responseFinalizers}.{core::List::clear}();
      this.{ser::Angel::_flattened} = null;
      let final ang4::AngelHttp #t109 = this.{ser::Angel::_http} in #t109.==(null) ?{asy::Future<_ht::HttpServer>} null : #t109.{ang4::AngelHttp::close}();
      return asy::Future::value<dynamic>(let final ang4::AngelHttp #t110 = this.{ser::Angel::_http} in #t110.==(null) ?{_ht::HttpServer} null : #t110.{ang4::AngelHttp::httpServer});
    }
    @core::override
    method dumpTree({(core::String) → dynamic callback = null, core::String header = "Dumping route tree:", core::String tab = "  ", core::bool showMatchers = false}) → void {
      if(this.{ser::Angel::isProduction}) {
        this.{ser::Angel::_flattened}.{core::Object::==}(null) ?{rou2::Router<dynamic>} this.{ser::Angel::_flattened} = rou2::flatten<dynamic>(this) : null;
        this.{ser::Angel::_flattened}.{rou2::Router::dumpTree}(callback: callback, header: (let final core::String #t111 = header in #t111.==(null) ?{core::bool} null : #t111.{core::String::isNotEmpty}).{core::Object::==}(true) ?{core::String} header : this.{ser::Angel::isProduction} ?{core::String} "Dumping flattened route tree:" : "Dumping route tree:", tab: let final core::String #t112 = tab in #t112.==(null) ?{core::String} "  " : #t112);
      }
      else {
        super.{rou2::Router::dumpTree}(callback: callback, header: (let final core::String #t113 = header in #t113.==(null) ?{core::bool} null : #t113.{core::String::isNotEmpty}).{core::Object::==}(true) ?{core::String} header : this.{ser::Angel::isProduction} ?{core::String} "Dumping flattened route tree:" : "Dumping route tree:", tab: let final core::String #t114 = tab in #t114.==(null) ?{core::String} "  " : #t114);
      }
    }
    method getHandlerResult(dynamic handler, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
      if(handler is (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>) {
        asy::FutureOr<dynamic> result = handler{(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>}.call(req, res);
        return this.{ser::Angel::getHandlerResult}(result, req, res);
      }
      if(handler is asy::Future<dynamic>) {
        return handler{asy::Future<dynamic>}.{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> => this.{ser::Angel::getHandlerResult}(result, req, res));
      }
      if(handler is core::Function) {
        asy::Future<dynamic> result = this.{ser::Angel::runContained}(handler{core::Function}, req, res);
        return this.{ser::Angel::getHandlerResult}(result, req, res);
      }
      if(handler is asy::Stream<dynamic>) {
        return this.{ser::Angel::getHandlerResult}(handler{asy::Stream<dynamic>}.{asy::Stream::toList}(), req, res);
      }
      return asy::Future::value<dynamic>(handler);
    }
    method executeHandler(dynamic handler, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<core::bool> {
      return this.{ser::Angel::getHandlerResult}(handler, req, res).{asy::Future::then}<core::bool>((dynamic result) → core::bool {
        if(result.{core::Object::==}(null))
          return false;
        else
          if(result is core::bool) {
            return result{core::bool};
          }
          else
            if(!result.{core::Object::==}(null)) {
              return res.{res::ResponseContext::serialize}(result);
            }
            else
              return res.{res::ResponseContext::isOpen};
      });
    }
    method findProperty(dynamic key) → dynamic {
      if(this.{ser::Angel::configuration}.{core::Map::containsKey}(key))
        return this.{ser::Angel::configuration}.{core::Map::[]}(key);
      return !this.{ser::Angel::parent}.{core::Object::==}(null) ?{dynamic} this.{ser::Angel::parent}.{ser::Angel::findProperty}(key) : null;
    }
    method optimizeForProduction({core::bool force = false}) → void {
      if(this.{ser::Angel::isProduction}.{core::Object::==}(true) || force.{core::Object::==}(true)) {
        this.{ser::Angel::_isProduction} = true;
        this.{ser::Angel::_flattened}.{core::Object::==}(null) ?{rou2::Router<dynamic>} this.{ser::Angel::_flattened} = rou2::flatten<dynamic>(this) : null;
        let final log::Logger #t115 = this.{ser::Angel::logger} in #t115.==(null) ?{void} null : #t115.{log::Logger::config}("Angel is running in production mode.");
      }
    }
    method runContained(core::Function handler, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> {
        if(this.{ser::Angel::_preContained}.{core::Map::containsKey}(handler)) {
          return req::handleContained(handler, this.{ser::Angel::_preContained}.{core::Map::[]}(handler)).call(req, res);
        }
        return this.{ser::Angel::runReflected}(handler, req, res);
      });
    }
    method runReflected(core::Function handler, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
      (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> h = req::handleContained(handler, let final core::Map<dynamic, req::InjectionRequest> #t116 = this.{ser::Angel::_preContained} in let final core::Function #t117 = handler in let final req::InjectionRequest #t118 = req::preInject(handler, req.{req::RequestContext::app}.{rou::Routable::container}.{con::Container::reflector}) in let final void #t119 = #t116.{core::Map::[]=}(#t117, #t118) in #t118);
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => h.call(req, res));
    }
    method configure((ser::Angel) → asy::FutureOr<dynamic> configurer) → asy::Future<dynamic> {
      return asy::Future::sync<dynamic>(() → asy::FutureOr<dynamic> => configurer.call(this));
    }
    method fallback((req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> handler) → rou2::Route<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> {
      return this.{rou2::Router::all}("*", handler);
    }
    @core::override
    method use(core::String path, ser4::Service service) → hoo::HookedService {
      service.{ser4::Service::app} = this;
      return let final hoo::HookedService #t120 = super.{rou::Routable::use}(path, service) in let final dynamic #t121 = #t120.{ser4::Service::app} = this in #t120;
    }
  }
}
library angel_framework.http.service from "package:angel_framework/src/core/service.dart" as ser4 {
  import "dart:async";
  import "package:angel_http_exception/angel_http_exception.dart";
  import "package:merge_map/merge_map.dart";
  import "package:angel_framework/src/util.dart";
  import "package:angel_framework/src/core/hooked_service.dart";
  import "package:angel_framework/src/core/metadata.dart";
  import "package:angel_framework/src/core/response_context.dart";
  import "package:angel_framework/src/core/routable.dart";
  import "package:angel_framework/src/core/server.dart";
  class Providers extends core::Object {
    final field core::String via;
    static const field core::String viaRest = "rest";
    static const field core::String viaWebsocket = "websocket";
    static const field core::String viaGraphQL = "graphql";
    static const field ser4::Providers rest = const ser4::Providers::•(ser4::Providers::viaRest);
    static const field ser4::Providers websocket = const ser4::Providers::•(ser4::Providers::viaWebsocket);
    static const field ser4::Providers graphQL = const ser4::Providers::•(ser4::Providers::viaGraphQL);
    const constructor •(core::String via) → void
      : ser4::Providers::via = via, super core::Object::•()
      ;
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ser4::Providers && other{ser4::Providers}.{ser4::Providers::via}.{core::String::==}(this.{ser4::Providers::via});
    method toJson() → core::Map<core::String, core::String> {
      return <core::String, core::String>{"via": this.{ser4::Providers::via}};
    }
    @core::override
    method toString() → core::String {
      return "via:${this.{ser4::Providers::via}}";
    }
  }
  class Service extends rou::Routable {
    static const field core::List<core::String> specialQueryKeys = const <core::String>["\$limit", "\$sort", "page", "token"];
    field ser::Angel app = null;
    synthetic constructor •() → void
      : super rou::Routable::•()
      ;
    get bootstrappers() → core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>
      return <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[];
    method close() → void {}
    method findOne([core::Map<dynamic, dynamic> params = null, core::String errorMessage = "No record was found matching the given query."]) → asy::Future<dynamic> {
      return this.{ser4::Service::index}(params).{asy::Future::then}<dynamic>((dynamic result) → dynamic {
        if(result.{core::Object::==}(null)) {
          throw ang3::AngelHttpException::notFound(message: errorMessage);
        }
        else
          if(result is core::Iterable<dynamic>) {
            if(result{core::Iterable<dynamic>}.{core::Iterable::isEmpty}) {
              throw ang3::AngelHttpException::notFound(message: errorMessage);
            }
            else {
              return result{core::Iterable<dynamic>}.{core::Iterable::first};
            }
          }
          else {
            return result;
          }
      });
    }
    method index([core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic> {
      throw ang3::AngelHttpException::methodNotAllowed();
    }
    method read(dynamic id, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic> {
      throw ang3::AngelHttpException::methodNotAllowed();
    }
    method create(dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic> {
      throw ang3::AngelHttpException::methodNotAllowed();
    }
    method modify(dynamic id, dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic> {
      throw ang3::AngelHttpException::methodNotAllowed();
    }
    method update(dynamic id, dynamic data, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic> {
      throw ang3::AngelHttpException::methodNotAllowed();
    }
    method remove(dynamic id, [core::Map<dynamic, dynamic> params = null]) → asy::Future<dynamic> {
      throw ang3::AngelHttpException::methodNotAllowed();
    }
    static method parseId<T extends core::Object = dynamic>(dynamic id) → ser4::Service::parseId::T {
      if(id.{core::Object::==}("null") || id.{core::Object::==}(null))
        return null;
      else
        if(ser4::Service::parseId::T.{core::Object::==}(core::String))
          return id.{core::Object::toString}() as ser4::Service::parseId::T;
        else
          if(ser4::Service::parseId::T.{core::Object::==}(core::int))
            return core::int::parse(id.{core::Object::toString}()) as ser4::Service::parseId::T;
          else
            if(ser4::Service::parseId::T.{core::Object::==}(core::bool))
              return (id.{core::Object::==}(true) || (let final dynamic #t122 = id in #t122.==(null) ?{core::String} null : #t122.{core::Object::toString}()).{core::String::==}("true")) as ser4::Service::parseId::T;
            else
              if(ser4::Service::parseId::T.{core::Object::==}(core::double))
                return core::int::parse(id.{core::Object::toString}()) as ser4::Service::parseId::T;
              else
                if(ser4::Service::parseId::T.{core::Object::==}(core::num))
                  return core::num::parse(id.{core::Object::toString}()) as ser4::Service::parseId::T;
                else
                  return id as ser4::Service::parseId::T;
    }
    method addRoutes([ser4::Service service = null]) → void {
      this.{ser4::Service::_addRoutesInner}(let final ser4::Service #t123 = service in #t123.==(null) ?{ser4::Service} this : #t123, this.{ser4::Service::bootstrappers});
    }
    method _addRoutesInner(ser4::Service service, core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlerss) → void {
      core::Map<core::String, ser4::Providers> restProvider = <core::String, ser4::Providers>{"provider": ser4::Providers::rest};
      core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlers = core::List::from<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>(handlerss);
      met::Middleware before = util::getAnnotation(service, met::Middleware, this.{ser4::Service::app}.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Middleware;
      if(!before.{core::Object::==}(null))
        handlers.{core::List::addAll}(before.{met::Middleware::handlers});
      met::Middleware indexMiddleware = util::getAnnotation(service.{ser4::Service::index}, met::Middleware, this.{ser4::Service::app}.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Middleware;
      this.{rou2::Router::get}("/", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return this.{ser4::Service::index}(mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}]));
        });
      }, middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t124 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t125 = #t124.{core::List::addAll}(handlers) in let final dynamic #t126 = #t124.{core::List::addAll}(indexMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : indexMiddleware.{met::Middleware::handlers}) in #t124);
      met::Middleware createMiddleware = util::getAnnotation(service.{ser4::Service::create}, met::Middleware, this.{ser4::Service::app}.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Middleware;
      this.{rou2::Router::post}("/", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return req.{req::RequestContext::parseBody}().{asy::Future::then}<dynamic>((core::Map<dynamic, dynamic> body) → asy::Future<dynamic> {
            return this.{ser4::Service::create}(body, mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}])).{asy::Future::then}<dynamic>((dynamic r) → dynamic {
              res.{res::ResponseContext::statusCode} = 201;
              return r;
            });
          });
        });
      }, middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t127 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t128 = #t127.{core::List::addAll}(handlers) in let final dynamic #t129 = #t127.{core::List::addAll}(createMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : createMiddleware.{met::Middleware::handlers}) in #t127);
      met::Middleware readMiddleware = util::getAnnotation(service.{ser4::Service::read}, met::Middleware, this.{ser4::Service::app}.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Middleware;
      this.{rou2::Router::get}("/:id", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return this.{ser4::Service::read}(ser4::Service::parseId<dynamic>(req.{req::RequestContext::params}.{core::Map::[]}("id")), mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}]));
        });
      }, middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t130 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t131 = #t130.{core::List::addAll}(handlers) in let final dynamic #t132 = #t130.{core::List::addAll}(readMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : readMiddleware.{met::Middleware::handlers}) in #t130);
      met::Middleware modifyMiddleware = util::getAnnotation(service.{ser4::Service::modify}, met::Middleware, this.{ser4::Service::app}.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Middleware;
      this.{rou2::Router::patch}("/:id", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> => req.{req::RequestContext::parseBody}().{asy::Future::then}<dynamic>((core::Map<dynamic, dynamic> body) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return this.{ser4::Service::modify}(ser4::Service::parseId<dynamic>(req.{req::RequestContext::params}.{core::Map::[]}("id")), body, mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}]));
        });
      }), middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t133 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t134 = #t133.{core::List::addAll}(handlers) in let final dynamic #t135 = #t133.{core::List::addAll}(modifyMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : modifyMiddleware.{met::Middleware::handlers}) in #t133);
      met::Middleware updateMiddleware = util::getAnnotation(service.{ser4::Service::update}, met::Middleware, this.{ser4::Service::app}.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Middleware;
      this.{rou2::Router::post}("/:id", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> => req.{req::RequestContext::parseBody}().{asy::Future::then}<dynamic>((core::Map<dynamic, dynamic> body) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return this.{ser4::Service::update}(ser4::Service::parseId<dynamic>(req.{req::RequestContext::params}.{core::Map::[]}("id")), body, mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}]));
        });
      }), middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t136 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t137 = #t136.{core::List::addAll}(handlers) in let final dynamic #t138 = #t136.{core::List::addAll}(updateMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : updateMiddleware.{met::Middleware::handlers}) in #t136);
      this.{rou2::Router::put}("/:id", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> => req.{req::RequestContext::parseBody}().{asy::Future::then}<dynamic>((core::Map<dynamic, dynamic> body) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return this.{ser4::Service::update}(ser4::Service::parseId<dynamic>(req.{req::RequestContext::params}.{core::Map::[]}("id")), body, mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}]));
        });
      }), middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t139 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t140 = #t139.{core::List::addAll}(handlers) in let final dynamic #t141 = #t139.{core::List::addAll}(updateMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : updateMiddleware.{met::Middleware::handlers}) in #t139);
      met::Middleware removeMiddleware = util::getAnnotation(service.{ser4::Service::remove}, met::Middleware, this.{ser4::Service::app}.{rou::Routable::container}.{con::Container::reflector}) as{TypeError} met::Middleware;
      this.{rou2::Router::delete}("/", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return this.{ser4::Service::remove}(null, mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}]));
        });
      }, middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t142 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t143 = #t142.{core::List::addAll}(handlers) in let final dynamic #t144 = #t142.{core::List::addAll}(removeMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : removeMiddleware.{met::Middleware::handlers}) in #t142);
      this.{rou2::Router::delete}("/:id", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → asy::Future<dynamic> {
        return req.{req::RequestContext::parseQuery}().{asy::Future::then}<dynamic>((core::Map<core::String, dynamic> query) → asy::Future<dynamic> {
          return this.{ser4::Service::remove}(ser4::Service::parseId<dynamic>(req.{req::RequestContext::params}.{core::Map::[]}("id")), mer::mergeMap<dynamic, dynamic>(<core::Map<dynamic, dynamic>>[<dynamic, dynamic>{"query": query}, restProvider, req.{req::RequestContext::serviceParams}]));
        });
      }, middleware: let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t145 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t146 = #t145.{core::List::addAll}(handlers) in let final dynamic #t147 = #t145.{core::List::addAll}(removeMiddleware.{core::Object::==}(null) ?{core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>} <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] : removeMiddleware.{met::Middleware::handlers}) in #t145);
      this.{rou2::Router::put}("/", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → <BottomType>=> throw ang3::AngelHttpException::notFound());
      this.{rou2::Router::patch}("/", (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → <BottomType>=> throw ang3::AngelHttpException::notFound());
    }
    method onHooked(hoo::HookedService hookedService) → void {}
  }
}
library from "package:angel_framework/src/core/typed_service.dart" as typ {
}
library angel_http_exception from "package:angel_http_exception/angel_http_exception.dart" as ang3 {
  import "package:dart2_constant/convert.dart";
  class AngelHttpException extends core::Object implements core::Exception {
    field dynamic error;
    final field core::List<core::String> errors = <core::String>[];
    field core::String message;
    field core::StackTrace stackTrace;
    field core::int statusCode;
    constructor •(dynamic error, {core::String message = "500 Internal Server Error", core::StackTrace stackTrace = null, core::int statusCode = 500, core::List<core::String> errors = const <core::String>[]}) → void
      : ang3::AngelHttpException::error = error, ang3::AngelHttpException::message = message, ang3::AngelHttpException::stackTrace = stackTrace, ang3::AngelHttpException::statusCode = statusCode, super core::Object::•() {
      if(!errors.{core::Object::==}(null)) {
        this.{ang3::AngelHttpException::errors}.{core::List::addAll}(errors);
      }
    }
    method toJson() → core::Map<dynamic, dynamic> {
      return <dynamic, dynamic>{"isError": true, "status_code": this.{ang3::AngelHttpException::statusCode}, "message": this.{ang3::AngelHttpException::message}, "errors": this.{ang3::AngelHttpException::errors}};
    }
    method toMap() → core::Map<dynamic, dynamic>
      return this.{ang3::AngelHttpException::toJson}();
    @core::override
    method toString() → core::String {
      return "${this.{ang3::AngelHttpException::statusCode}}: ${this.{ang3::AngelHttpException::message}}";
    }
    static factory fromMap(core::Map<dynamic, dynamic> data) → ang3::AngelHttpException {
      return new ang3::AngelHttpException::•(null, statusCode: (let final dynamic #t148 = data.{core::Map::[]}("status_code") in #t148.==(null) ?{dynamic} data.{core::Map::[]}("statusCode") : #t148) as core::int, message: let final dynamic #t149 = data.{core::Map::[]}("message") in #t149.==(null) ?{core::String} null : #t149.{core::Object::toString}(), errors: data.{core::Map::[]}("errors") is core::Iterable<dynamic> ?{core::List<core::String>} (data.{core::Map::[]}("errors") as core::Iterable<dynamic>).{core::Iterable::map}<core::String>((dynamic x) → core::String => x.{core::Object::toString}()).{core::Iterable::toList}() : <core::String>[]);
    }
    static factory fromJson(core::String str) → ang3::AngelHttpException
      return ang3::AngelHttpException::fromMap(con4::json.{con2::JsonCodec::decode}(str) as core::Map<dynamic, dynamic>);
    static factory badRequest({core::String message = "400 Bad Request", core::List<core::String> errors = const <core::String>[]}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, errors: errors, statusCode: 400);
    static factory notAuthenticated({core::String message = "401 Not Authenticated"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 401);
    static factory paymentRequired({core::String message = "402 Payment Required"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 402);
    static factory forbidden({core::String message = "403 Forbidden"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 403);
    static factory notFound({core::String message = "404 Not Found"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 404);
    static factory methodNotAllowed({core::String message = "405 Method Not Allowed"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 405);
    static factory notAcceptable({core::String message = "406 Not Acceptable"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 406);
    static factory methodTimeout({core::String message = "408 Timeout"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 408);
    static factory conflict({core::String message = "409 Conflict"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 409);
    static factory notProcessable({core::String message = "422 Not Processable"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 422);
    static factory notImplemented({core::String message = "501 Not Implemented"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 501);
    static factory unavailable({core::String message = "503 Unavailable"}) → ang3::AngelHttpException
      return new ang3::AngelHttpException::•(null, message: message, statusCode: 503);
  }
}
library from "package:angel_model/angel_model.dart" as ang5 {
  class Model extends core::Object {
    field core::String id;
    field core::DateTime createdAt;
    field core::DateTime updatedAt;
    constructor •({core::String id = null, core::DateTime createdAt = null, core::DateTime updatedAt = null}) → void
      : ang5::Model::id = id, ang5::Model::createdAt = createdAt, ang5::Model::updatedAt = updatedAt, super core::Object::•()
      ;
  }
}
library angel_route from "package:angel_route/angel_route.dart" as ang6 {
  export "package:angel_route/src/middleware_pipeline.dart";
  export "package:angel_route/src/router.dart";
  export "package:angel_route/src/routing_exception.dart";
}
library body_parser from "package:body_parser/body_parser.dart" as bod2 {
  export "package:body_parser/src/body_parse_result.dart";
  export "package:body_parser/src/file_upload_info.dart";
  export "package:body_parser/src/parse_body.dart";
}
library from "package:angel_framework/src/http/angel_http.dart" as ang4 {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:angel_http_exception/angel_http_exception.dart";
  import "package:angel_route/angel_route.dart";
  import "package:combinator/combinator.dart";
  import "package:stack_trace/stack_trace.dart";
  import "package:tuple/tuple.dart";
  import "package:angel_framework/src/core/core.dart";
  import "package:angel_framework/src/http/http_request_context.dart";
  import "package:angel_framework/src/http/http_response_context.dart";
  class AngelHttp extends core::Object {
    final field ser::Angel app;
    final field core::bool useZone;
    field core::bool _closed = false;
    field _ht::HttpServer _server = null;
    field (dynamic, core::int) → asy::Future<_ht::HttpServer> _serverGenerator = _ht::HttpServer::bind;
    field asy::StreamSubscription<_ht::HttpRequest> _sub = null;
    constructor •(ser::Angel app, {core::bool useZone = false}) → void
      : ang4::AngelHttp::app = app, ang4::AngelHttp::useZone = useZone, super core::Object::•()
      ;
    get serverGenerator() → (dynamic, core::int) → asy::Future<_ht::HttpServer>
      return this.{ang4::AngelHttp::_serverGenerator};
    static factory custom(ser::Angel app, (dynamic, core::int) → asy::Future<_ht::HttpServer> serverGenerator, {core::bool useZone = true}) → ang4::AngelHttp {
      return let final ang4::AngelHttp #t150 = new ang4::AngelHttp::•(app, useZone: useZone) in let final dynamic #t151 = #t150.{ang4::AngelHttp::_serverGenerator} = serverGenerator in #t150;
    }
    static factory fromSecurityContext(ser::Angel app, io::SecurityContext context, {core::bool useZone = true}) → ang4::AngelHttp {
      ang4::AngelHttp http = new ang4::AngelHttp::•(app, useZone: useZone);
      http.{ang4::AngelHttp::_serverGenerator} = (dynamic address, core::int port) → asy::Future<_ht::HttpServer> {
        return _ht::HttpServer::bindSecure(address, port, context);
      };
      return http;
    }
    static factory secure(ser::Angel app, core::String certificateChainPath, core::String serverKeyPath, {core::String password = null, core::bool useZone = true}) → ang4::AngelHttp {
      core::String certificateChain = io::Platform::script.{core::Uri::resolve}(certificateChainPath).{core::Uri::toFilePath}();
      core::String serverKey = io::Platform::script.{core::Uri::resolve}(serverKeyPath).{core::Uri::toFilePath}();
      io::SecurityContext serverContext = io::SecurityContext::•();
      serverContext.{io::SecurityContext::useCertificateChain}(certificateChain, password: password);
      serverContext.{io::SecurityContext::usePrivateKey}(serverKey, password: password);
      return ang4::AngelHttp::fromSecurityContext(app, serverContext, useZone: useZone);
    }
    get httpServer() → _ht::HttpServer
      return this.{ang4::AngelHttp::_server};
    method startServer([dynamic address = null, core::int port = null]) → asy::Future<_ht::HttpServer> {
      dynamic host = let final dynamic #t152 = address in #t152.==(null) ?{dynamic} "127.0.0.1" : #t152;
      return this.{ang4::AngelHttp::_serverGenerator}(host, let final core::int #t153 = port in #t153.==(null) ?{core::int} 0 : #t153).{asy::Future::then}<_ht::HttpServer>((_ht::HttpServer server) → asy::Future<_ht::HttpServer> {
        this.{ang4::AngelHttp::_server} = server;
        return asy::Future::wait<dynamic>(this.{ang4::AngelHttp::app}.{ser::Angel::startupHooks}.{core::Iterable::map}<asy::Future<dynamic>>(this.{ang4::AngelHttp::app}.{ser::Angel::configure})).{asy::Future::then}<_ht::HttpServer>((core::List<dynamic> _) → _ht::HttpServer {
          this.{ang4::AngelHttp::app}.{ser::Angel::optimizeForProduction}();
          this.{ang4::AngelHttp::_sub} = this.{ang4::AngelHttp::_server}.{asy::Stream::listen}(this.{ang4::AngelHttp::handleRequest});
          return this.{ang4::AngelHttp::_server};
        });
      });
    }
    method close() → asy::Future<_ht::HttpServer> {
      if(this.{ang4::AngelHttp::_closed})
        return asy::Future::value<_ht::HttpServer>(this.{ang4::AngelHttp::_server});
      this.{ang4::AngelHttp::_closed} = true;
      let final asy::StreamSubscription<_ht::HttpRequest> #t154 = this.{ang4::AngelHttp::_sub} in #t154.==(null) ?{asy::Future<dynamic>} null : #t154.{asy::StreamSubscription::cancel}();
      return this.{ang4::AngelHttp::app}.{ser::Angel::close}().{asy::Future::then}<_ht::HttpServer>((dynamic _) → asy::Future<_ht::HttpServer> => asy::Future::wait<dynamic>(this.{ang4::AngelHttp::app}.{ser::Angel::shutdownHooks}.{core::Iterable::map}<asy::Future<dynamic>>(this.{ang4::AngelHttp::app}.{ser::Angel::configure})).{asy::Future::then}<_ht::HttpServer>((core::List<dynamic> _) → _ht::HttpServer => this.{ang4::AngelHttp::_server}));
    }
    method handleRequest(_ht::HttpRequest request) → asy::Future<dynamic> {
      return this.{ang4::AngelHttp::createRequestContext}(request).{asy::Future::then}<dynamic>((htt::HttpRequestContext req) → asy::Future<dynamic> {
        return this.{ang4::AngelHttp::createResponseContext}(request.{_ht::HttpRequest::response}, req).{asy::Future::then}<dynamic>((res::ResponseContext<dynamic> res) → asy::FutureOr<dynamic> {
          function handle() → asy::Future<dynamic> {
            core::String path = req.{htt::HttpRequestContext::path};
            if(path.{core::String::==}("/"))
              path = "";
            function resolveTuple() → tup::Tuple3<core::List<dynamic>, core::Map<core::String, dynamic>, com::ParseResult<core::Map<core::String, dynamic>>> {
              rou2::Router<dynamic> r = this.{ang4::AngelHttp::app}.{ser::Angel::optimizedRouter};
              core::Iterable<rou2::RoutingResult<dynamic>> resolved = r.{rou2::Router::resolveAbsolute}(path, method: req.{htt::HttpRequestContext::method}, strip: false);
              return new tup::Tuple3::•<core::List<dynamic>, core::Map<core::String, dynamic>, com::ParseResult<core::Map<core::String, dynamic>>>(new mid::MiddlewarePipeline::•<dynamic>(resolved).{mid::MiddlewarePipeline::handlers}, resolved.{core::Iterable::fold}<core::Map<core::String, dynamic>>(<core::String, dynamic>{}, (core::Map<core::String, dynamic> out, rou2::RoutingResult<dynamic> r) → core::Map<core::String, dynamic> => let final core::Map<core::String, dynamic> #t155 = out in let final dynamic #t156 = #t155.{core::Map::addAll}(r.{rou2::RoutingResult::allParams}) in #t155), resolved.{core::Iterable::isEmpty} ?{com::ParseResult<core::Map<core::String, dynamic>>} null : resolved.{core::Iterable::first}.{rou2::RoutingResult::parseResult});
            }
            core::String cacheKey = req.{htt::HttpRequestContext::method}.{core::String::+}(path);
            tup::Tuple3<core::List<dynamic>, core::Map<core::String, dynamic>, com::ParseResult<core::Map<core::String, dynamic>>> tuple = this.{ang4::AngelHttp::app}.{ser::Angel::isProduction} ?{tup::Tuple3<core::List<dynamic>, core::Map<core::String, dynamic>, com::ParseResult<core::Map<core::String, dynamic>>>} this.{ang4::AngelHttp::app}.{ser::Angel::handlerCache}.{core::Map::putIfAbsent}(cacheKey, resolveTuple) : resolveTuple.call();
            req.{req::RequestContext::params}.{core::Map::addAll}(tuple.{tup::Tuple3::item2});
            req.{htt::HttpRequestContext::container}.{con::Container::registerSingleton}<com::ParseResult<core::Map<core::String, dynamic>>>(tuple.{tup::Tuple3::item3});
            req.{htt::HttpRequestContext::container}.{con::Container::registerSingleton}<com::ParseResult<dynamic>>(tuple.{tup::Tuple3::item3});
            if(!this.{ang4::AngelHttp::app}.{ser::Angel::isProduction} && !this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{core::Object::==}(null)) {
              req.{htt::HttpRequestContext::container}.{con::Container::registerSingleton}<core::Stopwatch>(let final core::Stopwatch #t157 = new core::Stopwatch::•() in let final dynamic #t158 = #t157.{core::Stopwatch::start}() in #t157);
            }
            core::List<dynamic> pipeline = tuple.{tup::Tuple3::item1};
            () → asy::Future<dynamic> runPipeline;
            #L24:
            for (dynamic handler in pipeline) {
              if(handler.{core::Object::==}(null))
                break #L24;
              if(runPipeline.{core::Object::==}(null))
                runPipeline = () → asy::Future<dynamic> => asy::Future::sync<dynamic>(() → asy::Future<core::bool> => this.{ang4::AngelHttp::app}.{ser::Angel::executeHandler}(handler, req, res));
              else {
                () → asy::Future<dynamic> current = runPipeline;
                runPipeline = () → asy::Future<dynamic> => current.call().{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> => !res.{res::ResponseContext::isOpen} ?{asy::Future<dynamic>} asy::Future::value<dynamic>(result) : this.{ang4::AngelHttp::app}.{ser::Angel::executeHandler}(handler, req, res));
              }
            }
            return runPipeline.{core::Object::==}(null) ?{asy::Future<dynamic>} this.{ang4::AngelHttp::sendResponse}(request, req, res) : runPipeline.call().{asy::Future::then}<dynamic>((dynamic _) → asy::Future<dynamic> => this.{ang4::AngelHttp::sendResponse}(request, req, res));
          }
          if(this.{ang4::AngelHttp::useZone}.{core::Object::==}(false)) {
            asy::Future<dynamic> f;
            try {
              f = handle.call();
            }
            on dynamic catch(final dynamic e, final core::StackTrace st) {
              f = asy::Future::error<dynamic>(e, st);
            }
            return f.{asy::Future::catchError}((dynamic e, core::StackTrace st) → core::Null {
              if(e is core::FormatException)
                throw let final ang3::AngelHttpException #t159 = ang3::AngelHttpException::badRequest(message: e{core::FormatException}.{core::FormatException::message}) in let final dynamic #t160 = #t159.{ang3::AngelHttpException::stackTrace} = st in #t159;
              throw new ang3::AngelHttpException::•(e, stackTrace: st, statusCode: 500, message: let final core::String #t161 = let final dynamic #t162 = e in #t162.==(null) ?{core::String} null : #t162.{core::Object::toString}() in #t161.==(null) ?{core::String} "500 Internal Server Error" : #t161);
            }, test: (core::Object e) → core::bool => !(e is ang3::AngelHttpException)).{asy::Future::catchError}((dynamic ee, core::StackTrace st) → asy::Future<dynamic> {
              ang3::AngelHttpException e = ee as ang3::AngelHttpException;
              if(!this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{core::Object::==}(null)) {
                dynamic error = let final dynamic #t163 = e.{ang3::AngelHttpException::error} in #t163.==(null) ?{dynamic} e : #t163;
                tra::Trace trace = tra::Trace::from(let final core::StackTrace #t164 = e.{ang3::AngelHttpException::stackTrace} in #t164.==(null) ?{core::StackTrace} core::StackTrace::current : #t164).{tra::Trace::terse};
                this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{log::Logger::severe}(let final core::String #t165 = e.{ang3::AngelHttpException::message} in #t165.==(null) ?{core::String} e.{ang3::AngelHttpException::toString}() : #t165, error, trace);
              }
              return this.{ang4::AngelHttp::handleAngelHttpException}(e, let final core::StackTrace #t166 = e.{ang3::AngelHttpException::stackTrace} in #t166.==(null) ?{core::StackTrace} st : #t166, req, res, request);
            });
          }
          else {
            asy::ZoneSpecification zoneSpec = new asy::_ZoneSpecification::•(print: (asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, core::String line) → core::Null {
              if(!this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{core::Object::==}(null))
                this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{log::Logger::info}(line);
              else
                parent.{asy::ZoneDelegate::print}(zone, line);
            }, handleUncaughtError: (asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, core::Object error, core::StackTrace stackTrace) → void {
              tra::Trace trace = tra::Trace::from(let final core::StackTrace #t167 = stackTrace in #t167.==(null) ?{core::StackTrace} core::StackTrace::current : #t167).{tra::Trace::terse};
              return asy::Future::•<dynamic>(() → asy::Future<dynamic> {
                ang3::AngelHttpException e;
                if(error is core::FormatException) {
                  e = ang3::AngelHttpException::badRequest(message: error{core::FormatException}.{core::FormatException::message});
                }
                else
                  if(error is ang3::AngelHttpException) {
                    e = error{ang3::AngelHttpException};
                  }
                  else {
                    e = new ang3::AngelHttpException::•(error, stackTrace: stackTrace, message: let final core::String #t168 = let final core::Object #t169 = error in #t169.==(null) ?{core::String} null : #t169.{core::Object::toString}() in #t168.==(null) ?{core::String} "500 Internal Server Error" : #t168);
                  }
                if(!this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{core::Object::==}(null)) {
                  this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{log::Logger::severe}(let final core::String #t170 = e.{ang3::AngelHttpException::message} in #t170.==(null) ?{core::String} e.{ang3::AngelHttpException::toString}() : #t170, error, trace);
                }
                return this.{ang4::AngelHttp::handleAngelHttpException}(e, trace, req, res, request);
              }).{asy::Future::catchError}((dynamic e, core::StackTrace st) → core::Null {
                tra::Trace trace = tra::Trace::from(let final core::StackTrace #t171 = st in #t171.==(null) ?{core::StackTrace} core::StackTrace::current : #t171).{tra::Trace::terse};
                request.{_ht::HttpRequest::response}.{io::IOSink::close}();
                if(!this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{core::Object::==}(null)) {
                  this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{log::Logger::severe}("Fatal error occurred when processing ${request.{_ht::HttpRequest::uri}}.", e, trace);
                }
                else {
                  let final io::Stdout #t172 = io::stderr in let final dynamic #t173 = #t172.{io::_StdSink::writeln}("Fatal error occurred when processing ${request.{_ht::HttpRequest::uri}}:") in let final dynamic #t174 = #t172.{io::_StdSink::writeln}(e) in let final dynamic #t175 = #t172.{io::_StdSink::writeln}(trace) in #t172;
                }
              });
            });
            asy::Zone zone = asy::Zone::current.{asy::Zone::fork}(specification: zoneSpec);
            req.{htt::HttpRequestContext::container}.{con::Container::registerSingleton}<asy::Zone>(zone);
            req.{htt::HttpRequestContext::container}.{con::Container::registerSingleton}<asy::ZoneSpecification>(zoneSpec);
            try {
              return zone.{asy::Zone::run}<asy::FutureOr<dynamic>>(handle);
            }
            on dynamic catch(final dynamic e, final core::StackTrace st) {
              zone.{asy::Zone::handleUncaughtError}(e, st);
              return asy::Future::value<dynamic>();
            }
          }
        });
      });
    }
    method handleAngelHttpException(ang3::AngelHttpException e, core::StackTrace st, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res, _ht::HttpRequest request, {core::bool ignoreFinalizers = false}) → asy::Future<dynamic> {
      if(req.{core::Object::==}(null) || res.{core::Object::==}(null)) {
        try {
          let final log::Logger #t176 = this.{ang4::AngelHttp::app}.{ser::Angel::logger} in #t176.==(null) ?{void} null : #t176.{log::Logger::severe}(e, st);
          let final _ht::HttpResponse #t177 = request.{_ht::HttpRequest::response} in let final dynamic #t178 = #t177.{_ht::HttpResponse::statusCode} = 500 in let final dynamic #t179 = #t177.{io::IOSink::write}("500 Internal Server Error") in let final dynamic #t180 = #t177.{io::IOSink::close}() in #t177;
        }
        finally {
          return null;
        }
      }
      asy::Future<dynamic> handleError;
      if(!res.{res::ResponseContext::isOpen})
        handleError = asy::Future::value<dynamic>();
      else {
        res.{res::ResponseContext::statusCode} = e.{ang3::AngelHttpException::statusCode};
        handleError = asy::Future::sync<dynamic>(() → dynamic => this.{ang4::AngelHttp::app}.{ser::Angel::errorHandler}(e, req, res)).{asy::Future::then}<dynamic>((dynamic result) → asy::Future<dynamic> {
          return this.{ang4::AngelHttp::app}.{ser::Angel::executeHandler}(result, req, res).{asy::Future::then}<dynamic>((core::bool _) → asy::Future<dynamic> => res.{res::ResponseContext::close}());
        });
      }
      return handleError.{asy::Future::then}<dynamic>((dynamic _) → asy::Future<dynamic> => this.{ang4::AngelHttp::sendResponse}(request, req, res, ignoreFinalizers: ignoreFinalizers.{core::Object::==}(true)));
    }
    method sendResponse(_ht::HttpRequest request, req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res, {core::bool ignoreFinalizers = false}) → asy::Future<dynamic> {
      function _cleanup(dynamic _) → void {
        if(!this.{ang4::AngelHttp::app}.{ser::Angel::isProduction} && !this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{core::Object::==}(null)) {
          core::Stopwatch sw = req.{req::RequestContext::container}.{con::Container::make}<core::Stopwatch>();
          this.{ang4::AngelHttp::app}.{ser::Angel::logger}.{log::Logger::info}("${res.{res::ResponseContext::statusCode}} ${req.{req::RequestContext::method}} ${req.{req::RequestContext::uri}} (${let final core::int #t181 = let final core::Stopwatch #t182 = sw in #t182.==(null) ?{core::int} null : #t182.{core::Stopwatch::elapsedMilliseconds} in #t181.==(null) ?{core::Object} "unknown" : #t181} ms)");
        }
      }
      if(!res.{res::ResponseContext::isBuffered})
        return res.{res::ResponseContext::close}().{asy::Future::then}<dynamic>(_cleanup);
      asy::Future<dynamic> finalizers = ignoreFinalizers.{core::Object::==}(true) ?{asy::Future<dynamic>} asy::Future::value<dynamic>() : this.{ang4::AngelHttp::app}.{ser::Angel::responseFinalizers}.{core::Iterable::fold}<asy::Future<dynamic>>(asy::Future::value<dynamic>(), (asy::Future<dynamic> out, (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> f) → asy::Future<dynamic> => out.{asy::Future::then}<dynamic>((dynamic _) → asy::FutureOr<dynamic> => f.call(req, res)));
      return finalizers.{asy::Future::then}<dynamic>((dynamic _) → asy::Future<dynamic> {
        if(res.{res::ResponseContext::isOpen})
          res.{res::ResponseContext::close}();
        for (core::String key in res.{res::ResponseContext::headers}.{core::Map::keys}) {
          request.{_ht::HttpRequest::response}.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::add}(key, res.{res::ResponseContext::headers}.{core::Map::[]}(key));
        }
        request.{_ht::HttpRequest::response}.{_ht::HttpResponse::contentLength} = res.{res::ResponseContext::buffer}.{io::BytesBuilder::length};
        request.{_ht::HttpRequest::response}.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::chunkedTransferEncoding} = let final core::bool #t183 = res.{res::ResponseContext::chunked} in #t183.==(null) ?{core::bool} true : #t183;
        core::List<core::int> outputBuffer = res.{res::ResponseContext::buffer}.{io::BytesBuilder::toBytes}();
        if(res.{res::ResponseContext::encoders}.{core::Map::isNotEmpty}) {
          core::Iterable<core::String> allowedEncodings = let final core::Iterable<core::String> #t184 = let final core::Iterable<core::String> #t185 = let final core::List<core::String> #t186 = let final core::String #t187 = req.{req::RequestContext::headers}.{_ht::HttpHeaders::value}("accept-encoding") in #t187.==(null) ?{core::List<core::String>} null : #t187.{core::String::split}(",") in #t186.==(null) ?{core::Iterable<core::String>} null : #t186.{core::Iterable::map}<core::String>((core::String s) → core::String => s.{core::String::trim}()) in #t185.==(null) ?{core::Iterable<core::String>} null : #t185.{core::Iterable::where}((core::String s) → core::bool => s.{core::String::isNotEmpty}) in #t184.==(null) ?{core::Iterable<core::String>} null : #t184.{core::Iterable::map}<core::String>((core::String str) → core::String {
            if(!str.{core::String::contains}(";"))
              return str;
            return str.{core::String::split}(";").{core::List::[]}(0);
          });
          if(!allowedEncodings.{core::Object::==}(null)) {
            #L25:
            for (core::String encodingName in allowedEncodings) {
              con2::Converter<core::List<core::int>, core::List<core::int>> encoder;
              core::String key = encodingName;
              if(res.{res::ResponseContext::encoders}.{core::Map::containsKey}(encodingName))
                encoder = res.{res::ResponseContext::encoders}.{core::Map::[]}(encodingName);
              else
                if(encodingName.{core::String::==}("*")) {
                  encoder = res.{res::ResponseContext::encoders}.{core::Map::[]}(key = res.{res::ResponseContext::encoders}.{core::Map::keys}.{core::Iterable::first});
                }
              if(!encoder.{core::Object::==}(null)) {
                request.{_ht::HttpRequest::response}.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}("content-encoding", key);
                outputBuffer = res.{res::ResponseContext::encoders}.{core::Map::[]}(key).{con2::Converter::convert}(outputBuffer);
                request.{_ht::HttpRequest::response}.{_ht::HttpResponse::contentLength} = outputBuffer.{core::List::length};
                break #L25;
              }
            }
          }
        }
        let final _ht::HttpResponse #t188 = request.{_ht::HttpRequest::response} in let final dynamic #t189 = #t188.{_ht::HttpResponse::statusCode} = res.{res::ResponseContext::statusCode} in let final dynamic #t190 = #t188.{_ht::HttpResponse::cookies}.{core::List::addAll}(res.{res::ResponseContext::cookies}) in let final dynamic #t191 = #t188.{io::IOSink::add}(outputBuffer) in #t188;
        return request.{_ht::HttpRequest::response}.{io::IOSink::close}().{asy::Future::then}<dynamic>(_cleanup);
      });
    }
    method createRequestContext(_ht::HttpRequest request) → asy::Future<htt::HttpRequestContext> {
      core::String path = request.{_ht::HttpRequest::uri}.{core::Uri::path}.{core::String::replaceAll}(ang4::_straySlashes, "");
      if(path.{core::String::length}.{core::num::==}(0))
        path = "/";
      return htt::HttpRequestContext::from(request, this.{ang4::AngelHttp::app}, path);
    }
    method createResponseContext(_ht::HttpResponse response, [req::RequestContext<dynamic> correspondingRequest = null]) → asy::Future<res::ResponseContext<dynamic>>
      return asy::Future::value<res::ResponseContext<dynamic>>(let final htt2::HttpResponseContext #t192 = new htt2::HttpResponseContext::•(response, this.{ang4::AngelHttp::app}, correspondingRequest as htt::HttpRequestContext) in let final dynamic #t193 = #t192.{res::ResponseContext::serializer} = let final (dynamic) → core::String #t194 = this.{ang4::AngelHttp::app}.{ser::Angel::serializer} in #t194.==(null) ?{(core::Object) → core::String} con2::json.{con2::JsonCodec::encode} : #t194 in let final dynamic #t195 = #t192.{res::ResponseContext::encoders}.{core::Map::addAll}(let final core::Map<core::String, con2::Converter<core::List<core::int>, core::List<core::int>>> #t196 = this.{ang4::AngelHttp::app}.{ser::Angel::encoders} in #t196.==(null) ?{core::Map<core::String, con2::Converter<core::List<core::int>, core::List<core::int>>>} <core::String, con2::Converter<core::List<core::int>, core::List<core::int>>>{} : #t196) in #t192);
  }
  static final field core::RegExp _straySlashes = core::RegExp::•("(^/+)|(/+\$)");
}
library angel_framework.http.controller from "package:angel_framework/src/http/controller.dart" as con3 {
  import "dart:async";
  import "package:angel_container/angel_container.dart";
  import "package:angel_route/angel_route.dart";
  import "package:meta/meta.dart";
  import "package:angel_framework/src/core/core.dart";
  class Controller extends core::Object {
    field ser::Angel _app = null;
    final field core::bool injectSingleton;
    field core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> middleware = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[];
    field core::Map<core::String, rou2::Route<dynamic>> routeMappings = <core::String, rou2::Route<dynamic>>{};
    constructor •({core::bool injectSingleton = true}) → void
      : con3::Controller::injectSingleton = injectSingleton, super core::Object::•()
      ;
    get app() → ser::Angel
      return this.{con3::Controller::_app};
    @meta::mustCallSuper
    method configureServer(ser::Angel app) → asy::Future<dynamic> {
      this.{con3::Controller::_app} = app;
      if(!this.{con3::Controller::injectSingleton}.{core::Object::==}(false)) {
        this.{con3::Controller::_app}.{rou::Routable::container}.{con::Container::registerSingleton}<con3::Controller>(this, as: this.{core::Object::runtimeType});
      }
      ref::ReflectedClass classMirror = app.{rou::Routable::container}.{con::Container::reflector}.{ref::Reflector::reflectClass}(this.{core::Object::runtimeType});
      met::Expose exposeDecl = this.{con3::Controller::findExpose}(app.{rou::Routable::container}.{con::Container::reflector});
      if(exposeDecl.{core::Object::==}(null)) {
        throw core::Exception::•("All controllers must carry an @Expose() declaration.");
      }
      rou::Routable routable = new rou::Routable::•();
      app.{ser::Angel::mount}(exposeDecl.{met::Expose::path}, routable);
      ref::ReflectedType typeMirror = app.{rou::Routable::container}.{con::Container::reflector}.{ref::Reflector::reflectType}(this.{core::Object::runtimeType});
      core::String name = (let final core::String #t197 = exposeDecl.{met::Expose::as} in #t197.==(null) ?{core::bool} null : #t197.{core::String::isNotEmpty}).{core::Object::==}(true) ?{core::String} exposeDecl.{met::Expose::as} : typeMirror.{ref::ReflectedType::name};
      app.{ser::Angel::controllers}.{core::Map::[]=}(name, this);
      ref::ReflectedInstance instanceMirror = app.{rou::Routable::container}.{con::Container::reflector}.{ref::Reflector::reflectInstance}(this);
      final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlers = let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t198 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t199 = #t198.{core::List::addAll}(exposeDecl.{met::Expose::middleware}) in let final dynamic #t200 = #t198.{core::List::addAll}(this.{con3::Controller::middleware}) in #t198;
      final (ref::ReflectedDeclaration) → void routeBuilder = this.{con3::Controller::_routeBuilder}(instanceMirror, routable, handlers);
      classMirror.{ref::ReflectedClass::declarations}.{core::Iterable::forEach}(routeBuilder);
      this.{con3::Controller::configureRoutes}(routable);
      return asy::Future::value<dynamic>();
    }
    method _routeBuilder(ref::ReflectedInstance instanceMirror, rou::Routable routable, core::Iterable<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> handlers) → (ref::ReflectedDeclaration) → void {
      return (ref::ReflectedDeclaration decl) → core::Null {
        core::String methodName = decl.{ref::ReflectedDeclaration::name};
        if(!methodName.{core::String::==}("toString") && !methodName.{core::String::==}("noSuchMethod") && !methodName.{core::String::==}("call") && !methodName.{core::String::==}("equals") && !methodName.{core::String::==}("==")) {
          met::Expose exposeDecl = decl.{ref::ReflectedDeclaration::function}.{ref::ReflectedFunction::annotations}.{core::Iterable::map}<core::Object>((ref::ReflectedInstance m) → core::Object => m.{ref::ReflectedInstance::reflectee}).{core::Iterable::firstWhere}((core::Object r) → core::bool => r is met::Expose, orElse: () → core::Null => null) as{TypeError} met::Expose;
          if(exposeDecl.{core::Object::==}(null))
            return;
          core::Function reflectedMethod = instanceMirror.{ref::ReflectedInstance::getField}(methodName).{ref::ReflectedInstance::reflectee} as core::Function;
          core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> middleware = let final core::List<(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>> #t201 = <(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>>[] in let final dynamic #t202 = #t201.{core::List::addAll}(handlers) in let final dynamic #t203 = #t201.{core::List::addAll}(exposeDecl.{met::Expose::middleware}) in #t201;
          core::String name = (let final core::String #t204 = exposeDecl.{met::Expose::as} in #t204.==(null) ?{core::bool} null : #t204.{core::String::isNotEmpty}).{core::Object::==}(true) ?{core::String} exposeDecl.{met::Expose::as} : methodName;
          ref::ReflectedFunction method = decl.{ref::ReflectedDeclaration::function};
          if(method.{ref::ReflectedFunction::parameters}.{core::List::length}.{core::num::==}(2) && method.{ref::ReflectedFunction::parameters}.{core::List::[]}(0).{ref::ReflectedParameter::type}.{ref::ReflectedType::reflectedType}.{core::Object::==}(req::RequestContext<dynamic>) && method.{ref::ReflectedFunction::parameters}.{core::List::[]}(1).{ref::ReflectedParameter::type}.{ref::ReflectedType::reflectedType}.{core::Object::==}(res::ResponseContext<dynamic>)) {
            this.{con3::Controller::routeMappings}.{core::Map::[]=}(name, routable.{rou::Routable::addRoute}(exposeDecl.{met::Expose::method}, exposeDecl.{met::Expose::path}, (req::RequestContext<dynamic> req, res::ResponseContext<dynamic> res) → dynamic {
              dynamic result = reflectedMethod.call(req, res);
              return result is (req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic> ?{dynamic} result{(req::RequestContext<dynamic>, res::ResponseContext<dynamic>) → asy::FutureOr<dynamic>}.call(req, res) : result;
            }, middleware: middleware));
            return;
          }
          req::InjectionRequest injection = req::preInject(reflectedMethod, this.{con3::Controller::app}.{rou::Routable::container}.{con::Container::reflector});
          if((let final core::List<core::String> #t205 = let final met::Expose #t206 = exposeDecl in #t206.==(null) ?{core::List<core::String>} null : #t206.{met::Expose::allowNull} in #t205.==(null) ?{core::bool} null : #t205.{core::Iterable::isNotEmpty}).{core::Object::==}(true))
            let final core::List<core::String> #t207 = injection.{req::InjectionRequest::optional} in #t207.==(null) ?{void} null : #t207.{core::List::addAll}(exposeDecl.{met::Expose::allowNull});
          this.{con3::Controller::routeMappings}.{core::Map::[]=}(name, routable.{rou::Routable::addRoute}(exposeDecl.{met::Expose::method}, exposeDecl.{met::Expose::path}, req::handleContained(reflectedMethod, injection), middleware: middleware));
        }
      };
    }
    method configureRoutes(rou::Routable routable) → void {}
    method findExpose(ref::Reflector reflector) → met::Expose
      return reflector.{ref::Reflector::reflectClass}(this.{core::Object::runtimeType}).{ref::ReflectedClass::annotations}.{core::Iterable::map}<core::Object>((ref::ReflectedInstance m) → core::Object => m.{ref::ReflectedInstance::reflectee}).{core::Iterable::firstWhere}((core::Object r) → core::bool => r is met::Expose, orElse: () → core::Null => null) as met::Expose;
  }
}
library from "package:angel_framework/src/http/http_request_context.dart" as htt {
  import "dart:async";
  import "dart:io";
  import "package:angel_container/angel_container.dart";
  import "package:body_parser/body_parser.dart";
  import "package:http_parser/http_parser.dart";
  import "package:angel_framework/src/core/core.dart";
  class HttpRequestContext extends req::RequestContext<_ht::HttpRequest> {
    field con::Container _container = null;
    field med::MediaType _contentType = null;
    field _ht::HttpRequest _io = null;
    field core::String _override = null;
    field core::String _path = null;
    synthetic constructor •() → void
      : super req::RequestContext::•()
      ;
    @core::override
    get container() → con::Container
      return this.{htt::HttpRequestContext::_container};
    @core::override
    get contentType() → med::MediaType {
      return this.{htt::HttpRequestContext::_contentType};
    }
    @core::override
    get cookies() → core::List<_ht::Cookie> {
      return this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::cookies};
    }
    @core::override
    get headers() → _ht::HttpHeaders {
      return this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::headers};
    }
    @core::override
    get hostname() → core::String {
      return this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::value}("host");
    }
    get rawRequest() → _ht::HttpRequest
      return this.{htt::HttpRequestContext::_io};
    @core::override
    get method() → core::String {
      return let final core::String #t208 = this.{htt::HttpRequestContext::_override} in #t208.==(null) ?{core::String} this.{htt::HttpRequestContext::originalMethod} : #t208;
    }
    @core::override
    get originalMethod() → core::String {
      return this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::method};
    }
    @core::override
    get path() → core::String {
      return this.{htt::HttpRequestContext::_path};
    }
    @core::override
    get remoteAddress() → io::InternetAddress {
      return this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::connectionInfo}.{_ht::HttpConnectionInfo::remoteAddress};
    }
    @core::override
    get session() → _ht::HttpSession {
      return this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::session};
    }
    @core::override
    get uri() → core::Uri {
      return this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::uri};
    }
    @core::override
    get xhr() → core::bool {
      return (let final core::String #t209 = let final core::String #t210 = this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::value}("X-Requested-With") in #t210.==(null) ?{core::String} null : #t210.{core::String::trim}() in #t209.==(null) ?{core::String} null : #t209.{core::String::toLowerCase}()).{core::String::==}("xmlhttprequest");
    }
    static method from(_ht::HttpRequest request, ser::Angel app, core::String path) → asy::Future<htt::HttpRequestContext> {
      htt::HttpRequestContext ctx = let final htt::HttpRequestContext #t211 = new htt::HttpRequestContext::•() in let final dynamic #t212 = #t211.{htt::HttpRequestContext::_container} = app.{rou::Routable::container}.{con::Container::createChild}() in #t211;
      core::String override = request.{_ht::HttpRequest::method};
      if(app.{ser::Angel::allowMethodOverrides}.{core::Object::==}(true))
        override = let final core::String #t213 = let final core::String #t214 = request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::value}("x-http-method-override") in #t214.==(null) ?{core::String} null : #t214.{core::String::toUpperCase}() in #t213.==(null) ?{core::String} request.{_ht::HttpRequest::method} : #t213;
      ctx.{req::RequestContext::app} = app;
      ctx.{htt::HttpRequestContext::_contentType} = request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::contentType}.{core::Object::==}(null) ?{med::MediaType} null : med::MediaType::parse(request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::contentType}.{core::Object::toString}());
      ctx.{htt::HttpRequestContext::_override} = override;
      ctx.{htt::HttpRequestContext::_path} = path;
      ctx.{htt::HttpRequestContext::_io} = request;
      if(app.{ser::Angel::eagerParseRequestBodies}.{core::Object::==}(true)) {
        return ctx.{req::RequestContext::parse}().{asy::Future::then}<htt::HttpRequestContext>((bod::BodyParseResult _) → htt::HttpRequestContext => ctx);
      }
      return asy::Future::value<htt::HttpRequestContext>(ctx);
    }
    @core::override
    method close() → asy::Future<dynamic> {
      this.{htt::HttpRequestContext::_contentType} = null;
      this.{htt::HttpRequestContext::_io} = null;
      this.{htt::HttpRequestContext::_override} = this.{htt::HttpRequestContext::_path} = null;
      return super.{req::RequestContext::close}();
    }
    @core::override
    method parseOnce() → asy::Future<bod::BodyParseResult> {
      return par::parseBodyFromStream(this.{htt::HttpRequestContext::rawRequest}, !this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::contentType}.{core::Object::==}(null) ?{med::MediaType} med::MediaType::parse(this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::contentType}.{core::Object::toString}()) : null, this.{htt::HttpRequestContext::rawRequest}.{_ht::HttpRequest::uri}, storeOriginalBuffer: this.{req::RequestContext::app}.{ser::Angel::keepRawRequestBuffers}.{core::Object::==}(true));
    }
  }
}
library from "package:angel_framework/src/http/http_response_context.dart" as htt2 {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:angel_framework/src/core/core.dart";
  import "package:angel_framework/src/http/http_request_context.dart";
  class HttpResponseContext extends res::ResponseContext<_ht::HttpResponse> {
    @core::override
    final field _ht::HttpResponse rawResponse;
    field ser::Angel app;
    field res::LockableBytesBuilder _buffer = null;
    final field htt::HttpRequestContext _correspondingRequest;
    field core::bool _isDetached = false;
    field core::bool _isClosed = false;
    field core::bool _streamInitialized = false;
    field core::Iterable<core::String> __allowedEncodings = null;
    constructor •(_ht::HttpResponse rawResponse, ser::Angel app, [htt::HttpRequestContext _correspondingRequest = null]) → void
      : htt2::HttpResponseContext::rawResponse = rawResponse, htt2::HttpResponseContext::app = app, htt2::HttpResponseContext::_correspondingRequest = _correspondingRequest, super res::ResponseContext::•()
      ;
    @core::override
    method detach() → _ht::HttpResponse {
      this.{htt2::HttpResponseContext::_isDetached} = true;
      return this.{htt2::HttpResponseContext::rawResponse};
    }
    @core::override
    get correspondingRequest() → req::RequestContext<dynamic> {
      return this.{htt2::HttpResponseContext::_correspondingRequest};
    }
    @core::override
    get isOpen() → core::bool {
      return !this.{htt2::HttpResponseContext::_isClosed} && !this.{htt2::HttpResponseContext::_isDetached};
    }
    @core::override
    get isBuffered() → core::bool
      return !this.{htt2::HttpResponseContext::_buffer}.{core::Object::==}(null);
    @core::override
    get buffer() → io::BytesBuilder
      return this.{htt2::HttpResponseContext::_buffer};
    @core::override
    method addError(core::Object error, [core::StackTrace stackTrace = null]) → void {
      this.{htt2::HttpResponseContext::rawResponse}.{io::IOSink::addError}(error, stackTrace);
      super.{res::ResponseContext::addError}(error, stackTrace);
    }
    @core::override
    method useBuffer() → void {
      this.{htt2::HttpResponseContext::_buffer} = res::LockableBytesBuilder::•();
    }
    get _allowedEncodings() → core::Iterable<core::String> {
      return let final core::Iterable<core::String> #t215 = this.{htt2::HttpResponseContext::__allowedEncodings} in #t215.{core::Object::==}(null) ?{core::Iterable<core::String>} this.{htt2::HttpResponseContext::__allowedEncodings} = let final core::Iterable<core::String> #t216 = let final core::Iterable<core::String> #t217 = let final core::List<core::String> #t218 = let final core::String #t219 = this.{htt2::HttpResponseContext::correspondingRequest}.{req::RequestContext::headers}.{_ht::HttpHeaders::value}("accept-encoding") in #t219.==(null) ?{core::List<core::String>} null : #t219.{core::String::split}(",") in #t218.==(null) ?{core::Iterable<core::String>} null : #t218.{core::Iterable::map}<core::String>((core::String s) → core::String => s.{core::String::trim}()) in #t217.==(null) ?{core::Iterable<core::String>} null : #t217.{core::Iterable::where}((core::String s) → core::bool => s.{core::String::isNotEmpty}) in #t216.==(null) ?{core::Iterable<core::String>} null : #t216.{core::Iterable::map}<core::String>((core::String str) → core::String {
        if(!str.{core::String::contains}(";"))
          return str;
        return str.{core::String::split}(";").{core::List::[]}(0);
      }) : #t215;
    }
    method _openStream() → core::bool {
      if(!this.{htt2::HttpResponseContext::_streamInitialized}) {
        let final _ht::HttpResponse #t220 = this.{htt2::HttpResponseContext::rawResponse} in let final dynamic #t221 = #t220.{_ht::HttpResponse::statusCode} = this.{res::ResponseContext::statusCode} in let final dynamic #t222 = #t220.{_ht::HttpResponse::cookies}.{core::List::addAll}(this.{res::ResponseContext::cookies}) in #t220;
        this.{res::ResponseContext::headers}.{core::Map::forEach}(this.{htt2::HttpResponseContext::rawResponse}.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set});
        this.{htt2::HttpResponseContext::rawResponse}.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::contentType} = _ht::ContentType::•(this.{res::ResponseContext::contentType}.{med::MediaType::type}, this.{res::ResponseContext::contentType}.{med::MediaType::subtype}, charset: this.{res::ResponseContext::contentType}.{med::MediaType::parameters}.{core::Map::[]}("charset"), parameters: this.{res::ResponseContext::contentType}.{med::MediaType::parameters});
        if(this.{res::ResponseContext::encoders}.{core::Map::isNotEmpty} && !this.{htt2::HttpResponseContext::correspondingRequest}.{core::Object::==}(null)) {
          if(!this.{htt2::HttpResponseContext::_allowedEncodings}.{core::Object::==}(null)) {
            #L26:
            for (core::String encodingName in this.{htt2::HttpResponseContext::_allowedEncodings}) {
              con2::Converter<core::List<core::int>, core::List<core::int>> encoder;
              core::String key = encodingName;
              if(this.{res::ResponseContext::encoders}.{core::Map::containsKey}(encodingName))
                encoder = this.{res::ResponseContext::encoders}.{core::Map::[]}(encodingName);
              else
                if(encodingName.{core::String::==}("*")) {
                  encoder = this.{res::ResponseContext::encoders}.{core::Map::[]}(key = this.{res::ResponseContext::encoders}.{core::Map::keys}.{core::Iterable::first});
                }
              if(!encoder.{core::Object::==}(null)) {
                this.{htt2::HttpResponseContext::rawResponse}.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}("content-encoding", key);
                break #L26;
              }
            }
          }
        }
        return this.{htt2::HttpResponseContext::_streamInitialized} = true;
      }
      return false;
    }
    @core::override
    method addStream(generic-covariant-impl asy::Stream<core::List<core::int>> stream) → asy::Future<dynamic> {
      if(this.{htt2::HttpResponseContext::_isClosed} && this.{htt2::HttpResponseContext::isBuffered})
        throw res::ResponseContext::closed();
      this.{htt2::HttpResponseContext::_openStream}();
      asy::Stream<core::List<core::int>> output = stream;
      if(this.{res::ResponseContext::encoders}.{core::Map::isNotEmpty} && !this.{htt2::HttpResponseContext::correspondingRequest}.{core::Object::==}(null)) {
        if(!this.{htt2::HttpResponseContext::_allowedEncodings}.{core::Object::==}(null)) {
          #L27:
          for (core::String encodingName in this.{htt2::HttpResponseContext::_allowedEncodings}) {
            con2::Converter<core::List<core::int>, core::List<core::int>> encoder;
            core::String key = encodingName;
            if(this.{res::ResponseContext::encoders}.{core::Map::containsKey}(encodingName))
              encoder = this.{res::ResponseContext::encoders}.{core::Map::[]}(encodingName);
            else
              if(encodingName.{core::String::==}("*")) {
                encoder = this.{res::ResponseContext::encoders}.{core::Map::[]}(key = this.{res::ResponseContext::encoders}.{core::Map::keys}.{core::Iterable::first});
              }
            if(!encoder.{core::Object::==}(null)) {
              output = this.{res::ResponseContext::encoders}.{core::Map::[]}(key).{con2::Converter::bind}(output);
              break #L27;
            }
          }
        }
      }
      return this.{htt2::HttpResponseContext::rawResponse}.{io::IOSink::addStream}(output);
    }
    @core::override
    method add(generic-covariant-impl core::List<core::int> data) → void {
      if(this.{htt2::HttpResponseContext::_isClosed} && this.{htt2::HttpResponseContext::isBuffered})
        throw res::ResponseContext::closed();
      else
        if(!this.{htt2::HttpResponseContext::isBuffered}) {
          this.{htt2::HttpResponseContext::_openStream}();
          if(this.{res::ResponseContext::encoders}.{core::Map::isNotEmpty} && !this.{htt2::HttpResponseContext::correspondingRequest}.{core::Object::==}(null)) {
            if(!this.{htt2::HttpResponseContext::_allowedEncodings}.{core::Object::==}(null)) {
              #L28:
              for (core::String encodingName in this.{htt2::HttpResponseContext::_allowedEncodings}) {
                con2::Converter<core::List<core::int>, core::List<core::int>> encoder;
                core::String key = encodingName;
                if(this.{res::ResponseContext::encoders}.{core::Map::containsKey}(encodingName))
                  encoder = this.{res::ResponseContext::encoders}.{core::Map::[]}(encodingName);
                else
                  if(encodingName.{core::String::==}("*")) {
                    encoder = this.{res::ResponseContext::encoders}.{core::Map::[]}(key = this.{res::ResponseContext::encoders}.{core::Map::keys}.{core::Iterable::first});
                  }
                if(!encoder.{core::Object::==}(null)) {
                  data = this.{res::ResponseContext::encoders}.{core::Map::[]}(key).{con2::Converter::convert}(data);
                  break #L28;
                }
              }
            }
          }
          this.{htt2::HttpResponseContext::rawResponse}.{io::IOSink::add}(data);
        }
        else
          this.{htt2::HttpResponseContext::buffer}.{io::BytesBuilder::add}(data);
    }
    @core::override
    method close() → asy::Future<dynamic> {
      if(!this.{htt2::HttpResponseContext::_isDetached}) {
        if(!this.{htt2::HttpResponseContext::_isClosed}) {
          if(!this.{htt2::HttpResponseContext::isBuffered}) {
            try {
              this.{htt2::HttpResponseContext::rawResponse}.{io::IOSink::close}();
            }
            on dynamic catch(final dynamic _) {
            }
          }
          else {
            this.{htt2::HttpResponseContext::_buffer}.{res::LockableBytesBuilder::lock}();
          }
          this.{htt2::HttpResponseContext::_isClosed} = true;
        }
        super.{res::ResponseContext::close}();
      }
      return asy::Future::value<dynamic>();
    }
  }
}
library from "package:args/args.dart" as args {
  export "package:args/src/arg_parser.dart";
  export "package:args/src/arg_parser_exception.dart";
  export "package:args/src/arg_results.dart";
  export "package:args/src/option.dart";
}
library angel_container from "package:angel_container/angel_container.dart" as ang7 {
  export "package:angel_container/src/container.dart";
  export "package:angel_container/src/empty/empty.dart";
  export "package:angel_container/src/exception.dart";
  export "package:angel_container/src/reflector.dart";
  class GenerateReflector extends core::Object {
    final field core::List<core::Type> types;
    final field core::List<core::Function> functions;
    final field core::List<core::Symbol> symbols;
    final field core::String name;
    const constructor •({core::List<core::Type> types = const <core::Type>[], core::List<core::Function> functions = const <core::Function>[], core::List<core::Symbol> symbols = const <core::Symbol>[], core::String name = null}) → void
      : ang7::GenerateReflector::types = types, ang7::GenerateReflector::functions = functions, ang7::GenerateReflector::symbols = symbols, ang7::GenerateReflector::name = name, super core::Object::•()
      ;
  }
}
library from "package:io/ansi.dart" as ansi {
  export "package:io/src/ansi_code.dart";
}
library from "package:io/io.dart" as io2 {
  export "package:io/src/copy_path.dart";
  export "package:io/src/exit_code.dart";
  export "package:io/src/permissions.dart";
  export "package:io/src/process_manager.dart";
  export "package:io/src/shared_stdin.dart";
  export "package:io/src/shell_words.dart";
}
library logging from "package:logging/logging.dart" as log {
  import "dart:async";
  import "dart:collection";
  typedef LoggerHandler = (log::LogRecord) → void;
  class Logger extends core::Object {
    final field core::String name;
    final field log::Logger parent;
    field log::Level _level = null;
    final field core::Map<core::String, log::Logger> _children;
    final field core::Map<core::String, log::Logger> children;
    field asy::StreamController<log::LogRecord> _controller = null;
    static final field log::Logger root = log::Logger::•("");
    static final field core::Map<core::String, log::Logger> _loggers = <core::String, log::Logger>{};
    constructor _internal(core::String name, log::Logger parent, core::Map<core::String, log::Logger> children) → void
      : log::Logger::name = name, log::Logger::parent = parent, log::Logger::_children = children, log::Logger::children = new col::UnmodifiableMapView::•<core::String, log::Logger>(children), super core::Object::•() {
      if(!this.{log::Logger::parent}.{core::Object::==}(null))
        this.{log::Logger::parent}.{log::Logger::_children}.{core::Map::[]=}(this.{log::Logger::name}, this);
    }
    get fullName() → core::String
      return this.{log::Logger::parent}.{core::Object::==}(null) || this.{log::Logger::parent}.{log::Logger::name}.{core::String::==}("") ?{core::String} this.{log::Logger::name} : "${this.{log::Logger::parent}.{log::Logger::fullName}}.${this.{log::Logger::name}}";
    static factory •(core::String name) → log::Logger {
      return log::Logger::_loggers.{core::Map::putIfAbsent}(name, () → log::Logger => log::Logger::_named(name));
    }
    static factory detached(core::String name) → log::Logger {
      return new log::Logger::_internal(name, null, new _js::LinkedMap::•<core::String, log::Logger>());
    }
    static factory _named(core::String name) → log::Logger {
      if(name.{core::String::startsWith}(".")) {
        throw new core::ArgumentError::•("name shouldn't start with a '.'");
      }
      core::int dot = name.{core::String::lastIndexOf}(".");
      log::Logger parent;
      core::String thisName;
      if(dot.{core::num::==}(1.{core::int::unary-}())) {
        if(!name.{core::String::==}(""))
          parent = log::Logger::•("");
        thisName = name;
      }
      else {
        parent = log::Logger::•(name.{core::String::substring}(0, dot));
        thisName = name.{core::String::substring}(dot.{core::num::+}(1));
      }
      return new log::Logger::_internal(thisName, parent, new _js::LinkedMap::•<core::String, log::Logger>());
    }
    get level() → log::Level {
      if(log::hierarchicalLoggingEnabled) {
        if(!this.{log::Logger::_level}.{log::Level::==}(null))
          return this.{log::Logger::_level};
        if(!this.{log::Logger::parent}.{core::Object::==}(null))
          return this.{log::Logger::parent}.{log::Logger::level};
      }
      return log::_rootLevel;
    }
    set level(log::Level value) → void {
      if(log::hierarchicalLoggingEnabled && !this.{log::Logger::parent}.{core::Object::==}(null)) {
        this.{log::Logger::_level} = value;
      }
      else {
        if(!this.{log::Logger::parent}.{core::Object::==}(null)) {
          throw new core::UnsupportedError::•("Please set \"hierarchicalLoggingEnabled\" to true if you want to change the level on a non-root logger.");
        }
        log::_rootLevel = value;
      }
    }
    get onRecord() → asy::Stream<log::LogRecord>
      return this.{log::Logger::_getStream}();
    method clearListeners() → void {
      if(log::hierarchicalLoggingEnabled || this.{log::Logger::parent}.{core::Object::==}(null)) {
        if(!this.{log::Logger::_controller}.{core::Object::==}(null)) {
          this.{log::Logger::_controller}.{asy::StreamController::close}();
          this.{log::Logger::_controller} = null;
        }
      }
      else {
        log::Logger::root.{log::Logger::clearListeners}();
      }
    }
    method isLoggable(log::Level value) → core::bool
      return value.{log::Level::>=}(this.{log::Logger::level});
    method log(log::Level logLevel, dynamic message, [core::Object error = null, core::StackTrace stackTrace = null, asy::Zone zone = null]) → void {
      core::Object object;
      if(this.{log::Logger::isLoggable}(logLevel)) {
        if(message is core::Function) {
          message = message.call();
        }
        core::String msg;
        if(message is core::String) {
          msg = message{core::String};
        }
        else {
          msg = message.{core::Object::toString}();
          object = message;
        }
        if(stackTrace.{core::Object::==}(null) && logLevel.{log::Level::>=}(log::recordStackTraceAtLevel)) {
          stackTrace = core::StackTrace::current;
          error.{core::Object::==}(null) ?{core::Object} error = "autogenerated stack trace for ${logLevel} ${msg}" : null;
        }
        if(zone.{core::Object::==}(null))
          zone = asy::Zone::current;
        log::LogRecord record = new log::LogRecord::•(logLevel, msg, this.{log::Logger::fullName}, error, stackTrace, zone, object);
        if(log::hierarchicalLoggingEnabled) {
          log::Logger target = this;
          while (!target.{core::Object::==}(null)) {
            target.{log::Logger::_publish}(record);
            target = target.{log::Logger::parent};
          }
        }
        else {
          log::Logger::root.{log::Logger::_publish}(record);
        }
      }
    }
    method finest(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::FINEST, message, error, stackTrace);
    method finer(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::FINER, message, error, stackTrace);
    method fine(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::FINE, message, error, stackTrace);
    method config(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::CONFIG, message, error, stackTrace);
    method info(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::INFO, message, error, stackTrace);
    method warning(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::WARNING, message, error, stackTrace);
    method severe(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::SEVERE, message, error, stackTrace);
    method shout(dynamic message, [core::Object error = null, core::StackTrace stackTrace = null]) → void
      return this.{log::Logger::log}(log::Level::SHOUT, message, error, stackTrace);
    method _getStream() → asy::Stream<log::LogRecord> {
      if(log::hierarchicalLoggingEnabled || this.{log::Logger::parent}.{core::Object::==}(null)) {
        if(this.{log::Logger::_controller}.{core::Object::==}(null)) {
          this.{log::Logger::_controller} = asy::StreamController::broadcast<log::LogRecord>(sync: true);
        }
        return this.{log::Logger::_controller}.{asy::StreamController::stream};
      }
      else {
        return log::Logger::root.{log::Logger::_getStream}();
      }
    }
    method _publish(log::LogRecord record) → void {
      if(!this.{log::Logger::_controller}.{core::Object::==}(null)) {
        this.{log::Logger::_controller}.{asy::StreamController::add}(record);
      }
    }
  }
  class Level extends core::Object implements core::Comparable<log::Level> {
    final field core::String name;
    final field core::int value;
    static const field log::Level ALL = const log::Level::•("ALL", 0);
    static const field log::Level OFF = const log::Level::•("OFF", 2000);
    static const field log::Level FINEST = const log::Level::•("FINEST", 300);
    static const field log::Level FINER = const log::Level::•("FINER", 400);
    static const field log::Level FINE = const log::Level::•("FINE", 500);
    static const field log::Level CONFIG = const log::Level::•("CONFIG", 700);
    static const field log::Level INFO = const log::Level::•("INFO", 800);
    static const field log::Level WARNING = const log::Level::•("WARNING", 900);
    static const field log::Level SEVERE = const log::Level::•("SEVERE", 1000);
    static const field log::Level SHOUT = const log::Level::•("SHOUT", 1200);
    static const field core::List<log::Level> LEVELS = const <log::Level>[log::Level::ALL, log::Level::FINEST, log::Level::FINER, log::Level::FINE, log::Level::CONFIG, log::Level::INFO, log::Level::WARNING, log::Level::SEVERE, log::Level::SHOUT, log::Level::OFF];
    const constructor •(core::String name, core::int value) → void
      : log::Level::name = name, log::Level::value = value, super core::Object::•()
      ;
    @core::override
    operator ==(core::Object other) → core::bool
      return other is log::Level && this.{log::Level::value}.{core::num::==}(other{log::Level}.{log::Level::value});
    operator <(log::Level other) → core::bool
      return this.{log::Level::value}.{core::num::<}(other.{log::Level::value});
    operator <=(log::Level other) → core::bool
      return this.{log::Level::value}.{core::num::<=}(other.{log::Level::value});
    operator >(log::Level other) → core::bool
      return this.{log::Level::value}.{core::num::>}(other.{log::Level::value});
    operator >=(log::Level other) → core::bool
      return this.{log::Level::value}.{core::num::>=}(other.{log::Level::value});
    @core::override
    method compareTo(generic-covariant-impl log::Level other) → core::int
      return this.{log::Level::value}.{core::num::-}(other.{log::Level::value});
    @core::override
    get hashCode() → core::int
      return this.{log::Level::value};
    @core::override
    method toString() → core::String
      return this.{log::Level::name};
  }
  class LogRecord extends core::Object {
    final field log::Level level;
    final field core::String message;
    final field core::Object object;
    final field core::String loggerName;
    final field core::DateTime time;
    final field core::int sequenceNumber;
    static field core::int _nextNumber = 0;
    final field core::Object error;
    final field core::StackTrace stackTrace;
    final field asy::Zone zone;
    constructor •(log::Level level, core::String message, core::String loggerName, [core::Object error = null, core::StackTrace stackTrace = null, asy::Zone zone = null, core::Object object = null]) → void
      : log::LogRecord::level = level, log::LogRecord::message = message, log::LogRecord::loggerName = loggerName, log::LogRecord::error = error, log::LogRecord::stackTrace = stackTrace, log::LogRecord::zone = zone, log::LogRecord::object = object, log::LogRecord::time = new core::DateTime::now(), log::LogRecord::sequenceNumber = let final core::int #t223 = log::LogRecord::_nextNumber in let final core::int #t224 = log::LogRecord::_nextNumber = #t223.{core::num::+}(1) in #t223, super core::Object::•()
      ;
    @core::override
    method toString() → core::String
      return "[${this.{log::LogRecord::level}.{log::Level::name}}] ${this.{log::LogRecord::loggerName}}: ${this.{log::LogRecord::message}}";
  }
  static field core::bool hierarchicalLoggingEnabled = false;
  static field log::Level recordStackTraceAtLevel = log::Level::OFF;
  static field log::Level _rootLevel = log::Level::INFO;
}
library from "package:pub_sub/isolate.dart" as iso2 {
  export "package:pub_sub/src/isolate/client.dart";
  export "package:pub_sub/src/isolate/server.dart";
}
library from "package:pub_sub/src/protocol/client/sync_client.dart" as syn {
  export "package:pub_sub/src/protocol/client/client.dart";
}
library from "package:pub_sub/src/protocol/server/sync_server.dart" as syn2 {
  export "package:pub_sub/src/protocol/server/adapter.dart";
  export "package:pub_sub/src/protocol/server/client.dart";
  export "package:pub_sub/src/protocol/server/publish.dart";
  export "package:pub_sub/src/protocol/server/server.dart";
  export "package:pub_sub/src/protocol/server/subscription.dart";
}
library from "package:angel_framework/src/util.dart" as util {
  import "package:angel_container/angel_container.dart";
  static final field core::RegExp straySlashes = core::RegExp::•("(^/+)|(/+\$)");
  static method matchingAnnotation(core::List<ref::ReflectedInstance> metadata, core::Type T) → dynamic {
    for (ref::ReflectedInstance metaDatum in metadata) {
      if(metaDatum.{ref::ReflectedInstance::type}.{ref::ReflectedType::reflectedType}.{core::Object::==}(T)) {
        return metaDatum.{ref::ReflectedInstance::reflectee};
      }
    }
    return null;
  }
  static method getAnnotation(dynamic obj, core::Type T, ref::Reflector reflector) → dynamic {
    if(reflector.{core::Object::==}(null)) {
      return null;
    }
    else {
      if(obj is core::Function) {
        ref::ReflectedFunction methodMirror = reflector.{ref::Reflector::reflectFunction}(obj{core::Function});
        return util::matchingAnnotation(methodMirror.{ref::ReflectedFunction::annotations}, T);
      }
      else {
        ref::ReflectedClass classMirror = reflector.{ref::Reflector::reflectClass}(obj.{core::Object::runtimeType} as core::Type);
        return util::matchingAnnotation(classMirror.{ref::ReflectedClass::annotations}, T);
      }
    }
  }
}
library from "package:http_parser/http_parser.dart" as htt3 {
  export "package:http_parser/src/authentication_challenge.dart";
  export "package:http_parser/src/case_insensitive_map.dart";
  export "package:http_parser/src/chunked_coding.dart";
  export "package:http_parser/src/http_date.dart";
  export "package:http_parser/src/media_type.dart";
}
library meta from "package:meta/meta.dart" as meta {
  class Immutable extends core::Object {
    final field core::String reason;
    const constructor •([core::String reason = null]) → void
      : meta::Immutable::reason = reason, super core::Object::•()
      ;
  }
  class Required extends core::Object {
    final field core::String reason;
    const constructor •([core::String reason = null]) → void
      : meta::Required::reason = reason, super core::Object::•()
      ;
  }
  class _AlwaysThrows extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _Checked extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _Experimental extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _Factory extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _IsTest extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _IsTestGroup extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _Literal extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _MustCallSuper extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _OptionalTypeArgs extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _Protected extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _Virtual extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _VisibleForOverriding extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _VisibleForTesting extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  static const field meta::_AlwaysThrows alwaysThrows = const meta::_AlwaysThrows::•();
  @core::deprecated
  static const field meta::_Checked checked = const meta::_Checked::•();
  static const field meta::_Experimental experimental = const meta::_Experimental::•();
  static const field meta::_Factory factory = const meta::_Factory::•();
  static const field meta::Immutable immutable = const meta::Immutable::•();
  static const field meta::_IsTest isTest = const meta::_IsTest::•();
  static const field meta::_IsTestGroup isTestGroup = const meta::_IsTestGroup::•();
  static const field meta::_Literal literal = const meta::_Literal::•();
  static const field meta::_MustCallSuper mustCallSuper = const meta::_MustCallSuper::•();
  static const field meta::_OptionalTypeArgs optionalTypeArgs = const meta::_OptionalTypeArgs::•();
  static const field meta::_Protected protected = const meta::_Protected::•();
  static const field meta::Required required = const meta::Required::•();
  static const field meta::_Virtual virtual = const meta::_Virtual::•();
  static const field meta::_VisibleForOverriding visibleForOverriding = const meta::_VisibleForOverriding::•();
  static const field meta::_VisibleForTesting visibleForTesting = const meta::_VisibleForTesting::•();
}
library from "package:path/path.dart" as path {
  import "package:path/src/context.dart";
  import "package:path/src/style.dart";
  export "package:path/src/context.dart";
  export "package:path/src/path_exception.dart";
  export "package:path/src/path_map.dart";
  export "package:path/src/path_set.dart";
  export "package:path/src/style.dart";
  static final field con5::Context posix = con5::Context::•(style: sty::Style::posix);
  static final field con5::Context windows = con5::Context::•(style: sty::Style::windows);
  static final field con5::Context url = con5::Context::•(style: sty::Style::url);
  static final field con5::Context context = con5::createInternal();
  static field core::Uri _currentUriBase;
  static field core::String _current;
  static get style() → sty::Style
    return path::context.{con5::Context::style};
  static get current() → core::String {
    core::Uri uri = core::Uri::base;
    if(uri.{core::Uri::==}(path::_currentUriBase))
      return path::_current;
    path::_currentUriBase = uri;
    if(sty::Style::platform.{core::Object::==}(sty::Style::url)) {
      path::_current = uri.{core::Uri::resolve}(".").{core::Uri::toString}();
      return path::_current;
    }
    else {
      core::String path = uri.{core::Uri::toFilePath}();
      core::int lastIndex = path.{core::String::length}.{core::num::-}(1);
      assert(path.{core::String::[]}(lastIndex).{core::String::==}("/") || path.{core::String::[]}(lastIndex).{core::String::==}("\\"));
      path::_current = lastIndex.{core::num::==}(0) ?{core::String} path : path.{core::String::substring}(0, lastIndex);
      return path::_current;
    }
  }
  static get separator() → core::String
    return path::context.{con5::Context::separator};
  static method absolute(core::String part1, [core::String part2 = null, core::String part3 = null, core::String part4 = null, core::String part5 = null, core::String part6 = null, core::String part7 = null]) → core::String
    return path::context.{con5::Context::absolute}(part1, part2, part3, part4, part5, part6, part7);
  static method basename(core::String path) → core::String
    return path::context.{con5::Context::basename}(path);
  static method basenameWithoutExtension(core::String path) → core::String
    return path::context.{con5::Context::basenameWithoutExtension}(path);
  static method dirname(core::String path) → core::String
    return path::context.{con5::Context::dirname}(path);
  static method extension(core::String path) → core::String
    return path::context.{con5::Context::extension}(path);
  static method rootPrefix(core::String path) → core::String
    return path::context.{con5::Context::rootPrefix}(path);
  static method isAbsolute(core::String path) → core::bool
    return path::context.{con5::Context::isAbsolute}(path);
  static method isRelative(core::String path) → core::bool
    return path::context.{con5::Context::isRelative}(path);
  static method isRootRelative(core::String path) → core::bool
    return path::context.{con5::Context::isRootRelative}(path);
  static method join(core::String part1, [core::String part2 = null, core::String part3 = null, core::String part4 = null, core::String part5 = null, core::String part6 = null, core::String part7 = null, core::String part8 = null]) → core::String
    return path::context.{con5::Context::join}(part1, part2, part3, part4, part5, part6, part7, part8);
  static method joinAll(core::Iterable<core::String> parts) → core::String
    return path::context.{con5::Context::joinAll}(parts);
  static method split(core::String path) → core::List<core::String>
    return path::context.{con5::Context::split}(path);
  static method canonicalize(core::String path) → core::String
    return path::context.{con5::Context::canonicalize}(path);
  static method normalize(core::String path) → core::String
    return path::context.{con5::Context::normalize}(path);
  static method relative(core::String path, {core::String from = null}) → core::String
    return path::context.{con5::Context::relative}(path, from: from);
  static method isWithin(core::String parent, core::String child) → core::bool
    return path::context.{con5::Context::isWithin}(parent, child);
  static method equals(core::String path1, core::String path2) → core::bool
    return path::context.{con5::Context::equals}(path1, path2);
  static method hash(core::String path) → core::int
    return path::context.{con5::Context::hash}(path);
  static method withoutExtension(core::String path) → core::String
    return path::context.{con5::Context::withoutExtension}(path);
  static method setExtension(core::String path, core::String extension) → core::String
    return path::context.{con5::Context::setExtension}(path, extension);
  static method fromUri(dynamic uri) → core::String
    return path::context.{con5::Context::fromUri}(uri);
  static method toUri(core::String path) → core::Uri
    return path::context.{con5::Context::toUri}(path);
  static method prettyUri(dynamic uri) → core::String
    return path::context.{con5::Context::prettyUri}(uri);
}
library from "package:file/file.dart" as file2 {
  export "package:file/src/forwarding.dart";
  export "package:file/src/interface.dart";
}
library mime from "package:mime/mime.dart" as mime {
  export "package:mime/src/mime_multipart_transformer.dart";
  export "package:mime/src/mime_shared.dart";
  export "package:mime/src/mime_type.dart";
}
library from "package:combinator/combinator.dart" as com2 {
  export "package:combinator/src/combinator/combinator.dart";
  export "package:combinator/src/error.dart";
}
library tuple from "package:tuple/tuple.dart" as tup {
  import "package:quiver/core.dart";
  class Tuple2<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/tuple-1.0.2/lib/src/tuple.dart
    final field tup::Tuple2::T1 item1;
    final field tup::Tuple2::T2 item2;
    const constructor •(tup::Tuple2::T1 item1, tup::Tuple2::T2 item2) → void
      : tup::Tuple2::item1 = item1, tup::Tuple2::item2 = item2, super core::Object::•()
      ;
    static factory fromList<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic>(core::List<dynamic> items) → tup::Tuple2<tup::Tuple2::fromList::T1, tup::Tuple2::fromList::T2> {
      if(!items.{core::List::length}.{core::num::==}(2)) {
        throw new core::ArgumentError::•("items must have length 2");
      }
      return new tup::Tuple2::•<tup::Tuple2::fromList::T1, tup::Tuple2::fromList::T2>(items.{core::List::[]}(0) as tup::Tuple2::fromList::T1, items.{core::List::[]}(1) as tup::Tuple2::fromList::T2);
    }
    method withItem1(generic-covariant-impl tup::Tuple2::T1 v) → tup::Tuple2<tup::Tuple2::T1, tup::Tuple2::T2> {
      return new tup::Tuple2::•<tup::Tuple2::T1, tup::Tuple2::T2>(v, this.{tup::Tuple2::item2});
    }
    method withItem2(generic-covariant-impl tup::Tuple2::T2 v) → tup::Tuple2<tup::Tuple2::T1, tup::Tuple2::T2> {
      return new tup::Tuple2::•<tup::Tuple2::T1, tup::Tuple2::T2>(this.{tup::Tuple2::item1}, v);
    }
    method toList({core::bool growable = false}) → core::List<dynamic>
      return core::List::from<dynamic>(<dynamic>[this.{tup::Tuple2::item1}, this.{tup::Tuple2::item2}], growable: growable);
    @core::override
    method toString() → core::String
      return "[${this.{tup::Tuple2::item1}}, ${this.{tup::Tuple2::item2}}]";
    @core::override
    operator ==(dynamic o) → core::bool
      return o is tup::Tuple2<dynamic, dynamic> && o{tup::Tuple2<dynamic, dynamic>}.{tup::Tuple2::item1}.{core::Object::==}(this.{tup::Tuple2::item1}) && o{tup::Tuple2<dynamic, dynamic>}.{tup::Tuple2::item2}.{core::Object::==}(this.{tup::Tuple2::item2});
    @core::override
    get hashCode() → core::int
      return core3::hash2(this.{tup::Tuple2::item1}.{core::Object::hashCode}, this.{tup::Tuple2::item2}.{core::Object::hashCode});
  }
  class Tuple3<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/tuple-1.0.2/lib/src/tuple.dart
    final field tup::Tuple3::T1 item1;
    final field tup::Tuple3::T2 item2;
    final field tup::Tuple3::T3 item3;
    const constructor •(tup::Tuple3::T1 item1, tup::Tuple3::T2 item2, tup::Tuple3::T3 item3) → void
      : tup::Tuple3::item1 = item1, tup::Tuple3::item2 = item2, tup::Tuple3::item3 = item3, super core::Object::•()
      ;
    static factory fromList<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic>(core::List<dynamic> items) → tup::Tuple3<tup::Tuple3::fromList::T1, tup::Tuple3::fromList::T2, tup::Tuple3::fromList::T3> {
      if(!items.{core::List::length}.{core::num::==}(3)) {
        throw new core::ArgumentError::•("items must have length 3");
      }
      return new tup::Tuple3::•<tup::Tuple3::fromList::T1, tup::Tuple3::fromList::T2, tup::Tuple3::fromList::T3>(items.{core::List::[]}(0) as tup::Tuple3::fromList::T1, items.{core::List::[]}(1) as tup::Tuple3::fromList::T2, items.{core::List::[]}(2) as tup::Tuple3::fromList::T3);
    }
    method withItem1(generic-covariant-impl tup::Tuple3::T1 v) → tup::Tuple3<tup::Tuple3::T1, tup::Tuple3::T2, tup::Tuple3::T3> {
      return new tup::Tuple3::•<tup::Tuple3::T1, tup::Tuple3::T2, tup::Tuple3::T3>(v, this.{tup::Tuple3::item2}, this.{tup::Tuple3::item3});
    }
    method withItem2(generic-covariant-impl tup::Tuple3::T2 v) → tup::Tuple3<tup::Tuple3::T1, tup::Tuple3::T2, tup::Tuple3::T3> {
      return new tup::Tuple3::•<tup::Tuple3::T1, tup::Tuple3::T2, tup::Tuple3::T3>(this.{tup::Tuple3::item1}, v, this.{tup::Tuple3::item3});
    }
    method withItem3(generic-covariant-impl tup::Tuple3::T3 v) → tup::Tuple3<tup::Tuple3::T1, tup::Tuple3::T2, tup::Tuple3::T3> {
      return new tup::Tuple3::•<tup::Tuple3::T1, tup::Tuple3::T2, tup::Tuple3::T3>(this.{tup::Tuple3::item1}, this.{tup::Tuple3::item2}, v);
    }
    method toList({core::bool growable = false}) → core::List<dynamic>
      return core::List::from<dynamic>(<dynamic>[this.{tup::Tuple3::item1}, this.{tup::Tuple3::item2}, this.{tup::Tuple3::item3}], growable: growable);
    @core::override
    method toString() → core::String
      return "[${this.{tup::Tuple3::item1}}, ${this.{tup::Tuple3::item2}}, ${this.{tup::Tuple3::item3}}]";
    @core::override
    operator ==(dynamic o) → core::bool
      return o is tup::Tuple3<dynamic, dynamic, dynamic> && o{tup::Tuple3<dynamic, dynamic, dynamic>}.{tup::Tuple3::item1}.{core::Object::==}(this.{tup::Tuple3::item1}) && o{tup::Tuple3<dynamic, dynamic, dynamic>}.{tup::Tuple3::item2}.{core::Object::==}(this.{tup::Tuple3::item2}) && o{tup::Tuple3<dynamic, dynamic, dynamic>}.{tup::Tuple3::item3}.{core::Object::==}(this.{tup::Tuple3::item3});
    @core::override
    get hashCode() → core::int
      return core3::hash3(this.{tup::Tuple3::item1}.{core::Object::hashCode}, this.{tup::Tuple3::item2}.{core::Object::hashCode}, this.{tup::Tuple3::item3}.{core::Object::hashCode});
  }
  class Tuple4<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/tuple-1.0.2/lib/src/tuple.dart
    final field tup::Tuple4::T1 item1;
    final field tup::Tuple4::T2 item2;
    final field tup::Tuple4::T3 item3;
    final field tup::Tuple4::T4 item4;
    const constructor •(tup::Tuple4::T1 item1, tup::Tuple4::T2 item2, tup::Tuple4::T3 item3, tup::Tuple4::T4 item4) → void
      : tup::Tuple4::item1 = item1, tup::Tuple4::item2 = item2, tup::Tuple4::item3 = item3, tup::Tuple4::item4 = item4, super core::Object::•()
      ;
    static factory fromList<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic>(core::List<dynamic> items) → tup::Tuple4<tup::Tuple4::fromList::T1, tup::Tuple4::fromList::T2, tup::Tuple4::fromList::T3, tup::Tuple4::fromList::T4> {
      if(!items.{core::List::length}.{core::num::==}(4)) {
        throw new core::ArgumentError::•("items must have length 4");
      }
      return new tup::Tuple4::•<tup::Tuple4::fromList::T1, tup::Tuple4::fromList::T2, tup::Tuple4::fromList::T3, tup::Tuple4::fromList::T4>(items.{core::List::[]}(0) as tup::Tuple4::fromList::T1, items.{core::List::[]}(1) as tup::Tuple4::fromList::T2, items.{core::List::[]}(2) as tup::Tuple4::fromList::T3, items.{core::List::[]}(3) as tup::Tuple4::fromList::T4);
    }
    method withItem1(generic-covariant-impl tup::Tuple4::T1 v) → tup::Tuple4<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4> {
      return new tup::Tuple4::•<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4>(v, this.{tup::Tuple4::item2}, this.{tup::Tuple4::item3}, this.{tup::Tuple4::item4});
    }
    method withItem2(generic-covariant-impl tup::Tuple4::T2 v) → tup::Tuple4<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4> {
      return new tup::Tuple4::•<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4>(this.{tup::Tuple4::item1}, v, this.{tup::Tuple4::item3}, this.{tup::Tuple4::item4});
    }
    method withItem3(generic-covariant-impl tup::Tuple4::T3 v) → tup::Tuple4<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4> {
      return new tup::Tuple4::•<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4>(this.{tup::Tuple4::item1}, this.{tup::Tuple4::item2}, v, this.{tup::Tuple4::item4});
    }
    method withItem4(generic-covariant-impl tup::Tuple4::T4 v) → tup::Tuple4<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4> {
      return new tup::Tuple4::•<tup::Tuple4::T1, tup::Tuple4::T2, tup::Tuple4::T3, tup::Tuple4::T4>(this.{tup::Tuple4::item1}, this.{tup::Tuple4::item2}, this.{tup::Tuple4::item3}, v);
    }
    method toList({core::bool growable = false}) → core::List<dynamic>
      return core::List::from<dynamic>(<dynamic>[this.{tup::Tuple4::item1}, this.{tup::Tuple4::item2}, this.{tup::Tuple4::item3}, this.{tup::Tuple4::item4}], growable: growable);
    @core::override
    method toString() → core::String
      return "[${this.{tup::Tuple4::item1}}, ${this.{tup::Tuple4::item2}}, ${this.{tup::Tuple4::item3}}, ${this.{tup::Tuple4::item4}}]";
    @core::override
    operator ==(dynamic o) → core::bool
      return o is tup::Tuple4<dynamic, dynamic, dynamic, dynamic> && o{tup::Tuple4<dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple4::item1}.{core::Object::==}(this.{tup::Tuple4::item1}) && o{tup::Tuple4<dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple4::item2}.{core::Object::==}(this.{tup::Tuple4::item2}) && o{tup::Tuple4<dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple4::item3}.{core::Object::==}(this.{tup::Tuple4::item3}) && o{tup::Tuple4<dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple4::item4}.{core::Object::==}(this.{tup::Tuple4::item4});
    @core::override
    get hashCode() → core::int
      return core3::hash4(this.{tup::Tuple4::item1}.{core::Object::hashCode}, this.{tup::Tuple4::item2}.{core::Object::hashCode}, this.{tup::Tuple4::item3}.{core::Object::hashCode}, this.{tup::Tuple4::item4}.{core::Object::hashCode});
  }
  class Tuple5<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic, T5 extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/tuple-1.0.2/lib/src/tuple.dart
    final field tup::Tuple5::T1 item1;
    final field tup::Tuple5::T2 item2;
    final field tup::Tuple5::T3 item3;
    final field tup::Tuple5::T4 item4;
    final field tup::Tuple5::T5 item5;
    const constructor •(tup::Tuple5::T1 item1, tup::Tuple5::T2 item2, tup::Tuple5::T3 item3, tup::Tuple5::T4 item4, tup::Tuple5::T5 item5) → void
      : tup::Tuple5::item1 = item1, tup::Tuple5::item2 = item2, tup::Tuple5::item3 = item3, tup::Tuple5::item4 = item4, tup::Tuple5::item5 = item5, super core::Object::•()
      ;
    static factory fromList<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic, T5 extends core::Object = dynamic>(core::List<dynamic> items) → tup::Tuple5<tup::Tuple5::fromList::T1, tup::Tuple5::fromList::T2, tup::Tuple5::fromList::T3, tup::Tuple5::fromList::T4, tup::Tuple5::fromList::T5> {
      if(!items.{core::List::length}.{core::num::==}(5)) {
        throw new core::ArgumentError::•("items must have length 5");
      }
      return new tup::Tuple5::•<tup::Tuple5::fromList::T1, tup::Tuple5::fromList::T2, tup::Tuple5::fromList::T3, tup::Tuple5::fromList::T4, tup::Tuple5::fromList::T5>(items.{core::List::[]}(0) as tup::Tuple5::fromList::T1, items.{core::List::[]}(1) as tup::Tuple5::fromList::T2, items.{core::List::[]}(2) as tup::Tuple5::fromList::T3, items.{core::List::[]}(3) as tup::Tuple5::fromList::T4, items.{core::List::[]}(4) as tup::Tuple5::fromList::T5);
    }
    method withItem1(generic-covariant-impl tup::Tuple5::T1 v) → tup::Tuple5<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5> {
      return new tup::Tuple5::•<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5>(v, this.{tup::Tuple5::item2}, this.{tup::Tuple5::item3}, this.{tup::Tuple5::item4}, this.{tup::Tuple5::item5});
    }
    method withItem2(generic-covariant-impl tup::Tuple5::T2 v) → tup::Tuple5<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5> {
      return new tup::Tuple5::•<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5>(this.{tup::Tuple5::item1}, v, this.{tup::Tuple5::item3}, this.{tup::Tuple5::item4}, this.{tup::Tuple5::item5});
    }
    method withItem3(generic-covariant-impl tup::Tuple5::T3 v) → tup::Tuple5<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5> {
      return new tup::Tuple5::•<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5>(this.{tup::Tuple5::item1}, this.{tup::Tuple5::item2}, v, this.{tup::Tuple5::item4}, this.{tup::Tuple5::item5});
    }
    method withItem4(generic-covariant-impl tup::Tuple5::T4 v) → tup::Tuple5<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5> {
      return new tup::Tuple5::•<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5>(this.{tup::Tuple5::item1}, this.{tup::Tuple5::item2}, this.{tup::Tuple5::item3}, v, this.{tup::Tuple5::item5});
    }
    method withItem5(generic-covariant-impl tup::Tuple5::T5 v) → tup::Tuple5<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5> {
      return new tup::Tuple5::•<tup::Tuple5::T1, tup::Tuple5::T2, tup::Tuple5::T3, tup::Tuple5::T4, tup::Tuple5::T5>(this.{tup::Tuple5::item1}, this.{tup::Tuple5::item2}, this.{tup::Tuple5::item3}, this.{tup::Tuple5::item4}, v);
    }
    method toList({core::bool growable = false}) → core::List<dynamic>
      return core::List::from<dynamic>(<dynamic>[this.{tup::Tuple5::item1}, this.{tup::Tuple5::item2}, this.{tup::Tuple5::item3}, this.{tup::Tuple5::item4}, this.{tup::Tuple5::item5}], growable: growable);
    @core::override
    method toString() → core::String
      return "[${this.{tup::Tuple5::item1}}, ${this.{tup::Tuple5::item2}}, ${this.{tup::Tuple5::item3}}, ${this.{tup::Tuple5::item4}}, ${this.{tup::Tuple5::item5}}]";
    @core::override
    operator ==(dynamic o) → core::bool
      return o is tup::Tuple5<dynamic, dynamic, dynamic, dynamic, dynamic> && o{tup::Tuple5<dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple5::item1}.{core::Object::==}(this.{tup::Tuple5::item1}) && o{tup::Tuple5<dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple5::item2}.{core::Object::==}(this.{tup::Tuple5::item2}) && o{tup::Tuple5<dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple5::item3}.{core::Object::==}(this.{tup::Tuple5::item3}) && o{tup::Tuple5<dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple5::item4}.{core::Object::==}(this.{tup::Tuple5::item4}) && o{tup::Tuple5<dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple5::item5}.{core::Object::==}(this.{tup::Tuple5::item5});
    @core::override
    get hashCode() → core::int
      return core3::hashObjects(<dynamic>[this.{tup::Tuple5::item1}.{core::Object::hashCode}, this.{tup::Tuple5::item2}.{core::Object::hashCode}, this.{tup::Tuple5::item3}.{core::Object::hashCode}, this.{tup::Tuple5::item4}.{core::Object::hashCode}, this.{tup::Tuple5::item5}.{core::Object::hashCode}]);
  }
  class Tuple6<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic, T5 extends core::Object = dynamic, T6 extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/tuple-1.0.2/lib/src/tuple.dart
    final field tup::Tuple6::T1 item1;
    final field tup::Tuple6::T2 item2;
    final field tup::Tuple6::T3 item3;
    final field tup::Tuple6::T4 item4;
    final field tup::Tuple6::T5 item5;
    final field tup::Tuple6::T6 item6;
    const constructor •(tup::Tuple6::T1 item1, tup::Tuple6::T2 item2, tup::Tuple6::T3 item3, tup::Tuple6::T4 item4, tup::Tuple6::T5 item5, tup::Tuple6::T6 item6) → void
      : tup::Tuple6::item1 = item1, tup::Tuple6::item2 = item2, tup::Tuple6::item3 = item3, tup::Tuple6::item4 = item4, tup::Tuple6::item5 = item5, tup::Tuple6::item6 = item6, super core::Object::•()
      ;
    static factory fromList<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic, T5 extends core::Object = dynamic, T6 extends core::Object = dynamic>(core::List<dynamic> items) → tup::Tuple6<tup::Tuple6::fromList::T1, tup::Tuple6::fromList::T2, tup::Tuple6::fromList::T3, tup::Tuple6::fromList::T4, tup::Tuple6::fromList::T5, tup::Tuple6::fromList::T6> {
      if(!items.{core::List::length}.{core::num::==}(6)) {
        throw new core::ArgumentError::•("items must have length 6");
      }
      return new tup::Tuple6::•<tup::Tuple6::fromList::T1, tup::Tuple6::fromList::T2, tup::Tuple6::fromList::T3, tup::Tuple6::fromList::T4, tup::Tuple6::fromList::T5, tup::Tuple6::fromList::T6>(items.{core::List::[]}(0) as tup::Tuple6::fromList::T1, items.{core::List::[]}(1) as tup::Tuple6::fromList::T2, items.{core::List::[]}(2) as tup::Tuple6::fromList::T3, items.{core::List::[]}(3) as tup::Tuple6::fromList::T4, items.{core::List::[]}(4) as tup::Tuple6::fromList::T5, items.{core::List::[]}(5) as tup::Tuple6::fromList::T6);
    }
    method withItem1(generic-covariant-impl tup::Tuple6::T1 v) → tup::Tuple6<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6> {
      return new tup::Tuple6::•<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6>(v, this.{tup::Tuple6::item2}, this.{tup::Tuple6::item3}, this.{tup::Tuple6::item4}, this.{tup::Tuple6::item5}, this.{tup::Tuple6::item6});
    }
    method withItem2(generic-covariant-impl tup::Tuple6::T2 v) → tup::Tuple6<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6> {
      return new tup::Tuple6::•<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6>(this.{tup::Tuple6::item1}, v, this.{tup::Tuple6::item3}, this.{tup::Tuple6::item4}, this.{tup::Tuple6::item5}, this.{tup::Tuple6::item6});
    }
    method withItem3(generic-covariant-impl tup::Tuple6::T3 v) → tup::Tuple6<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6> {
      return new tup::Tuple6::•<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6>(this.{tup::Tuple6::item1}, this.{tup::Tuple6::item2}, v, this.{tup::Tuple6::item4}, this.{tup::Tuple6::item5}, this.{tup::Tuple6::item6});
    }
    method withItem4(generic-covariant-impl tup::Tuple6::T4 v) → tup::Tuple6<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6> {
      return new tup::Tuple6::•<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6>(this.{tup::Tuple6::item1}, this.{tup::Tuple6::item2}, this.{tup::Tuple6::item3}, v, this.{tup::Tuple6::item5}, this.{tup::Tuple6::item6});
    }
    method withItem5(generic-covariant-impl tup::Tuple6::T5 v) → tup::Tuple6<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6> {
      return new tup::Tuple6::•<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6>(this.{tup::Tuple6::item1}, this.{tup::Tuple6::item2}, this.{tup::Tuple6::item3}, this.{tup::Tuple6::item4}, v, this.{tup::Tuple6::item6});
    }
    method withItem6(generic-covariant-impl tup::Tuple6::T6 v) → tup::Tuple6<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6> {
      return new tup::Tuple6::•<tup::Tuple6::T1, tup::Tuple6::T2, tup::Tuple6::T3, tup::Tuple6::T4, tup::Tuple6::T5, tup::Tuple6::T6>(this.{tup::Tuple6::item1}, this.{tup::Tuple6::item2}, this.{tup::Tuple6::item3}, this.{tup::Tuple6::item4}, this.{tup::Tuple6::item5}, v);
    }
    method toList({core::bool growable = false}) → core::List<dynamic>
      return core::List::from<dynamic>(<dynamic>[this.{tup::Tuple6::item1}, this.{tup::Tuple6::item2}, this.{tup::Tuple6::item3}, this.{tup::Tuple6::item4}, this.{tup::Tuple6::item5}, this.{tup::Tuple6::item6}], growable: growable);
    @core::override
    method toString() → core::String
      return "[${this.{tup::Tuple6::item1}}, ${this.{tup::Tuple6::item2}}, ${this.{tup::Tuple6::item3}}, ${this.{tup::Tuple6::item4}}, ${this.{tup::Tuple6::item5}}, ${this.{tup::Tuple6::item6}}]";
    @core::override
    operator ==(dynamic o) → core::bool
      return o is tup::Tuple6<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic> && o{tup::Tuple6<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple6::item1}.{core::Object::==}(this.{tup::Tuple6::item1}) && o{tup::Tuple6<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple6::item2}.{core::Object::==}(this.{tup::Tuple6::item2}) && o{tup::Tuple6<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple6::item3}.{core::Object::==}(this.{tup::Tuple6::item3}) && o{tup::Tuple6<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple6::item4}.{core::Object::==}(this.{tup::Tuple6::item4}) && o{tup::Tuple6<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple6::item5}.{core::Object::==}(this.{tup::Tuple6::item5}) && o{tup::Tuple6<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple6::item6}.{core::Object::==}(this.{tup::Tuple6::item6});
    @core::override
    get hashCode() → core::int
      return core3::hashObjects(<dynamic>[this.{tup::Tuple6::item1}.{core::Object::hashCode}, this.{tup::Tuple6::item2}.{core::Object::hashCode}, this.{tup::Tuple6::item3}.{core::Object::hashCode}, this.{tup::Tuple6::item4}.{core::Object::hashCode}, this.{tup::Tuple6::item5}.{core::Object::hashCode}, this.{tup::Tuple6::item6}.{core::Object::hashCode}]);
  }
  class Tuple7<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic, T5 extends core::Object = dynamic, T6 extends core::Object = dynamic, T7 extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/tuple-1.0.2/lib/src/tuple.dart
    final field tup::Tuple7::T1 item1;
    final field tup::Tuple7::T2 item2;
    final field tup::Tuple7::T3 item3;
    final field tup::Tuple7::T4 item4;
    final field tup::Tuple7::T5 item5;
    final field tup::Tuple7::T6 item6;
    final field tup::Tuple7::T7 item7;
    const constructor •(tup::Tuple7::T1 item1, tup::Tuple7::T2 item2, tup::Tuple7::T3 item3, tup::Tuple7::T4 item4, tup::Tuple7::T5 item5, tup::Tuple7::T6 item6, tup::Tuple7::T7 item7) → void
      : tup::Tuple7::item1 = item1, tup::Tuple7::item2 = item2, tup::Tuple7::item3 = item3, tup::Tuple7::item4 = item4, tup::Tuple7::item5 = item5, tup::Tuple7::item6 = item6, tup::Tuple7::item7 = item7, super core::Object::•()
      ;
    static factory fromList<T1 extends core::Object = dynamic, T2 extends core::Object = dynamic, T3 extends core::Object = dynamic, T4 extends core::Object = dynamic, T5 extends core::Object = dynamic, T6 extends core::Object = dynamic, T7 extends core::Object = dynamic>(core::List<dynamic> items) → tup::Tuple7<tup::Tuple7::fromList::T1, tup::Tuple7::fromList::T2, tup::Tuple7::fromList::T3, tup::Tuple7::fromList::T4, tup::Tuple7::fromList::T5, tup::Tuple7::fromList::T6, tup::Tuple7::fromList::T7> {
      if(!items.{core::List::length}.{core::num::==}(7)) {
        throw new core::ArgumentError::•("items must have length 7");
      }
      return new tup::Tuple7::•<tup::Tuple7::fromList::T1, tup::Tuple7::fromList::T2, tup::Tuple7::fromList::T3, tup::Tuple7::fromList::T4, tup::Tuple7::fromList::T5, tup::Tuple7::fromList::T6, tup::Tuple7::fromList::T7>(items.{core::List::[]}(0) as tup::Tuple7::fromList::T1, items.{core::List::[]}(1) as tup::Tuple7::fromList::T2, items.{core::List::[]}(2) as tup::Tuple7::fromList::T3, items.{core::List::[]}(3) as tup::Tuple7::fromList::T4, items.{core::List::[]}(4) as tup::Tuple7::fromList::T5, items.{core::List::[]}(5) as tup::Tuple7::fromList::T6, items.{core::List::[]}(6) as tup::Tuple7::fromList::T7);
    }
    method withItem1(generic-covariant-impl tup::Tuple7::T1 v) → tup::Tuple7<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7> {
      return new tup::Tuple7::•<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7>(v, this.{tup::Tuple7::item2}, this.{tup::Tuple7::item3}, this.{tup::Tuple7::item4}, this.{tup::Tuple7::item5}, this.{tup::Tuple7::item6}, this.{tup::Tuple7::item7});
    }
    method withItem2(generic-covariant-impl tup::Tuple7::T2 v) → tup::Tuple7<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7> {
      return new tup::Tuple7::•<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7>(this.{tup::Tuple7::item1}, v, this.{tup::Tuple7::item3}, this.{tup::Tuple7::item4}, this.{tup::Tuple7::item5}, this.{tup::Tuple7::item6}, this.{tup::Tuple7::item7});
    }
    method withItem3(generic-covariant-impl tup::Tuple7::T3 v) → tup::Tuple7<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7> {
      return new tup::Tuple7::•<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7>(this.{tup::Tuple7::item1}, this.{tup::Tuple7::item2}, v, this.{tup::Tuple7::item4}, this.{tup::Tuple7::item5}, this.{tup::Tuple7::item6}, this.{tup::Tuple7::item7});
    }
    method withItem4(generic-covariant-impl tup::Tuple7::T4 v) → tup::Tuple7<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7> {
      return new tup::Tuple7::•<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7>(this.{tup::Tuple7::item1}, this.{tup::Tuple7::item2}, this.{tup::Tuple7::item3}, v, this.{tup::Tuple7::item5}, this.{tup::Tuple7::item6}, this.{tup::Tuple7::item7});
    }
    method withItem5(generic-covariant-impl tup::Tuple7::T5 v) → tup::Tuple7<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7> {
      return new tup::Tuple7::•<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7>(this.{tup::Tuple7::item1}, this.{tup::Tuple7::item2}, this.{tup::Tuple7::item3}, this.{tup::Tuple7::item4}, v, this.{tup::Tuple7::item6}, this.{tup::Tuple7::item7});
    }
    method withItem6(generic-covariant-impl tup::Tuple7::T6 v) → tup::Tuple7<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7> {
      return new tup::Tuple7::•<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7>(this.{tup::Tuple7::item1}, this.{tup::Tuple7::item2}, this.{tup::Tuple7::item3}, this.{tup::Tuple7::item4}, this.{tup::Tuple7::item5}, v, this.{tup::Tuple7::item7});
    }
    method withItem7(generic-covariant-impl tup::Tuple7::T7 v) → tup::Tuple7<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7> {
      return new tup::Tuple7::•<tup::Tuple7::T1, tup::Tuple7::T2, tup::Tuple7::T3, tup::Tuple7::T4, tup::Tuple7::T5, tup::Tuple7::T6, tup::Tuple7::T7>(this.{tup::Tuple7::item1}, this.{tup::Tuple7::item2}, this.{tup::Tuple7::item3}, this.{tup::Tuple7::item4}, this.{tup::Tuple7::item5}, this.{tup::Tuple7::item6}, v);
    }
    method toList({core::bool growable = false}) → core::List<dynamic>
      return core::List::from<dynamic>(<dynamic>[this.{tup::Tuple7::item1}, this.{tup::Tuple7::item2}, this.{tup::Tuple7::item3}, this.{tup::Tuple7::item4}, this.{tup::Tuple7::item5}, this.{tup::Tuple7::item6}, this.{tup::Tuple7::item7}], growable: growable);
    @core::override
    method toString() → core::String
      return "[${this.{tup::Tuple7::item1}}, ${this.{tup::Tuple7::item2}}, ${this.{tup::Tuple7::item3}}, ${this.{tup::Tuple7::item4}}, ${this.{tup::Tuple7::item5}}, ${this.{tup::Tuple7::item6}}, ${this.{tup::Tuple7::item7}}]";
    @core::override
    operator ==(dynamic o) → core::bool
      return o is tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic> && o{tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple7::item1}.{core::Object::==}(this.{tup::Tuple7::item1}) && o{tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple7::item2}.{core::Object::==}(this.{tup::Tuple7::item2}) && o{tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple7::item3}.{core::Object::==}(this.{tup::Tuple7::item3}) && o{tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple7::item4}.{core::Object::==}(this.{tup::Tuple7::item4}) && o{tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple7::item5}.{core::Object::==}(this.{tup::Tuple7::item5}) && o{tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple7::item5}.{core::Object::==}(this.{tup::Tuple7::item6}) && o{tup::Tuple7<dynamic, dynamic, dynamic, dynamic, dynamic, dynamic, dynamic>}.{tup::Tuple7::item6}.{core::Object::==}(this.{tup::Tuple7::item7});
    @core::override
    get hashCode() → core::int
      return core3::hashObjects(<dynamic>[this.{tup::Tuple7::item1}.{core::Object::hashCode}, this.{tup::Tuple7::item2}.{core::Object::hashCode}, this.{tup::Tuple7::item3}.{core::Object::hashCode}, this.{tup::Tuple7::item4}.{core::Object::hashCode}, this.{tup::Tuple7::item5}.{core::Object::hashCode}, this.{tup::Tuple7::item6}.{core::Object::hashCode}, this.{tup::Tuple7::item7}.{core::Object::hashCode}]);
  }
}
library merge_map from "package:merge_map/merge_map.dart" as mer {
  static method _copyValues<K extends core::Object = dynamic, V extends core::Object = dynamic>(core::Map<mer::_copyValues::K, mer::_copyValues::V> from, core::Map<mer::_copyValues::K, mer::_copyValues::V> to, core::bool recursive, core::bool acceptNull) → dynamic {
    for (mer::_copyValues::K key in from.{core::Map::keys}) {
      if(from.{core::Map::[]}(key) is core::Map<mer::_copyValues::K, mer::_copyValues::V> && recursive) {
        if(!(to.{core::Map::[]}(key) is core::Map<mer::_copyValues::K, mer::_copyValues::V>)) {
          to.{core::Map::[]=}(key, <mer::_copyValues::K, mer::_copyValues::V>{} as mer::_copyValues::V);
        }
        mer::_copyValues<dynamic, dynamic>(from.{core::Map::[]}(key) as core::Map<dynamic, dynamic>, to.{core::Map::[]}(key) as core::Map<dynamic, dynamic>, recursive, acceptNull);
      }
      else {
        if(!from.{core::Map::[]}(key).{core::Object::==}(null) || acceptNull)
          to.{core::Map::[]=}(key, from.{core::Map::[]}(key));
      }
    }
  }
  static method mergeMap<K extends core::Object = dynamic, V extends core::Object = dynamic>(core::Iterable<core::Map<mer::mergeMap::K, mer::mergeMap::V>> maps, {core::bool recursive = true, core::bool acceptNull = false}) → core::Map<mer::mergeMap::K, mer::mergeMap::V> {
    core::Map<mer::mergeMap::K, mer::mergeMap::V> result = <mer::mergeMap::K, mer::mergeMap::V>{};
    maps.{core::Iterable::forEach}((core::Map<mer::mergeMap::K, mer::mergeMap::V> map) → core::Null {
      if(!map.{core::Object::==}(null))
        mer::_copyValues<mer::mergeMap::K, mer::mergeMap::V>(map, result, recursive, acceptNull);
    });
    return result;
  }
}
library from "package:dart2_constant/convert.dart" as con4 {
  import "dart:convert" as convert;
  abstract class HtmlEscapeMode extends core::Object {
    static const field con2::HtmlEscapeMode unknown = con2::HtmlEscapeMode::unknown;
    static const field con2::HtmlEscapeMode attribute = con2::HtmlEscapeMode::attribute;
    static const field con2::HtmlEscapeMode sqAttribute = con2::HtmlEscapeMode::sqAttribute;
    static const field con2::HtmlEscapeMode element = con2::HtmlEscapeMode::element;
    synthetic constructor •() → void
      : super core::Object::•()
      ;
  }
  static const field con2::AsciiCodec ascii = con2::ascii;
  static const field con2::Base64Codec base64 = con2::base64;
  static const field con2::Base64Codec base64Url = con2::base64Url;
  static const field con2::HtmlEscape htmlEscape = con2::htmlEscape;
  static const field con2::JsonCodec json = con2::json;
  static const field con2::Latin1Codec latin1 = con2::latin1;
  static const field core::int unicodeReplacementCharacterRune = con2::unicodeReplacementCharacterRune;
  static const field core::int unicodeBomCharacterRune = con2::unicodeBomCharacterRune;
  static const field con2::Utf8Codec utf8 = con2::utf8;
}
library from "package:angel_route/src/middleware_pipeline.dart" as mid {
  import "package:angel_route/src/router.dart";
  class MiddlewarePipeline<T extends core::Object = dynamic> extends core::Object {
    final field core::Iterable<rou2::RoutingResult<mid::MiddlewarePipeline::T>> routingResults;
    generic-covariant-impl field core::List<mid::MiddlewarePipeline::T> _handlers = null;
    constructor •(core::Iterable<rou2::RoutingResult<mid::MiddlewarePipeline::T>> routingResults) → void
      : mid::MiddlewarePipeline::routingResults = routingResults.{core::Iterable::toList}(), super core::Object::•()
      ;
    get handlers() → core::List<mid::MiddlewarePipeline::T> {
      if(!this.{mid::MiddlewarePipeline::_handlers}.{core::Object::==}(null))
        return this.{mid::MiddlewarePipeline::_handlers};
      final core::List<mid::MiddlewarePipeline::T> handlers = <mid::MiddlewarePipeline::T>[];
      for (rou2::RoutingResult<mid::MiddlewarePipeline::T> result in this.{mid::MiddlewarePipeline::routingResults}) {
        handlers.{core::List::addAll}(result.{rou2::RoutingResult::allHandlers});
      }
      return this.{mid::MiddlewarePipeline::_handlers} = handlers;
    }
  }
}
library angel_route.src.router from "package:angel_route/src/router.dart" as rou2 {
  import "package:combinator/combinator.dart";
  import "package:meta/meta.dart";
  import "package:string_scanner/string_scanner.dart";
  import "package:angel_route/string_util.dart";
  import "package:angel_route/src/routing_exception.dart";
  class Router<T extends core::Object = dynamic> extends core::Object {
    final field core::Map<core::String, core::Iterable<rou2::RoutingResult<rou2::Router::T>>> _cache = <core::String, core::Iterable<rou2::RoutingResult<rou2::Router::T>>>{};
    final field core::List<rou2::Router::T> _middleware = <rou2::Router::T>[];
    final field core::Map<core::Pattern, rou2::Router<rou2::Router::T>> _mounted = <core::Pattern, rou2::Router<rou2::Router::T>>{};
    final field core::List<rou2::Route<rou2::Router::T>> _routes = <rou2::Route<rou2::Router::T>>[];
    field core::bool _useCache = false;
    constructor •() → void
      : super core::Object::•()
      ;
    get middleware() → core::List<rou2::Router::T>
      return core::List::unmodifiable<rou2::Router::T>(this.{rou2::Router::_middleware});
    get mounted() → core::Map<core::Pattern, rou2::Router<dynamic>>
      return core::Map::unmodifiable<core::Pattern, rou2::Router<dynamic>>(this.{rou2::Router::_mounted});
    get routes() → core::List<rou2::Route<rou2::Router::T>> {
      return this.{rou2::Router::_routes}.{core::Iterable::fold}<core::List<rou2::Route<rou2::Router::T>>>(<rou2::Route<rou2::Router::T>>[], (core::List<rou2::Route<rou2::Router::T>> out, rou2::Route<rou2::Router::T> route) → core::List<rou2::Route<rou2::Router::T>> {
        if(route is rou2::SymlinkRoute<rou2::Router::T>) {
          core::List<rou2::Route<rou2::Router::T>> childRoutes = route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::SymlinkRoute::router}.{rou2::Router::routes}.{core::Iterable::fold}<core::List<rou2::Route<rou2::Router::T>>>(<rou2::Route<rou2::Router::T>>[], (core::List<rou2::Route<rou2::Router::T>> out, rou2::Route<rou2::Router::T> r) → core::List<rou2::Route<rou2::Router::T>> {
            return let final core::List<rou2::Route<rou2::Router::T>> #t225 = out in let final dynamic #t226 = #t225.{core::List::add}(route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::Route::path}.{core::String::isEmpty} ?{rou2::Route<rou2::Router::T>} r : rou2::Route::join<rou2::Router::T>(route{rou2::SymlinkRoute<rou2::Router::T>}, r)) in #t225;
          });
          return let final core::List<rou2::Route<rou2::Router::T>> #t227 = out in let final dynamic #t228 = #t227.{core::List::addAll}(childRoutes) in #t227;
        }
        else {
          return let final core::List<rou2::Route<rou2::Router::T>> #t229 = out in let final dynamic #t230 = #t229.{core::List::add}(route) in #t229;
        }
      });
    }
    method enableCache() → void {
      this.{rou2::Router::_useCache} = true;
    }
    method addRoute(core::String method, core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = const <core::Null>[]}) → rou2::Route<rou2::Router::T> {
      if(this.{rou2::Router::_useCache}.{core::Object::==}(true))
        throw new core::StateError::•("Cannot add routes after caching is enabled.");
      final core::List<rou2::Router::T> handlers = <rou2::Router::T>[handler];
      if(!middleware.{core::Object::==}(null))
        handlers.{core::List::insertAll}(0, middleware);
      final rou2::Route<rou2::Router::T> route = new rou2::Route::•<rou2::Router::T>(path, method: method, handlers: handlers);
      this.{rou2::Router::_routes}.{core::List::add}(route);
      return route;
    }
    method chain(generic-covariant-impl core::Iterable<rou2::Router::T> middleware) → rou2::_ChainedRouter<rou2::Router::T> {
      rou2::_ChainedRouter<rou2::Router::T> piped = new rou2::_ChainedRouter::•<rou2::Router::T>(this, middleware);
      rou2::SymlinkRoute<rou2::Router::T> route = new rou2::SymlinkRoute::•<rou2::Router::T>("/", piped);
      this.{rou2::Router::_routes}.{core::List::add}(route);
      return piped;
    }
    method clone() → rou2::Router<rou2::Router::T> {
      final rou2::Router<rou2::Router::T> router = new rou2::Router::•<rou2::Router::T>();
      final core::Map<core::Pattern, rou2::Router<rou2::Router::T>> newMounted = col::LinkedHashMap::from<core::Pattern, rou2::Router<rou2::Router::T>>(this.{rou2::Router::mounted});
      for (rou2::Route<rou2::Router::T> route in this.{rou2::Router::routes}) {
        if(!(route is rou2::SymlinkRoute<rou2::Router::T>)) {
          router.{rou2::Router::_routes}.{core::List::add}(route.{rou2::Route::clone}());
        }
        else
          if(route is rou2::SymlinkRoute<rou2::Router::T>) {
            final rou2::Router<rou2::Router::T> newRouter = route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::SymlinkRoute::router}.{rou2::Router::clone}();
            newMounted.{core::Map::[]=}(route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::Route::path}, newRouter);
            final rou2::SymlinkRoute<rou2::Router::T> symlink = new rou2::SymlinkRoute::•<rou2::Router::T>(route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::Route::path}, newRouter);
            router.{rou2::Router::_routes}.{core::List::add}(symlink);
          }
      }
      return let final rou2::Router<rou2::Router::T> #t231 = router in let final dynamic #t232 = #t231.{rou2::Router::_mounted}.{core::Map::addAll}(newMounted) in #t231;
    }
    method dumpTree({(core::String) → dynamic callback = null, core::String header = "Dumping route tree:", core::String tab = "  "}) → void {
      final core::StringBuffer buf = new core::StringBuffer::•();
      core::int tabs = 0;
      if(!header.{core::String::==}(null) && header.{core::String::isNotEmpty}) {
        buf.{core::StringBuffer::writeln}(header);
      }
      buf.{core::StringBuffer::writeln}("<root>");
      function indent() → core::Null {
        for (core::int i = 0; i.{core::num::<}(tabs); i = i.{core::num::+}(1))
          buf.{core::StringBuffer::write}(tab);
      }
      function dumpRouter(rou2::Router<dynamic> router) → core::Null {
        indent.call();
        tabs = tabs.{core::num::+}(1);
        for (rou2::Route<dynamic> route in router.{rou2::Router::routes}) {
          indent.call();
          buf.{core::StringBuffer::write}("- ");
          if(!(route is rou2::SymlinkRoute<dynamic>))
            buf.{core::StringBuffer::write}("${route.{rou2::Route::method}} ");
          buf.{core::StringBuffer::write}("${route.{rou2::Route::path}.{core::String::isNotEmpty} ?{core::String} route.{rou2::Route::path} : "/"}");
          if(route is rou2::SymlinkRoute<rou2::Router::T>) {
            buf.{core::StringBuffer::writeln}();
            dumpRouter.call(route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::SymlinkRoute::router});
          }
          else {
            buf.{core::StringBuffer::writeln}(" => ${route.{rou2::Route::handlers}.{core::List::length}} handler(s)");
          }
        }
        tabs = tabs.{core::num::-}(1);
      }
      dumpRouter.call(this);
      (let final (core::String) → dynamic #t233 = callback in #t233.==(null) ?{(core::String) → dynamic} core::print : #t233).call(buf.{core::StringBuffer::toString}());
    }
    method group(core::String path, (rou2::Router<dynamic>) → void callback, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = const <core::Null>[], core::String name = null}) → rou2::SymlinkRoute<rou2::Router::T> {
      final rou2::Router<rou2::Router::T> router = let final rou2::Router<rou2::Router::T> #t234 = new rou2::Router::•<rou2::Router::T>() in let final dynamic #t235 = #t234.{rou2::Router::_middleware}.{core::List::addAll}(middleware) in #t234;
      callback.call(router);
      return let final rou2::SymlinkRoute<rou2::Router::T> #t236 = this.{rou2::Router::mount}(path, router) in let final dynamic #t237 = #t236.{rou2::Route::name} = name in #t236;
    }
    method navigate(core::Iterable<dynamic> linkParams, {core::bool absolute = true}) → core::String {
      final core::List<core::String> segments = <core::String>[];
      rou2::Router<dynamic> search = this;
      rou2::Route<dynamic> lastRoute;
      for (final dynamic param in linkParams) {
        core::bool resolved = false;
        if(param is core::String) {
          #L29:
          for (rou2::Route<dynamic> route in search.{rou2::Router::routes}) {
            if(route.{rou2::Route::name}.{core::String::==}(param{core::String})) {
              segments.{core::List::add}(route.{rou2::Route::path}.{core::String::replaceAll}(rou2::_straySlashes, ""));
              lastRoute = route;
              if(route is rou2::SymlinkRoute<rou2::Router::T>) {
                search = route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::SymlinkRoute::router};
              }
              resolved = true;
              break #L29;
            }
          }
          if(!resolved) {
            spa::SpanScanner scanner = new spa::SpanScanner::•(param{core::String}.{core::String::replaceAll}(rou2::_straySlashes, ""));
            #L30:
            for (rou2::Route<dynamic> route in search.{rou2::Router::routes}) {
              core::int pos = scanner.{str::StringScanner::position};
              if(route.{rou2::Route::parser}.{com::Parser::parse}(scanner).{com::ParseResult::successful} && scanner.{str::StringScanner::isDone}) {
                segments.{core::List::add}(route.{rou2::Route::path}.{core::String::replaceAll}(rou2::_straySlashes, ""));
                lastRoute = route;
                if(route is rou2::SymlinkRoute<rou2::Router::T>) {
                  search = route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::SymlinkRoute::router};
                }
                resolved = true;
                break #L30;
              }
              else
                scanner.{str::StringScanner::position} = pos;
            }
          }
          if(!resolved) {
            throw rou3::RoutingException::•("Cannot resolve route for link param \"${param{core::String}}\".");
          }
        }
        else
          if(param is rou2::Route<dynamic>) {
            segments.{core::List::add}(param{rou2::Route<dynamic>}.{rou2::Route::path}.{core::String::replaceAll}(rou2::_straySlashes, ""));
          }
          else
            if(param is core::Map<core::String, dynamic>) {
              if(lastRoute.{core::Object::==}(null)) {
                throw rou3::RoutingException::•("Maps in link params must be preceded by a Route or String.");
              }
              else {
                segments.{core::List::removeLast}();
                segments.{core::List::add}(lastRoute.{rou2::Route::makeUri}(param{core::Map<core::String, dynamic>}).{core::String::replaceAll}(rou2::_straySlashes, ""));
              }
            }
            else
              throw rou3::RoutingException::•("Link param ${param} is not Route, String, or Map<String, dynamic>.");
      }
      return absolute ?{core::String} "/${segments.{core::Iterable::join}("/").{core::String::replaceAll}(rou2::_straySlashes, "")}" : segments.{core::Iterable::join}("/");
    }
    method resolve(core::String absolute, core::String relative, generic-covariant-impl core::List<rou2::RoutingResult<rou2::Router::T>> out, {core::String method = "GET", core::bool strip = true}) → core::bool {
      final core::String cleanRelative = strip.{core::Object::==}(false) ?{core::String} relative : str2::stripStraySlashes(relative);
      spa::SpanScanner scanner = new spa::SpanScanner::•(cleanRelative);
      function crawl(rou2::Router<rou2::Router::T> r) → core::bool {
        core::bool success = false;
        for (rou2::Route<rou2::Router::T> route in r.{rou2::Router::routes}) {
          core::int pos = scanner.{str::StringScanner::position};
          if(route is rou2::SymlinkRoute<rou2::Router::T>) {
            if(route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::Route::parser}.{com::Parser::parse}(scanner).{com::ParseResult::successful}) {
              core::bool s = crawl.call(route{rou2::SymlinkRoute<rou2::Router::T>}.{rou2::SymlinkRoute::router});
              if(s)
                success = true;
            }
            scanner.{str::StringScanner::position} = pos;
          }
          else
            if(route.{rou2::Route::method}.{core::String::==}("*") || route.{rou2::Route::method}.{core::String::==}(method)) {
              com::ParseResult<core::Map<core::String, dynamic>> parseResult = route.{rou2::Route::parser}.{com::Parser::parse}(scanner);
              if(parseResult.{com::ParseResult::successful} && scanner.{str::StringScanner::isDone}) {
                rou2::RoutingResult<rou2::Router::T> result = new rou2::RoutingResult::•<rou2::Router::T>(parseResult: parseResult, params: parseResult.{com::ParseResult::value}, shallowRoute: route, shallowRouter: this);
                out.{core::List::add}(result);
                success = true;
              }
              scanner.{str::StringScanner::position} = pos;
            }
        }
        return success;
      }
      return crawl.call(this);
    }
    method resolveAbsolute(core::String path, {core::String method = "GET", core::bool strip = true}) → core::Iterable<rou2::RoutingResult<rou2::Router::T>>
      return this.{rou2::Router::resolveAll}(path, path, method: method, strip: strip);
    method resolveAll(core::String absolute, core::String relative, {core::String method = "GET", core::bool strip = true}) → core::Iterable<rou2::RoutingResult<rou2::Router::T>> {
      if(this.{rou2::Router::_useCache}.{core::Object::==}(true)) {
        return this.{rou2::Router::_cache}.{core::Map::putIfAbsent}("${method}${absolute}", () → core::Iterable<rou2::RoutingResult<rou2::Router::T>> => this.{rou2::Router::_resolveAll}(absolute, relative, method: method, strip: strip));
      }
      return this.{rou2::Router::_resolveAll}(absolute, relative, method: method, strip: strip);
    }
    method _resolveAll(core::String absolute, core::String relative, {core::String method = "GET", core::bool strip = true}) → core::Iterable<rou2::RoutingResult<rou2::Router::T>> {
      core::List<rou2::RoutingResult<rou2::Router::T>> results = <rou2::RoutingResult<rou2::Router::T>>[];
      this.{rou2::Router::resolve}(absolute, relative, results, method: method, strip: strip);
      return results;
    }
    method mount(core::String path, generic-covariant-impl rou2::Router<rou2::Router::T> router) → rou2::SymlinkRoute<rou2::Router::T> {
      final rou2::SymlinkRoute<rou2::Router::T> route = new rou2::SymlinkRoute::•<rou2::Router::T>(path, router);
      this.{rou2::Router::_mounted}.{core::Map::[]=}(route.{rou2::Route::path}, router);
      this.{rou2::Router::_routes}.{core::List::add}(route);
      return route;
    }
    method all(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<rou2::Router::T> {
      return this.{rou2::Router::addRoute}("*", path, handler, middleware: middleware);
    }
    method delete(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<rou2::Router::T> {
      return this.{rou2::Router::addRoute}("DELETE", path, handler, middleware: middleware);
    }
    method get(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<rou2::Router::T> {
      return this.{rou2::Router::addRoute}("GET", path, handler, middleware: middleware);
    }
    method head(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<rou2::Router::T> {
      return this.{rou2::Router::addRoute}("HEAD", path, handler, middleware: middleware);
    }
    method options(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<rou2::Router::T> {
      return this.{rou2::Router::addRoute}("OPTIONS", path, handler, middleware: middleware);
    }
    method post(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<rou2::Router::T> {
      return this.{rou2::Router::addRoute}("POST", path, handler, middleware: middleware);
    }
    method patch(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<rou2::Router::T> {
      return this.{rou2::Router::addRoute}("PATCH", path, handler, middleware: middleware);
    }
    method put(core::String path, generic-covariant-impl rou2::Router::T handler, {generic-covariant-impl core::Iterable<rou2::Router::T> middleware = null}) → rou2::Route<dynamic> {
      return this.{rou2::Router::addRoute}("PUT", path, handler, middleware: middleware);
    }
  }
  class _ChainedRouter<T extends core::Object = dynamic> extends rou2::Router<rou2::_ChainedRouter::T> {
    final field core::List<rou2::_ChainedRouter::T> _handlers = <rou2::_ChainedRouter::T>[];
    field rou2::Router<dynamic> _root = null;
    constructor empty() → void
      : super rou2::Router::•()
      ;
    constructor •(rou2::Router<dynamic> root, core::Iterable<rou2::_ChainedRouter::T> middleware) → void
      : super rou2::Router::•() {
      this.{rou2::_ChainedRouter::_root} = root;
      this.{rou2::_ChainedRouter::_handlers}.{core::List::addAll}(middleware);
    }
    @core::override
    method addRoute(core::String method, core::String path, generic-covariant-impl rou2::_ChainedRouter::T handler, {generic-covariant-impl core::Iterable<rou2::_ChainedRouter::T> middleware = const <core::Null>[]}) → rou2::Route<rou2::_ChainedRouter::T> {
      rou2::Route<rou2::_ChainedRouter::T> route = super.{rou2::Router::addRoute}(method, path, handler, middleware: let final core::List<rou2::_ChainedRouter::T> #t238 = <rou2::_ChainedRouter::T>[] in let final dynamic #t239 = #t238.{core::List::addAll}(this.{rou2::_ChainedRouter::_handlers}) in let final dynamic #t240 = #t238.{core::List::addAll}(let final core::Iterable<rou2::_ChainedRouter::T> #t241 = middleware in #t241.==(null) ?{core::Iterable<rou2::_ChainedRouter::T>} <rou2::_ChainedRouter::T>[] : #t241) in #t238);
      return route;
    }
    method group(core::String path, (rou2::Router<rou2::_ChainedRouter::T>) → void callback, {generic-covariant-impl core::Iterable<rou2::_ChainedRouter::T> middleware = const <core::Null>[], core::String name = null}) → rou2::SymlinkRoute<rou2::_ChainedRouter::T> {
      final rou2::_ChainedRouter<rou2::_ChainedRouter::T> router = new rou2::_ChainedRouter::•<rou2::_ChainedRouter::T>(this.{rou2::_ChainedRouter::_root}, let final core::List<rou2::_ChainedRouter::T> #t242 = <rou2::_ChainedRouter::T>[] in let final dynamic #t243 = #t242.{core::List::addAll}(this.{rou2::_ChainedRouter::_handlers}) in let final dynamic #t244 = #t242.{core::List::addAll}(middleware) in #t242);
      callback.call(router);
      return let final rou2::SymlinkRoute<rou2::_ChainedRouter::T> #t245 = this.{rou2::_ChainedRouter::mount}(path, router) in let final dynamic #t246 = #t245.{rou2::Route::name} = name in #t245;
    }
    @core::override
    method mount(core::String path, generic-covariant-impl rou2::Router<rou2::_ChainedRouter::T> router) → rou2::SymlinkRoute<rou2::_ChainedRouter::T> {
      final rou2::SymlinkRoute<rou2::_ChainedRouter::T> route = super.{rou2::Router::mount}(path, router);
      route.{rou2::SymlinkRoute::router}.{rou2::Router::_middleware}.{core::List::insertAll}(0, this.{rou2::_ChainedRouter::_handlers});
      return route;
    }
    @core::override
    method chain(generic-covariant-impl core::Iterable<rou2::_ChainedRouter::T> middleware) → rou2::_ChainedRouter<rou2::_ChainedRouter::T> {
      final rou2::_ChainedRouter<rou2::_ChainedRouter::T> piped = let final rou2::_ChainedRouter<rou2::_ChainedRouter::T> #t247 = new rou2::_ChainedRouter::empty<rou2::_ChainedRouter::T>() in let final dynamic #t248 = #t247.{rou2::_ChainedRouter::_root} = this.{rou2::_ChainedRouter::_root} in #t247;
      piped.{rou2::_ChainedRouter::_handlers}.{core::List::addAll}(let final core::List<rou2::_ChainedRouter::T> #t249 = <rou2::_ChainedRouter::T>[] in let final dynamic #t250 = #t249.{core::List::addAll}(this.{rou2::_ChainedRouter::_handlers}) in let final dynamic #t251 = #t249.{core::List::addAll}(middleware) in #t249);
      rou2::SymlinkRoute<rou2::_ChainedRouter::T> route = new rou2::SymlinkRoute::•<rou2::_ChainedRouter::T>("/", piped);
      this.{rou2::Router::_routes}.{core::List::add}(route);
      return piped;
    }
  }
  class RouteGrammar extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    static final field core::RegExp rgx = core::RegExp::•("\\((.+)\\)");
    static final field com::Parser<core::String> notSlash = com::match<core::String>(core::RegExp::•("[^/]+")).{com::Parser::value}((com::ParseResult<core::String> r) → core::String => r.{com::ParseResult::span}.{span::SourceSpanBase::text});
    static final field com::Parser<core::RegExp> regExp = com::match<core::RegExp>(core::RegExp::•("\\((.+)\\)")).{com::Parser::value}((com::ParseResult<core::RegExp> r) → core::RegExp => core::RegExp::•(r.{com::ParseResult::scanner}.{str::StringScanner::lastMatch}.{core::Match::[]}(1)));
    static final field com::Parser<core::String> parameterName = com::match<core::String>(core::RegExp::•(":([A-Za-z0-9_]+)")).{com::Parser::value}((com::ParseResult<core::String> r) → core::String => r.{com::ParseResult::span}.{span::SourceSpanBase::text}.{core::String::substring}(1));
    static final field com::Parser<rou2::ParameterSegment> parameterSegment = com::chain<core::Object>(<com::Parser<core::Object>>[rou2::RouteGrammar::parameterName, com::match<core::bool>("?").{com::Parser::value}((com::ParseResult<core::bool> r) → core::bool => true).{com::Parser::opt}(), rou2::RouteGrammar::regExp.{com::Parser::opt}()]).{com::Parser::map}<rou2::ParameterSegment>((com::ParseResult<core::List<core::Object>> r) → rou2::ParameterSegment {
      rou2::ParameterSegment s = new rou2::ParameterSegment::•(r.{com::ParseResult::value}.{core::List::[]}(0) as core::String, r.{com::ParseResult::value}.{core::List::[]}(2) as core::RegExp);
      return r.{com::ParseResult::value}.{core::List::[]}(1).{core::Object::==}(true) ?{rou2::ParameterSegment} new rou2::OptionalSegment::•(s) : s;
    });
    static final field com::Parser<rou2::ParsedParameterSegment> parsedParameterSegment = com::chain<core::Object>(<com::Parser<core::Object>>[com::match<dynamic>(core::RegExp::•("(int|num|double)"), errorMessage: "Expected \"int\",\"double\", or \"num\".").{com::Parser::map}<core::String>((com::ParseResult<dynamic> r) → core::String => r.{com::ParseResult::span}.{span::SourceSpanBase::text}), rou2::RouteGrammar::parameterSegment]).{com::Parser::map}<rou2::ParsedParameterSegment>((com::ParseResult<core::List<core::Object>> r) → rou2::ParsedParameterSegment {
      return new rou2::ParsedParameterSegment::•(r.{com::ParseResult::value}.{core::List::[]}(0) as core::String, r.{com::ParseResult::value}.{core::List::[]}(1) as rou2::ParameterSegment);
    });
    static final field com::Parser<rou2::WildcardSegment> wildcardSegment = com::match<rou2::WildcardSegment>("*").{com::Parser::value}((com::ParseResult<rou2::WildcardSegment> r) → rou2::WildcardSegment => new rou2::WildcardSegment::•());
    static final field com::Parser<rou2::ConstantSegment> constantSegment = rou2::RouteGrammar::notSlash.{com::Parser::map}<rou2::ConstantSegment>((com::ParseResult<core::String> r) → rou2::ConstantSegment => new rou2::ConstantSegment::•(r.{com::ParseResult::value}));
    static final field com::Parser<rou2::RouteSegment> routeSegment = com::any<rou2::RouteSegment>(<com::Parser<rou2::RouteSegment>>[rou2::RouteGrammar::parsedParameterSegment, rou2::RouteGrammar::parameterSegment, rou2::RouteGrammar::wildcardSegment, rou2::RouteGrammar::constantSegment]);
    static final field com::Parser<rou2::RouteDefinition> routeDefinition = rou2::RouteGrammar::routeSegment.{com::Parser::separatedBy}(com::match<dynamic>("/")).{com::Parser::map}<rou2::RouteDefinition>((com::ParseResult<core::List<rou2::RouteSegment>> r) → rou2::RouteDefinition => new rou2::RouteDefinition::•(let final core::List<rou2::RouteSegment> #t252 = r.{com::ParseResult::value} in #t252.==(null) ?{core::List<rou2::RouteSegment>} <rou2::RouteSegment>[] : #t252)).{com::Parser::surroundedBy}(com::match<dynamic>("/").{com::Parser::star}().{com::ListParser::opt}());
    synthetic constructor •() → void
      : super core::Object::•()
      ;
  }
  class RouteDefinition extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    final field core::List<rou2::RouteSegment> segments;
    constructor •(core::List<rou2::RouteSegment> segments) → void
      : rou2::RouteDefinition::segments = segments, super core::Object::•()
      ;
    method compile() → com::Parser<core::Map<core::String, dynamic>> {
      com::Parser<core::Map<core::String, dynamic>> out;
      for (core::int i = 0; i.{core::num::<}(this.{rou2::RouteDefinition::segments}.{core::List::length}); i = i.{core::num::+}(1)) {
        rou2::RouteSegment s = this.{rou2::RouteDefinition::segments}.{core::List::[]}(i);
        core::bool isLast = i.{core::num::==}(this.{rou2::RouteDefinition::segments}.{core::List::length}.{core::num::-}(1));
        if(out.{core::Object::==}(null))
          out = s.{rou2::RouteSegment::compile}(isLast);
        else
          out = s.{rou2::RouteSegment::compileNext}(out.{com::Parser::then}(com::match<dynamic>("/")).{com::ListParser::index}(0).{com::Parser::cast}<core::Map<core::String, dynamic>>(), isLast);
      }
      return out;
    }
  }
  abstract class RouteSegment extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract method compile(core::bool isLast) → com::Parser<core::Map<core::String, dynamic>>;
    abstract method compileNext(com::Parser<core::Map<core::String, dynamic>> p, core::bool isLast) → com::Parser<core::Map<core::String, dynamic>>;
  }
  class ConstantSegment extends rou2::RouteSegment { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    final field core::String text;
    constructor •(core::String text) → void
      : rou2::ConstantSegment::text = text, super rou2::RouteSegment::•()
      ;
    @core::override
    method toString() → core::String {
      return "Constant: ${this.{rou2::ConstantSegment::text}}";
    }
    @core::override
    method compile(core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return com::match<core::Map<core::String, dynamic>>(this.{rou2::ConstantSegment::text}).{com::Parser::value}((com::ParseResult<core::Map<core::String, dynamic>> r) → core::Map<core::String, dynamic> => <core::String, dynamic>{});
    }
    @core::override
    method compileNext(com::Parser<core::Map<core::String, dynamic>> p, core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return p.{com::Parser::then}(this.{rou2::ConstantSegment::compile}(isLast)).{com::ListParser::index}(0).{com::Parser::cast}<core::Map<core::String, dynamic>>();
    }
  }
  class WildcardSegment extends rou2::RouteSegment { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    synthetic constructor •() → void
      : super rou2::RouteSegment::•()
      ;
    @core::override
    method toString() → core::String {
      return "Wildcard segment";
    }
    method _compile(core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      if(isLast)
        return com::match<core::Map<core::String, dynamic>>(core::RegExp::•(".*"));
      return com::match<core::Map<core::String, dynamic>>(core::RegExp::•("[^/]*"));
    }
    @core::override
    method compile(core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return this.{rou2::WildcardSegment::_compile}(isLast).{com::Parser::map}<core::Map<core::String, dynamic>>((com::ParseResult<core::Map<core::String, dynamic>> r) → core::Map<core::String, dynamic> => <core::String, dynamic>{});
    }
    @core::override
    method compileNext(com::Parser<core::Map<core::String, dynamic>> p, core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return p.{com::Parser::then}(this.{rou2::WildcardSegment::_compile}(isLast)).{com::ListParser::index}(0).{com::Parser::cast}<core::Map<core::String, dynamic>>();
    }
  }
  class OptionalSegment extends rou2::ParameterSegment { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    final field rou2::ParameterSegment parameter;
    constructor •(rou2::ParameterSegment parameter) → void
      : rou2::OptionalSegment::parameter = parameter, super rou2::ParameterSegment::•(parameter.{rou2::ParameterSegment::name}, parameter.{rou2::ParameterSegment::regExp})
      ;
    @core::override
    method toString() → core::String {
      return "Optional: ${this.{rou2::OptionalSegment::parameter}}";
    }
    @core::override
    method compile(core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return super.{rou2::ParameterSegment::compile}(isLast).{com::Parser::opt}();
    }
    @core::override
    method compileNext(com::Parser<core::Map<core::String, dynamic>> p, core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return p.{com::Parser::then}(this.{rou2::ParameterSegment::_compile}().{com::Parser::opt}()).{com::Parser::map}<core::Map<core::String, dynamic>>((com::ParseResult<core::List<dynamic>> r) → core::Map<core::String, dynamic> {
        if(r.{com::ParseResult::value}.{core::List::[]}(1).{core::Object::==}(null))
          return r.{com::ParseResult::value}.{core::List::[]}(0) as core::Map<core::String, dynamic>;
        return let final core::Map<core::String, dynamic> #t253 = r.{com::ParseResult::value}.{core::List::[]}(0) as core::Map<core::String, dynamic> in let final dynamic #t254 = #t253.{core::Map::addAll}(<core::String, dynamic>{this.{rou2::ParameterSegment::name}: core::Uri::decodeComponent(r.{com::ParseResult::value}.{core::List::[]}(1) as core::String)}) in #t253;
      });
    }
  }
  class ParameterSegment extends rou2::RouteSegment { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    final field core::String name;
    final field core::RegExp regExp;
    constructor •(core::String name, core::RegExp regExp) → void
      : rou2::ParameterSegment::name = name, rou2::ParameterSegment::regExp = regExp, super rou2::RouteSegment::•()
      ;
    @core::override
    method toString() → core::String {
      if(!this.{rou2::ParameterSegment::regExp}.{core::Object::==}(null))
        return "Param: ${this.{rou2::ParameterSegment::name}} (${this.{rou2::ParameterSegment::regExp}.{core::RegExp::pattern}})";
      return "Param: ${this.{rou2::ParameterSegment::name}}";
    }
    method _compile() → com::Parser<core::String> {
      return !this.{rou2::ParameterSegment::regExp}.{core::Object::==}(null) ?{com::Parser<core::String>} com::match<core::String>(this.{rou2::ParameterSegment::regExp}).{com::Parser::value}((com::ParseResult<core::String> r) → core::String => r.{com::ParseResult::span}.{span::SourceSpanBase::text}) : rou2::RouteGrammar::notSlash;
    }
    @core::override
    method compile(core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return this.{rou2::ParameterSegment::_compile}().{com::Parser::map}<core::Map<core::String, dynamic>>((com::ParseResult<core::String> r) → core::Map<core::String, dynamic> => <core::String, dynamic>{this.{rou2::ParameterSegment::name}: core::Uri::decodeComponent(r.{com::ParseResult::span}.{span::SourceSpanBase::text})});
    }
    @core::override
    method compileNext(com::Parser<core::Map<core::String, dynamic>> p, core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return p.{com::Parser::then}(this.{rou2::ParameterSegment::_compile}()).{com::Parser::map}<core::Map<core::String, dynamic>>((com::ParseResult<core::List<dynamic>> r) → core::Map<core::String, dynamic> {
        return let final core::Map<core::String, dynamic> #t255 = r.{com::ParseResult::value}.{core::List::[]}(0) as core::Map<core::String, dynamic> in let final dynamic #t256 = #t255.{core::Map::addAll}(<core::String, dynamic>{this.{rou2::ParameterSegment::name}: core::Uri::decodeComponent(r.{com::ParseResult::value}.{core::List::[]}(1) as core::String)}) in #t255;
      });
    }
  }
  class ParsedParameterSegment extends rou2::RouteSegment { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/grammar.dart
    final field core::String type;
    final field rou2::ParameterSegment parameter;
    constructor •(core::String type, rou2::ParameterSegment parameter) → void
      : rou2::ParsedParameterSegment::type = type, rou2::ParsedParameterSegment::parameter = parameter, super rou2::RouteSegment::•()
      ;
    method getValue(core::String s) → core::num {
      switch(this.{rou2::ParsedParameterSegment::type}) {
        #L31:
        case "int":
          {
            return core::int::parse(s);
          }
        #L32:
        case "double":
          {
            return core::double::parse(s);
          }
        #L33:
        default:
          {
            return core::num::parse(s);
          }
      }
    }
    @core::override
    method compile(core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return this.{rou2::ParsedParameterSegment::parameter}.{rou2::ParameterSegment::_compile}().{com::Parser::map}<core::Map<core::String, dynamic>>((com::ParseResult<core::String> r) → core::Map<core::String, dynamic> => <core::String, dynamic>{this.{rou2::ParsedParameterSegment::parameter}.{rou2::ParameterSegment::name}: this.{rou2::ParsedParameterSegment::getValue}(core::Uri::decodeComponent(r.{com::ParseResult::span}.{span::SourceSpanBase::text}))});
    }
    @core::override
    method compileNext(com::Parser<core::Map<core::String, dynamic>> p, core::bool isLast) → com::Parser<core::Map<core::String, dynamic>> {
      return p.{com::Parser::then}(this.{rou2::ParsedParameterSegment::parameter}.{rou2::ParameterSegment::_compile}()).{com::Parser::map}<core::Map<core::String, dynamic>>((com::ParseResult<core::List<dynamic>> r) → core::Map<core::String, dynamic> {
        return let final core::Map<core::String, dynamic> #t257 = r.{com::ParseResult::value}.{core::List::[]}(0) as core::Map<core::String, dynamic> in let final dynamic #t258 = #t257.{core::Map::addAll}(<core::String, dynamic>{this.{rou2::ParsedParameterSegment::parameter}.{rou2::ParameterSegment::name}: this.{rou2::ParsedParameterSegment::getValue}(core::Uri::decodeComponent(r.{com::ParseResult::value}.{core::List::[]}(1) as core::String))}) in #t257;
      });
    }
  }
  class Route<T extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/route.dart
    final field core::String method;
    final field core::String path;
    final field core::List<rou2::Route::T> handlers;
    final field core::Map<core::String, core::Map<core::String, dynamic>> _cache = <core::String, core::Map<core::String, dynamic>>{};
    final field rou2::RouteDefinition _routeDefinition;
    field core::String name = null;
    field com::Parser<core::Map<core::String, dynamic>> _parser = null;
    constructor •(core::String path, {@meta::required core::String method = null, @meta::required core::List<rou2::Route::T> handlers = null}) → void
      : rou2::Route::path = path, rou2::Route::method = method, rou2::Route::handlers = handlers, rou2::Route::_routeDefinition = rou2::RouteGrammar::routeDefinition.{com::Parser::parse}(new spa::SpanScanner::•(path.{core::String::replaceAll}(rou2::_straySlashes, ""))).{com::ParseResult::value}, super core::Object::•() {
      if(!(let final core::List<rou2::RouteSegment> #t259 = let final rou2::RouteDefinition #t260 = this.{rou2::Route::_routeDefinition} in #t260.==(null) ?{core::List<rou2::RouteSegment>} null : #t260.{rou2::RouteDefinition::segments} in #t259.==(null) ?{core::bool} null : #t259.{core::Iterable::isNotEmpty}).{core::Object::==}(true))
        this.{rou2::Route::_parser} = com::match<core::Map<core::String, dynamic>>("").{com::Parser::value}((com::ParseResult<core::Map<core::String, dynamic>> r) → core::Map<core::String, dynamic> => <core::String, dynamic>{});
    }
    static factory join<T extends core::Object = dynamic>(rou2::Route<rou2::Route::join::T> a, rou2::Route<rou2::Route::join::T> b) → rou2::Route<rou2::Route::join::T> {
      core::String start = a.{rou2::Route::path}.{core::String::replaceAll}(rou2::_straySlashes, "");
      core::String end = b.{rou2::Route::path}.{core::String::replaceAll}(rou2::_straySlashes, "");
      return new rou2::Route::•<rou2::Route::join::T>("${start}/${end}".{core::String::replaceAll}(rou2::_straySlashes, ""), method: b.{rou2::Route::method}, handlers: b.{rou2::Route::handlers});
    }
    get parser() → com::Parser<core::Map<core::String, dynamic>>
      return let final com::Parser<core::Map<core::String, dynamic>> #t261 = this.{rou2::Route::_parser} in #t261.{core::Object::==}(null) ?{com::Parser<core::Map<core::String, dynamic>>} this.{rou2::Route::_parser} = this.{rou2::Route::_routeDefinition}.{rou2::RouteDefinition::compile}() : #t261;
    @core::override
    method toString() → core::String {
      return "${this.{rou2::Route::method}} ${this.{rou2::Route::path}} => ${this.{rou2::Route::handlers}}";
    }
    method clone() → rou2::Route<rou2::Route::T> {
      return let final rou2::Route<rou2::Route::T> #t262 = new rou2::Route::•<rou2::Route::T>(this.{rou2::Route::path}, method: this.{rou2::Route::method}, handlers: this.{rou2::Route::handlers}) in let final dynamic #t263 = #t262.{rou2::Route::_cache}.{core::Map::addAll}(this.{rou2::Route::_cache}) in #t262;
    }
    method makeUri(core::Map<core::String, dynamic> params) → core::String {
      core::StringBuffer b = new core::StringBuffer::•();
      core::int i = 0;
      for (rou2::RouteSegment seg in this.{rou2::Route::_routeDefinition}.{rou2::RouteDefinition::segments}) {
        if((let final core::int #t264 = i in let final core::int #t265 = i = #t264.{core::num::+}(1) in #t264).{core::num::>}(0))
          b.{core::StringBuffer::write}("/");
        if(seg is rou2::ConstantSegment)
          b.{core::StringBuffer::write}(seg{rou2::ConstantSegment}.{rou2::ConstantSegment::text});
        else
          if(seg is rou2::ParameterSegment) {
            if(!params.{core::Map::containsKey}(seg{rou2::ParameterSegment}.{rou2::ParameterSegment::name}))
              throw new core::ArgumentError::•("Missing parameter \"${seg{rou2::ParameterSegment}.{rou2::ParameterSegment::name}}\".");
            b.{core::StringBuffer::write}(params.{core::Map::[]}(seg{rou2::ParameterSegment}.{rou2::ParameterSegment::name}));
          }
      }
      return b.{core::StringBuffer::toString}();
    }
  }
  class RoutingResult<T extends core::Object = dynamic> extends core::Object { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/routing_result.dart
    final field com::ParseResult<core::Map<core::String, dynamic>> parseResult;
    final field core::Iterable<rou2::RoutingResult<rou2::RoutingResult::T>> nested;
    final field core::Map<core::String, dynamic> params = <core::String, dynamic>{};
    final field rou2::Route<rou2::RoutingResult::T> shallowRoute;
    final field rou2::Router<rou2::RoutingResult::T> shallowRouter;
    final field core::String tail;
    constructor •({com::ParseResult<core::Map<core::String, dynamic>> parseResult = null, core::Map<core::String, dynamic> params = const <core::String, dynamic>{}, core::Iterable<rou2::RoutingResult<rou2::RoutingResult::T>> nested = null, rou2::Route<rou2::RoutingResult::T> shallowRoute = null, rou2::Router<rou2::RoutingResult::T> shallowRouter = null, core::String tail = null}) → void
      : rou2::RoutingResult::parseResult = parseResult, rou2::RoutingResult::nested = nested, rou2::RoutingResult::shallowRoute = shallowRoute, rou2::RoutingResult::shallowRouter = shallowRouter, rou2::RoutingResult::tail = tail, super core::Object::•() {
      this.{rou2::RoutingResult::params}.{core::Map::addAll}(let final core::Map<core::String, dynamic> #t266 = params in #t266.==(null) ?{core::Map<core::String, dynamic>} <core::String, dynamic>{} : #t266);
    }
    get deepest() → rou2::RoutingResult<rou2::RoutingResult::T> {
      rou2::RoutingResult<rou2::RoutingResult::T> search = this;
      while ((let final core::Iterable<rou2::RoutingResult<rou2::RoutingResult::T>> #t267 = let final rou2::RoutingResult<rou2::RoutingResult::T> #t268 = search in #t268.==(null) ?{core::Iterable<rou2::RoutingResult<rou2::RoutingResult::T>>} null : #t268.{rou2::RoutingResult::nested} in #t267.==(null) ?{core::bool} null : #t267.{core::Iterable::isNotEmpty}).{core::Object::==}(true))
        search = search.{rou2::RoutingResult::nested}.{core::Iterable::first};
      return search;
    }
    get route() → rou2::Route<rou2::RoutingResult::T>
      return this.{rou2::RoutingResult::deepest}.{rou2::RoutingResult::shallowRoute};
    get router() → rou2::Router<rou2::RoutingResult::T>
      return this.{rou2::RoutingResult::deepest}.{rou2::RoutingResult::shallowRouter};
    get handlers() → core::List<rou2::RoutingResult::T> {
      return let final core::List<rou2::RoutingResult::T> #t269 = <rou2::RoutingResult::T>[] in let final dynamic #t270 = #t269.{core::List::addAll}(this.{rou2::RoutingResult::shallowRouter}.{rou2::Router::middleware}) in let final dynamic #t271 = #t269.{core::List::addAll}(this.{rou2::RoutingResult::shallowRoute}.{rou2::Route::handlers}) in #t269;
    }
    get allHandlers() → core::List<rou2::RoutingResult::T> {
      final core::List<rou2::RoutingResult::T> handlers = <rou2::RoutingResult::T>[];
      function crawl(rou2::RoutingResult<rou2::RoutingResult::T> result) → void {
        handlers.{core::List::addAll}(result.{rou2::RoutingResult::handlers});
        if((let final core::Iterable<rou2::RoutingResult<rou2::RoutingResult::T>> #t272 = result.{rou2::RoutingResult::nested} in #t272.==(null) ?{core::bool} null : #t272.{core::Iterable::isNotEmpty}).{core::Object::==}(true)) {
          for (rou2::RoutingResult<rou2::RoutingResult::T> r in result.{rou2::RoutingResult::nested})
            crawl.call(r);
        }
      }
      crawl.call(this);
      return handlers;
    }
    get allParams() → core::Map<core::String, dynamic> {
      final core::Map<core::String, dynamic> params = <core::String, dynamic>{};
      function crawl(rou2::RoutingResult<dynamic> result) → void {
        params.{core::Map::addAll}(result.{rou2::RoutingResult::params});
        if((let final core::Iterable<rou2::RoutingResult<dynamic>> #t273 = result.{rou2::RoutingResult::nested} in #t273.==(null) ?{core::bool} null : #t273.{core::Iterable::isNotEmpty}).{core::Object::==}(true)) {
          for (rou2::RoutingResult<dynamic> r in result.{rou2::RoutingResult::nested})
            crawl.call(r);
        }
      }
      crawl.call(this);
      return params;
    }
  }
  class SymlinkRoute<T extends core::Object = dynamic> extends rou2::Route<rou2::SymlinkRoute::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/angel_route-3.0.0/lib/src/symlink_route.dart
    final field rou2::Router<rou2::SymlinkRoute::T> router;
    constructor •(core::String path, rou2::Router<rou2::SymlinkRoute::T> router) → void
      : rou2::SymlinkRoute::router = router, super rou2::Route::•(path, method: null, handlers: null)
      ;
  }
  static final field core::RegExp _straySlashes = core::RegExp::•("(^/+)|(/+\$)");
  static method flatten<T extends core::Object = dynamic>(rou2::Router<rou2::flatten::T> router) → rou2::Router<rou2::flatten::T> {
    rou2::Router<rou2::flatten::T> flattened = new rou2::Router::•<rou2::flatten::T>();
    for (rou2::Route<rou2::flatten::T> route in router.{rou2::Router::routes}) {
      if(route is rou2::SymlinkRoute<rou2::flatten::T>) {
        core::String base = route{rou2::SymlinkRoute<rou2::flatten::T>}.{rou2::Route::path}.{core::String::replaceAll}(rou2::_straySlashes, "");
        rou2::Router<rou2::flatten::T> child = rou2::flatten<rou2::flatten::T>(route{rou2::SymlinkRoute<rou2::flatten::T>}.{rou2::SymlinkRoute::router});
        for (rou2::Route<rou2::flatten::T> route in child.{rou2::Router::routes}) {
          core::String path = route.{rou2::Route::path}.{core::String::replaceAll}(rou2::_straySlashes, "");
          core::String joined = "${base}/${path}".{core::String::replaceAll}(rou2::_straySlashes, "");
          flattened.{rou2::Router::addRoute}(route.{rou2::Route::method}, joined.{core::String::replaceAll}(rou2::_straySlashes, ""), route.{rou2::Route::handlers}.{core::Iterable::last}, middleware: route.{rou2::Route::handlers}.{core::Iterable::take}(route.{rou2::Route::handlers}.{core::List::length}.{core::num::-}(1)).{core::Iterable::toList}());
        }
      }
      else {
        flattened.{rou2::Router::addRoute}(route.{rou2::Route::method}, route.{rou2::Route::path}, route.{rou2::Route::handlers}.{core::Iterable::last}, middleware: route.{rou2::Route::handlers}.{core::Iterable::take}(route.{rou2::Route::handlers}.{core::List::length}.{core::num::-}(1)).{core::Iterable::toList}());
      }
    }
    return let final rou2::Router<rou2::flatten::T> #t274 = flattened in let final dynamic #t275 = #t274.{rou2::Router::enableCache}() in #t274;
  }
}
library from "package:angel_route/src/routing_exception.dart" as rou3 {
  abstract class RoutingException extends core::Exception {
    static factory •(core::String message) → rou3::RoutingException
      return new rou3::_RoutingExceptionImpl::•(message);
    static factory orphan() → rou3::RoutingException
      return new rou3::_RoutingExceptionImpl::•("Tried to resolve path '..' on a route that has no parent.");
    static factory noSuchRoute(core::String path) → rou3::RoutingException
      return new rou3::_RoutingExceptionImpl::•("Tried to navigate to non-existent route: '${path}'.");
  }
  class _RoutingExceptionImpl extends core::Object implements rou3::RoutingException {
    final field core::String message;
    constructor •(core::String message) → void
      : rou3::_RoutingExceptionImpl::message = message, super core::Object::•()
      ;
    @core::override
    method toString() → core::String
      return this.{rou3::_RoutingExceptionImpl::message};
  }
}
library from "package:body_parser/src/body_parse_result.dart" as bod {
  import "package:body_parser/src/file_upload_info.dart";
  abstract class BodyParseResult extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get body() → core::Map<core::String, dynamic>;
    abstract get query() → core::Map<core::String, dynamic>;
    abstract get files() → core::List<fil::FileUploadInfo>;
    abstract get originalBuffer() → core::List<core::int>;
    abstract get error() → dynamic;
    abstract get stack() → core::StackTrace;
  }
}
library from "package:body_parser/src/file_upload_info.dart" as fil {
  class FileUploadInfo extends core::Object {
    field core::String mimeType;
    field core::String name;
    field core::String filename;
    field core::List<core::int> data;
    constructor •({core::String mimeType = null, core::String name = null, core::String filename = null, core::List<core::int> data = const <core::int>[]}) → void
      : fil::FileUploadInfo::mimeType = mimeType, fil::FileUploadInfo::name = name, fil::FileUploadInfo::filename = filename, fil::FileUploadInfo::data = data, super core::Object::•() {}
  }
}
library from "package:body_parser/src/parse_body.dart" as par {
  import "dart:async";
  import "dart:io";
  import "package:dart2_constant/convert.dart";
  import "package:http_parser/http_parser.dart";
  import "package:http_server/http_server.dart";
  import "package:mime/mime.dart";
  import "package:body_parser/src/body_parse_result.dart";
  import "package:body_parser/src/file_upload_info.dart";
  import "package:body_parser/src/map_from_uri.dart";
  class _BodyParseResultImpl extends core::Object implements bod::BodyParseResult {
    @core::override
    field core::Map<core::String, dynamic> body = <core::String, dynamic>{};
    @core::override
    field core::List<fil::FileUploadInfo> files = <fil::FileUploadInfo>[];
    @core::override
    field core::List<core::int> originalBuffer = null;
    @core::override
    field core::Map<core::String, dynamic> query = <core::String, dynamic>{};
    @core::override
    field dynamic error = null;
    @core::override
    field core::StackTrace stack = null;
    synthetic constructor •() → void
      : super core::Object::•()
      ;
  }
  @core::deprecated
  static method parseBody(_ht::HttpRequest request, {core::bool storeOriginalBuffer = false}) → asy::Future<bod::BodyParseResult> {
    return par::parseBodyFromStream(request, !request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::contentType}.{core::Object::==}(null) ?{med::MediaType} med::MediaType::parse(request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::contentType}.{core::Object::toString}()) : null, request.{_ht::HttpRequest::uri}, storeOriginalBuffer: storeOriginalBuffer);
  }
  static method parseBodyFromStream(asy::Stream<core::List<core::int>> data, med::MediaType contentType, core::Uri requestUri, {core::bool storeOriginalBuffer = false}) → asy::Future<bod::BodyParseResult> async {
    par::_BodyParseResultImpl result = new par::_BodyParseResultImpl::•();
    function getBytes() → asy::Future<core::List<core::int>> {
      return data.{asy::Stream::fold}<io::BytesBuilder>(io::BytesBuilder::•(copy: false), (io::BytesBuilder a, core::List<core::int> b) → io::BytesBuilder => let final io::BytesBuilder #t276 = a in let final dynamic #t277 = #t276.{io::BytesBuilder::add}(b) in #t276).{asy::Future::then}<core::List<core::int>>((io::BytesBuilder b) → core::List<core::int> => b.{io::BytesBuilder::takeBytes}());
    }
    function getBody() → asy::Future<core::String> {
      if(storeOriginalBuffer) {
        return getBytes.call().{asy::Future::then}<core::String>((core::List<core::int> bytes) → core::String {
          result.{par::_BodyParseResultImpl::originalBuffer} = bytes;
          return con4::utf8.{con2::Utf8Codec::decode}(bytes);
        });
      }
      else
        return data.{asy::Stream::transform}<core::String>(con4::utf8.{con2::Utf8Codec::decoder}).{asy::Stream::join}();
    }
    try {
      if(!contentType.{core::Object::==}(null)) {
        if(contentType.{med::MediaType::type}.{core::String::==}("multipart") && contentType.{med::MediaType::parameters}.{core::Map::containsKey}("boundary")) {
          asy::Stream<core::List<core::int>> stream;
          if(storeOriginalBuffer) {
            core::List<core::int> bytes = result.{par::_BodyParseResultImpl::originalBuffer} = await getBytes.call();
            asy::StreamController<core::List<core::int>> ctrl = let final asy::StreamController<core::List<core::int>> #t278 = asy::StreamController::•<core::List<core::int>>() in let final dynamic #t279 = #t278.{asy::StreamController::add}(bytes) in let final dynamic #t280 = #t278.{asy::StreamController::close}() in #t278;
            stream = ctrl.{asy::StreamController::stream};
          }
          else {
            stream = data;
          }
          asy::Stream<htt4::HttpMultipartFormData> parts = stream.{asy::Stream::transform}<sha::MimeMultipart>(new mul::MimeMultipartTransformer::•(contentType.{med::MediaType::parameters}.{core::Map::[]}("boundary"))).{asy::Stream::map}<htt4::HttpMultipartFormData>((sha::MimeMultipart part) → htt4::HttpMultipartFormData => htt4::HttpMultipartFormData::parse(part, defaultEncoding: con4::utf8));
          await for (htt4::HttpMultipartFormData part in parts) {
            if(part.{htt4::HttpMultipartFormData::isBinary} || part.{htt4::HttpMultipartFormData::contentDisposition}.{_ht::HeaderValue::parameters}.{core::Map::containsKey}("filename")) {
              io::BytesBuilder builder = await part.{asy::Stream::fold}<io::BytesBuilder>(io::BytesBuilder::•(copy: false), (io::BytesBuilder b, dynamic d) → io::BytesBuilder => let final io::BytesBuilder #t281 = b in let final dynamic #t282 = #t281.{io::BytesBuilder::add}(!(d is core::String) ?{core::List<core::int>} d as core::List<core::int> : (d as core::String).{core::String::codeUnits}) in #t281);
              fil::FileUploadInfo upload = new fil::FileUploadInfo::•(mimeType: part.{htt4::HttpMultipartFormData::contentType}.{_ht::ContentType::mimeType}, name: part.{htt4::HttpMultipartFormData::contentDisposition}.{_ht::HeaderValue::parameters}.{core::Map::[]}("name"), filename: let final core::String #t283 = part.{htt4::HttpMultipartFormData::contentDisposition}.{_ht::HeaderValue::parameters}.{core::Map::[]}("filename") in #t283.==(null) ?{core::String} "file" : #t283, data: builder.{io::BytesBuilder::takeBytes}());
              result.{par::_BodyParseResultImpl::files}.{core::List::add}(upload);
            }
            else
              if(part.{htt4::HttpMultipartFormData::isText}) {
                core::String text = await part.{asy::Stream::join}();
                map2::buildMapFromUri(result.{par::_BodyParseResultImpl::body}, "${part.{htt4::HttpMultipartFormData::contentDisposition}.{_ht::HeaderValue::parameters}.{core::Map::[]}("name")}=${text}");
              }
          }
        }
        else
          if(contentType.{med::MediaType::mimeType}.{core::String::==}("application/json")) {
            result.{par::_BodyParseResultImpl::body}.{core::Map::addAll}(par::_foldToStringDynamic(con4::json.{con2::JsonCodec::decode}(await getBody.call()) as core::Map<dynamic, dynamic>));
          }
          else
            if(contentType.{med::MediaType::mimeType}.{core::String::==}("application/x-www-form-urlencoded")) {
              core::String body = await getBody.call();
              map2::buildMapFromUri(result.{par::_BodyParseResultImpl::body}, body);
            }
            else
              if(storeOriginalBuffer.{core::Object::==}(true)) {
                result.{par::_BodyParseResultImpl::originalBuffer} = await getBytes.call();
              }
      }
      else {
        if(requestUri.{core::Uri::hasQuery}) {
          map2::buildMapFromUri(result.{par::_BodyParseResultImpl::query}, requestUri.{core::Uri::query});
        }
        if(storeOriginalBuffer.{core::Object::==}(true)) {
          result.{par::_BodyParseResultImpl::originalBuffer} = await getBytes.call();
        }
      }
    }
    on dynamic catch(final dynamic e, final core::StackTrace st) {
      result.{par::_BodyParseResultImpl::error} = e;
      result.{par::_BodyParseResultImpl::stack} = st;
    }
    return result;
  }
  static method _foldToStringDynamic(core::Map<dynamic, dynamic> map) → core::Map<core::String, dynamic> {
    return map.{core::Object::==}(null) ?{core::Map<core::String, dynamic>} null : map.{core::Map::keys}.{core::Iterable::fold}<core::Map<core::String, dynamic>>(<core::String, dynamic>{}, (core::Map<core::String, dynamic> out, dynamic k) → core::Map<core::String, dynamic> => let final core::Map<core::String, dynamic> #t284 = out in let final dynamic #t285 = #t284.{core::Map::[]=}(k.{core::Object::toString}(), map.{core::Map::[]}(k)) in #t284);
  }
}
library from "package:stack_trace/stack_trace.dart" as sta {
  export "package:stack_trace/src/chain.dart";
  export "package:stack_trace/src/frame.dart";
  export "package:stack_trace/src/trace.dart";
  export "package:stack_trace/src/unparsed_frame.dart";
}
library from "package:args/src/arg_parser.dart" as arg {
  import "dart:collection";
  import "package:args/src/allow_anything_parser.dart";
  import "package:args/src/arg_results.dart";
  import "package:args/src/option.dart";
  import "package:args/src/parser.dart";
  import "package:args/src/usage.dart";
  class ArgParser extends core::Object {
    final field core::Map<core::String, opt2::Option> _options;
    final field core::Map<core::String, arg::ArgParser> _commands;
    final field core::Map<core::String, opt2::Option> options;
    final field core::Map<core::String, arg::ArgParser> commands;
    final field core::List<dynamic> _optionsAndSeparators = <dynamic>[];
    final field core::bool allowTrailingOptions;
    final field core::int usageLineLength;
    static field dynamic _redirecting# = <dynamic>[arg::ArgParser::allowAnything];
    constructor _(core::Map<core::String, opt2::Option> options, core::Map<core::String, arg::ArgParser> commands, {core::bool allowTrailingOptions = true, core::int usageLineLength = null}) → void
      : arg::ArgParser::usageLineLength = usageLineLength, arg::ArgParser::_options = options, arg::ArgParser::options = new col::UnmodifiableMapView::•<core::String, opt2::Option>(options), arg::ArgParser::_commands = commands, arg::ArgParser::commands = new col::UnmodifiableMapView::•<core::String, arg::ArgParser>(commands), arg::ArgParser::allowTrailingOptions = !allowTrailingOptions.{core::Object::==}(null) ?{core::bool} allowTrailingOptions : false, super core::Object::•()
      ;
    get allowsAnything() → core::bool
      return false;
    static factory •({core::bool allowTrailingOptions = true, core::int usageLineLength = null}) → arg::ArgParser
      return new arg::ArgParser::_(<core::String, opt2::Option>{}, <core::String, arg::ArgParser>{}, allowTrailingOptions: allowTrailingOptions, usageLineLength: usageLineLength);
    static factory allowAnything() → arg::ArgParser
      let dynamic #redirecting_factory = all::AllowAnythingParser::• in invalid-expression;
    method addCommand(core::String name, [arg::ArgParser parser = null]) → arg::ArgParser {
      if(this.{arg::ArgParser::_commands}.{core::Map::containsKey}(name)) {
        throw new core::ArgumentError::•("Duplicate command \"${name}\".");
      }
      if(parser.{core::Object::==}(null))
        parser = arg::ArgParser::•();
      this.{arg::ArgParser::_commands}.{core::Map::[]=}(name, parser);
      return parser;
    }
    method addFlag(core::String name, {core::String abbr = null, core::String help = null, core::bool defaultsTo = false, core::bool negatable = true, (core::bool) → void callback = null, core::bool hide = false}) → void {
      this.{arg::ArgParser::_addOption}(name, abbr, help, null, null, null, defaultsTo, callback.{core::Object::==}(null) ?{(dynamic) → void} null : (dynamic value) → void => callback.call(value as core::bool), opt2::OptionType::flag, negatable: negatable, hide: hide);
    }
    method addOption(core::String name, {core::String abbr = null, core::String help = null, core::String valueHelp = null, core::Iterable<core::String> allowed = null, core::Map<core::String, core::String> allowedHelp = null, core::String defaultsTo = null, core::Function callback = null, @core::Deprecated::•("Use addMultiOption() instead.") core::bool allowMultiple = false, @core::Deprecated::•("Use addMultiOption() instead.") core::bool splitCommas = null, core::bool hide = false}) → void {
      if(!allowMultiple && !splitCommas.{core::Object::==}(null)) {
        throw new core::ArgumentError::•("splitCommas may not be set if allowMultiple is false.");
      }
      this.{arg::ArgParser::_addOption}(name, abbr, help, valueHelp, allowed, allowedHelp, allowMultiple ?{core::Object} defaultsTo.{core::String::==}(null) ?{core::List<core::String>} <core::String>[] : <core::String>[defaultsTo] : defaultsTo, callback, allowMultiple ?{opt2::OptionType} opt2::OptionType::multiple : opt2::OptionType::single, splitCommas: splitCommas, hide: hide);
    }
    method addMultiOption(core::String name, {core::String abbr = null, core::String help = null, core::String valueHelp = null, core::Iterable<core::String> allowed = null, core::Map<core::String, core::String> allowedHelp = null, core::Iterable<core::String> defaultsTo = null, (core::List<core::String>) → void callback = null, core::bool splitCommas = true, core::bool hide = false}) → void {
      this.{arg::ArgParser::_addOption}(name, abbr, help, valueHelp, allowed, allowedHelp, let final core::List<core::String> #t286 = let final core::Iterable<core::String> #t287 = defaultsTo in #t287.==(null) ?{core::List<core::String>} null : #t287.{core::Iterable::toList}() in #t286.==(null) ?{core::List<core::String>} <core::String>[] : #t286, callback.{core::Object::==}(null) ?{(dynamic) → void} null : (dynamic value) → void => callback.call(value as core::List<core::String>), opt2::OptionType::multiple, splitCommas: splitCommas, hide: hide);
    }
    method _addOption(core::String name, core::String abbr, core::String help, core::String valueHelp, core::Iterable<core::String> allowed, core::Map<core::String, core::String> allowedHelp, dynamic defaultsTo, core::Function callback, opt2::OptionType type, {core::bool negatable = false, core::bool splitCommas = null, core::bool hide = false}) → void {
      if(this.{arg::ArgParser::_options}.{core::Map::containsKey}(name)) {
        throw new core::ArgumentError::•("Duplicate option \"${name}\".");
      }
      if(!abbr.{core::String::==}(null)) {
        opt2::Option existing = this.{arg::ArgParser::findByAbbreviation}(abbr);
        if(!existing.{core::Object::==}(null)) {
          throw new core::ArgumentError::•("Abbreviation \"${abbr}\" is already used by \"${existing.{opt2::Option::name}}\".");
        }
      }
      opt2::Option option = opt2::newOption(name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, negatable: negatable, splitCommas: splitCommas, hide: hide);
      this.{arg::ArgParser::_options}.{core::Map::[]=}(name, option);
      this.{arg::ArgParser::_optionsAndSeparators}.{core::List::add}(option);
    }
    method addSeparator(core::String text) → void {
      this.{arg::ArgParser::_optionsAndSeparators}.{core::List::add}(text);
    }
    method parse(core::Iterable<core::String> args) → arg2::ArgResults
      return new par2::Parser::•(null, this, args.{core::Iterable::toList}()).{par2::Parser::parse}();
    @core::Deprecated::•("Replaced with get usage. getUsage() will be removed in args 1.0")
    method getUsage() → core::String
      return this.{arg::ArgParser::usage};
    get usage() → core::String {
      return new usa::Usage::•(this.{arg::ArgParser::_optionsAndSeparators}, lineLength: this.{arg::ArgParser::usageLineLength}).{usa::Usage::generate}();
    }
    method getDefault(core::String option) → dynamic {
      if(!this.{arg::ArgParser::options}.{core::Map::containsKey}(option)) {
        throw new core::ArgumentError::•("No option named ${option}");
      }
      return this.{arg::ArgParser::options}.{core::Map::[]}(option).{opt2::Option::defaultsTo};
    }
    method findByAbbreviation(core::String abbr) → opt2::Option {
      return this.{arg::ArgParser::options}.{core::Map::values}.{core::Iterable::firstWhere}((opt2::Option option) → core::bool => option.{opt2::Option::abbr}.{core::String::==}(abbr), orElse: () → core::Null => null);
    }
  }
}
library from "package:args/src/arg_parser_exception.dart" as arg3 {
  class ArgParserException extends core::FormatException {
    final field core::List<core::String> commands;
    constructor •(core::String message, [core::Iterable<core::String> commands = null]) → void
      : arg3::ArgParserException::commands = commands.{core::Object::==}(null) ?{core::List<core::String>} const <core::String>[] : core::List::unmodifiable<core::String>(commands), super core::FormatException::•(message)
      ;
  }
}
library from "package:args/src/arg_results.dart" as arg2 {
  import "dart:collection";
  import "package:args/src/arg_parser.dart";
  class ArgResults extends core::Object {
    final field arg::ArgParser _parser;
    final field core::Map<core::String, dynamic> _parsed;
    final field core::String name;
    final field arg2::ArgResults command;
    final field core::List<core::String> rest;
    final field core::List<core::String> arguments;
    constructor _(arg::ArgParser _parser, core::Map<core::String, dynamic> _parsed, core::String name, arg2::ArgResults command, core::List<core::String> rest, core::List<core::String> arguments) → void
      : arg2::ArgResults::_parser = _parser, arg2::ArgResults::_parsed = _parsed, arg2::ArgResults::name = name, arg2::ArgResults::command = command, arg2::ArgResults::rest = new col::UnmodifiableListView::•<core::String>(rest), arg2::ArgResults::arguments = new col::UnmodifiableListView::•<core::String>(arguments), super core::Object::•()
      ;
    operator [](core::String name) → dynamic {
      if(!this.{arg2::ArgResults::_parser}.{arg::ArgParser::options}.{core::Map::containsKey}(name)) {
        throw new core::ArgumentError::•("Could not find an option named \"${name}\".");
      }
      return this.{arg2::ArgResults::_parser}.{arg::ArgParser::options}.{core::Map::[]}(name).{opt2::Option::getOrDefault}(this.{arg2::ArgResults::_parsed}.{core::Map::[]}(name));
    }
    get options() → core::Iterable<core::String> {
      core::Set<core::String> result = col::LinkedHashSet::from<core::String>(this.{arg2::ArgResults::_parsed}.{core::Map::keys});
      this.{arg2::ArgResults::_parser}.{arg::ArgParser::options}.{core::Map::forEach}((core::String name, opt2::Option option) → core::Null {
        if(!option.{opt2::Option::defaultsTo}.{core::Object::==}(null))
          result.{core::Set::add}(name);
      });
      return result;
    }
    method wasParsed(core::String name) → core::bool {
      opt2::Option option = this.{arg2::ArgResults::_parser}.{arg::ArgParser::options}.{core::Map::[]}(name);
      if(option.{core::Object::==}(null)) {
        throw new core::ArgumentError::•("Could not find an option named \"${name}\".");
      }
      return this.{arg2::ArgResults::_parsed}.{core::Map::containsKey}(name);
    }
  }
  static method newArgResults(arg::ArgParser parser, core::Map<core::String, dynamic> parsed, core::String name, arg2::ArgResults command, core::List<core::String> rest, core::List<core::String> arguments) → arg2::ArgResults {
    return new arg2::ArgResults::_(parser, parsed, name, command, rest, arguments);
  }
}
library from "package:args/src/option.dart" as opt2 {
  class Option extends core::Object {
    final field core::String name;
    final field core::String abbr;
    final field core::String help;
    final field core::String valueHelp;
    final field core::List<core::String> allowed;
    final field core::Map<core::String, core::String> allowedHelp;
    final field dynamic defaultsTo;
    final field core::bool negatable;
    final field core::Function callback;
    final field opt2::OptionType type;
    final field core::bool splitCommas;
    final field core::bool hide;
    static final field core::RegExp _invalidChars = core::RegExp::•("[ \\t\\r\\n\"'\\\\/]");
    constructor _(core::String name, core::String abbr, core::String help, core::String valueHelp, core::Iterable<core::String> allowed, core::Map<core::String, core::String> allowedHelp, dynamic defaultsTo, core::Function callback, opt2::OptionType type, {core::bool negatable = null, core::bool splitCommas = null, core::bool hide = false}) → void
      : opt2::Option::name = name, opt2::Option::abbr = abbr, opt2::Option::help = help, opt2::Option::valueHelp = valueHelp, opt2::Option::defaultsTo = defaultsTo, opt2::Option::callback = callback, opt2::Option::negatable = negatable, opt2::Option::hide = hide, opt2::Option::allowed = allowed.{core::Object::==}(null) ?{core::List<core::String>} null : core::List::unmodifiable<core::String>(allowed), opt2::Option::allowedHelp = allowedHelp.{core::Object::==}(null) ?{core::Map<core::String, core::String>} null : core::Map::unmodifiable<core::String, core::String>(allowedHelp), opt2::Option::type = type, opt2::Option::splitCommas = splitCommas.{core::Object::==}(null) ?{core::bool} type.{core::Object::==}(opt2::OptionType::multiple) : splitCommas, super core::Object::•() {
      if(this.{opt2::Option::name}.{core::String::isEmpty}) {
        throw new core::ArgumentError::•("Name cannot be empty.");
      }
      else
        if(this.{opt2::Option::name}.{core::String::startsWith}("-")) {
          throw new core::ArgumentError::•("Name ${this.{opt2::Option::name}} cannot start with \"-\".");
        }
      if(opt2::Option::_invalidChars.{core::RegExp::hasMatch}(this.{opt2::Option::name})) {
        throw new core::ArgumentError::•("Name \"${this.{opt2::Option::name}}\" contains invalid characters.");
      }
      if(!this.{opt2::Option::abbr}.{core::String::==}(null)) {
        if(!this.{opt2::Option::abbr}.{core::String::length}.{core::num::==}(1)) {
          throw new core::ArgumentError::•("Abbreviation must be null or have length 1.");
        }
        else
          if(this.{opt2::Option::abbr}.{core::String::==}("-")) {
            throw new core::ArgumentError::•("Abbreviation cannot be \"-\".");
          }
        if(opt2::Option::_invalidChars.{core::RegExp::hasMatch}(this.{opt2::Option::abbr})) {
          throw new core::ArgumentError::•("Abbreviation is an invalid character.");
        }
      }
    }
    @core::Deprecated::•("Use abbr instead.")
    get abbreviation() → core::String
      return this.{opt2::Option::abbr};
    @core::Deprecated::•("Use defaultsTo instead.")
    get defaultValue() → dynamic
      return this.{opt2::Option::defaultsTo};
    get isFlag() → core::bool
      return this.{opt2::Option::type}.{core::Object::==}(opt2::OptionType::flag);
    get isSingle() → core::bool
      return this.{opt2::Option::type}.{core::Object::==}(opt2::OptionType::single);
    get isMultiple() → core::bool
      return this.{opt2::Option::type}.{core::Object::==}(opt2::OptionType::multiple);
    method getOrDefault(dynamic value) → dynamic {
      if(!value.{core::Object::==}(null))
        return value;
      if(this.{opt2::Option::isMultiple})
        return let final dynamic #t288 = this.{opt2::Option::defaultsTo} in #t288.==(null) ?{dynamic} <core::String>[] : #t288;
      return this.{opt2::Option::defaultsTo};
    }
  }
  class OptionType extends core::Object {
    static const field opt2::OptionType flag = const opt2::OptionType::_("OptionType.flag");
    @core::Deprecated::•("Use OptionType.flag instead.")
    static const field opt2::OptionType FLAG = opt2::OptionType::flag;
    static const field opt2::OptionType single = const opt2::OptionType::_("OptionType.single");
    @core::Deprecated::•("Use OptionType.single instead.")
    static const field opt2::OptionType SINGLE = opt2::OptionType::single;
    static const field opt2::OptionType multiple = const opt2::OptionType::_("OptionType.multiple");
    @core::Deprecated::•("Use OptionType.multiple instead.")
    static const field opt2::OptionType MULTIPLE = opt2::OptionType::multiple;
    final field core::String name;
    const constructor _(core::String name) → void
      : opt2::OptionType::name = name, super core::Object::•()
      ;
  }
  static method newOption(core::String name, core::String abbr, core::String help, core::String valueHelp, core::Iterable<core::String> allowed, core::Map<core::String, core::String> allowedHelp, dynamic defaultsTo, core::Function callback, opt2::OptionType type, {core::bool negatable = null, core::bool splitCommas = null, core::bool hide = false}) → opt2::Option {
    return new opt2::Option::_(name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, negatable: negatable, splitCommas: splitCommas, hide: hide);
  }
}
library from "package:angel_container/src/container.dart" as con {
  import "package:angel_container/src/exception.dart";
  import "package:angel_container/src/reflector.dart";
  class Container extends core::Object {
    final field ref::Reflector reflector;
    final field core::Map<core::Type, dynamic> _singletons = <core::Type, dynamic>{};
    final field core::Map<core::Type, (con::Container) → dynamic> _factories = <core::Type, (con::Container) → dynamic>{};
    final field con::Container _parent;
    constructor •(ref::Reflector reflector) → void
      : con::Container::reflector = reflector, con::Container::_parent = null, super core::Object::•()
      ;
    constructor _child(con::Container _parent) → void
      : con::Container::_parent = _parent, con::Container::reflector = _parent.{con::Container::reflector}, super core::Object::•()
      ;
    get isRoot() → core::bool
      return this.{con::Container::_parent}.{core::Object::==}(null);
    method createChild() → con::Container {
      return new con::Container::_child(this);
    }
    method has<T extends core::Object = dynamic>([core::Type t = null]) → core::bool {
      con::Container search = this;
      t.{core::Object::==}(null) ?{core::Type} t = con::Container::has::T.{core::Object::==}(dynamic) ?{core::Type} t : con::Container::has::T : null;
      while (!search.{core::Object::==}(null)) {
        if(search.{con::Container::_singletons}.{core::Map::containsKey}(t)) {
          return true;
        }
        else
          if(search.{con::Container::_factories}.{core::Map::containsKey}(t)) {
            return true;
          }
          else {
            search = search.{con::Container::_parent};
          }
      }
      return false;
    }
    method make<T extends core::Object = dynamic>([core::Type type = null]) → con::Container::make::T {
      type.{core::Object::==}(null) ?{core::Type} type = con::Container::make::T : null;
      con::Container search = this;
      while (!search.{core::Object::==}(null)) {
        if(search.{con::Container::_singletons}.{core::Map::containsKey}(type)) {
          return search.{con::Container::_singletons}.{core::Map::[]}(type) as con::Container::make::T;
        }
        else
          if(search.{con::Container::_factories}.{core::Map::containsKey}(type)) {
            return search.{con::Container::_factories}.{core::Map::[]}(type).call(this) as con::Container::make::T;
          }
          else {
            search = search.{con::Container::_parent};
          }
      }
      ref::ReflectedType reflectedType = this.{con::Container::reflector}.{ref::Reflector::reflectType}(type);
      core::List<dynamic> positional = <dynamic>[];
      core::Map<core::String, dynamic> named = <core::String, dynamic>{};
      if(reflectedType is ref::ReflectedClass) {
        function isDefault(core::String name) → core::bool {
          return name.{core::String::isEmpty} || name.{core::String::==}(reflectedType{ref::ReflectedClass}.{ref::ReflectedType::name});
        }
        ref::ReflectedFunction constructor = reflectedType{ref::ReflectedClass}.{ref::ReflectedClass::constructors}.{core::Iterable::firstWhere}((ref::ReflectedFunction c) → core::bool => isDefault.call(c.{ref::ReflectedFunction::name}), orElse: () → <BottomType>=> throw new exc::ReflectionException::•("${reflectedType{ref::ReflectedClass}.{ref::ReflectedType::name}} has no default constructor, and therefore cannot be instantiated."));
        for (ref::ReflectedParameter param in constructor.{ref::ReflectedFunction::parameters}) {
          dynamic value = this.{con::Container::make}<dynamic>(param.{ref::ReflectedParameter::type}.{ref::ReflectedType::reflectedType});
          if(param.{ref::ReflectedParameter::isNamed}) {
            named.{core::Map::[]=}(param.{ref::ReflectedParameter::name}, value);
          }
          else {
            positional.{core::List::add}(value);
          }
        }
        return reflectedType{ref::ReflectedClass}.{ref::ReflectedType::newInstance}(isDefault.call(constructor.{ref::ReflectedFunction::name}) ?{core::String} "" : constructor.{ref::ReflectedFunction::name}, positional, named, <core::Type>[]).{ref::ReflectedInstance::reflectee} as{TypeError} con::Container::make::T;
      }
      else {
        throw new exc::ReflectionException::•("${type} is not a class, and therefore cannot be instantiated.");
      }
    }
    method registerFactory<T extends core::Object = dynamic>((con::Container) → con::Container::registerFactory::T f, {core::Type as = null}) → void {
      as.{core::Object::==}(null) ?{core::Type} as = con::Container::registerFactory::T : null;
      if(this.{con::Container::_factories}.{core::Map::containsKey}(as)) {
        throw new core::StateError::•("This container already has a factory for ${as}.");
      }
      this.{con::Container::_factories}.{core::Map::[]=}(as, f);
    }
    method registerSingleton<T extends core::Object = dynamic>(con::Container::registerSingleton::T object, {core::Type as = null}) → void {
      as.{core::Object::==}(null) ?{core::Type} as = con::Container::registerSingleton::T.{core::Object::==}(dynamic) ?{core::Type} as : con::Container::registerSingleton::T : null;
      if(this.{con::Container::_singletons}.{core::Map::containsKey}(let final core::Type #t289 = as in #t289.==(null) ?{core::Type} object.{core::Object::runtimeType} : #t289)) {
        throw new core::StateError::•("This container already has a singleton for ${let final core::Type #t290 = as in #t290.==(null) ?{core::Type} object.{core::Object::runtimeType} : #t290}.");
      }
      this.{con::Container::_singletons}.{core::Map::[]=}(let final core::Type #t291 = as in #t291.==(null) ?{core::Type} object.{core::Object::runtimeType} : #t291, object);
    }
  }
}
library from "package:angel_container/src/empty/empty.dart" as emp {
  import "package:angel_container/angel_container.dart";
  class EmptyReflector extends core::Object implements ref::Reflector {
    static final field core::RegExp symbolRegex = core::RegExp::•("Symbol\\(\"([^\"]+)\"\\)");
    const constructor •() → void
      : super core::Object::•()
      ;
    @core::override
    method getName(core::Symbol symbol) → core::String {
      return emp::_symbolNames.{core::Map::putIfAbsent}(symbol, () → core::String => emp::EmptyReflector::symbolRegex.{core::RegExp::firstMatch}(symbol.{core::Object::toString}()).{core::Match::group}(1));
    }
    @core::override
    method reflectClass(core::Type clazz) → ref::ReflectedClass {
      return const emp::_EmptyReflectedClass::•();
    }
    @core::override
    method reflectInstance(core::Object object) → ref::ReflectedInstance {
      return const emp::_EmptyReflectedInstance::•();
    }
    @core::override
    method reflectType(core::Type type) → ref::ReflectedType {
      return const emp::_EmptyReflectedType::•();
    }
    @core::override
    method reflectFunction(core::Function function) → ref::ReflectedFunction {
      return const emp::_EmptyReflectedFunction::•();
    }
  }
  class _EmptyReflectedClass extends ref::ReflectedClass {
    const constructor •() → void
      : super ref::ReflectedClass::•("(empty)", const <ref::ReflectedTypeParameter>[], const <ref::ReflectedInstance>[], const <ref::ReflectedFunction>[], const <ref::ReflectedDeclaration>[], dynamic)
      ;
    @core::override
    method newInstance(core::String constructorName, core::List<dynamic> positionalArguments, [core::Map<core::String, dynamic> namedArguments = null, core::List<core::Type> typeArguments = null]) → ref::ReflectedInstance {
      throw new core::UnsupportedError::•("Classes reflected via an EmptyReflector cannot be instantiated.");
    }
    @core::override
    method isAssignableTo(ref::ReflectedType other) → core::bool {
      return other.{ref::ReflectedType::==}(this);
    }
    @core::override
    operator ==(dynamic other) → core::bool {
      return other is ref::ReflectedClass && other{ref::ReflectedClass}.{ref::ReflectedClass::hashCode}.{core::num::==}(this.{ref::ReflectedClass::hashCode});
    }
  }
  class _EmptyReflectedType extends ref::ReflectedType {
    const constructor •() → void
      : super ref::ReflectedType::•("(empty)", const <ref::ReflectedTypeParameter>[], dynamic)
      ;
    @core::override
    method newInstance(core::String constructorName, core::List<dynamic> positionalArguments, [core::Map<core::String, dynamic> namedArguments = null, core::List<core::Type> typeArguments = null]) → ref::ReflectedInstance {
      throw new core::UnsupportedError::•("Types reflected via an EmptyReflector cannot be instantiated.");
    }
    @core::override
    method isAssignableTo(ref::ReflectedType other) → core::bool {
      return other.{ref::ReflectedType::==}(this);
    }
    @core::override
    operator ==(dynamic other) → core::bool {
      return other is ref::ReflectedType && other{ref::ReflectedType}.{ref::ReflectedType::hashCode}.{core::num::==}(this.{ref::ReflectedType::hashCode});
    }
  }
  class _EmptyReflectedInstance extends ref::ReflectedInstance {
    const constructor •() → void
      : super ref::ReflectedInstance::•(const emp::_EmptyReflectedType::•(), const emp::_EmptyReflectedClass::•(), null)
      ;
    @core::override
    operator ==(dynamic other) → core::bool {
      return other is ref::ReflectedInstance && other{ref::ReflectedInstance}.{ref::ReflectedInstance::hashCode}.{core::num::==}(this.{ref::ReflectedInstance::hashCode});
    }
    @core::override
    method getField(core::String name) → ref::ReflectedInstance {
      throw new core::UnsupportedError::•("Instances reflected via an EmptyReflector cannot call getField().");
    }
  }
  class _EmptyReflectedFunction extends ref::ReflectedFunction {
    const constructor •() → void
      : super ref::ReflectedFunction::•("(empty)", const <ref::ReflectedTypeParameter>[], const <ref::ReflectedInstance>[], const emp::_EmptyReflectedType::•(), const <ref::ReflectedParameter>[], false, false)
      ;
    @core::override
    method invoke(core::Invocation invocation) → ref::ReflectedInstance {
      throw new core::UnsupportedError::•("Instances reflected via an EmptyReflector cannot call invoke().");
    }
  }
  static final field core::Map<core::Symbol, core::String> _symbolNames = <core::Symbol, core::String>{};
}
library from "package:angel_container/src/exception.dart" as exc {
  class ReflectionException extends core::Object implements core::Exception {
    final field core::String message;
    constructor •(core::String message) → void
      : exc::ReflectionException::message = message, super core::Object::•()
      ;
    @core::override
    method toString() → core::String
      return this.{exc::ReflectionException::message};
  }
}
library from "package:angel_container/src/reflector.dart" as ref {
  import "package:collection/collection.dart";
  import "package:quiver/core.dart";
  abstract class Reflector extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract method getName(core::Symbol symbol) → core::String;
    abstract method reflectClass(core::Type clazz) → ref::ReflectedClass;
    abstract method reflectFunction(core::Function function) → ref::ReflectedFunction;
    abstract method reflectType(core::Type type) → ref::ReflectedType;
    abstract method reflectInstance(core::Object object) → ref::ReflectedInstance;
  }
  abstract class ReflectedInstance extends core::Object {
    final field ref::ReflectedType type;
    final field ref::ReflectedClass clazz;
    final field core::Object reflectee;
    const constructor •(ref::ReflectedType type, ref::ReflectedClass clazz, core::Object reflectee) → void
      : ref::ReflectedInstance::type = type, ref::ReflectedInstance::clazz = clazz, ref::ReflectedInstance::reflectee = reflectee, super core::Object::•()
      ;
    @core::override
    get hashCode() → core::int
      return core3::hash2(this.{ref::ReflectedInstance::type}, this.{ref::ReflectedInstance::clazz});
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ref::ReflectedInstance && other{ref::ReflectedInstance}.{ref::ReflectedInstance::type}.{ref::ReflectedType::==}(this.{ref::ReflectedInstance::type}) && other{ref::ReflectedInstance}.{ref::ReflectedInstance::clazz}.{ref::ReflectedClass::==}(this.{ref::ReflectedInstance::clazz});
    abstract method getField(core::String name) → ref::ReflectedInstance;
  }
  abstract class ReflectedType extends core::Object {
    final field core::String name;
    final field core::List<ref::ReflectedTypeParameter> typeParameters;
    final field core::Type reflectedType;
    const constructor •(core::String name, core::List<ref::ReflectedTypeParameter> typeParameters, core::Type reflectedType) → void
      : ref::ReflectedType::name = name, ref::ReflectedType::typeParameters = typeParameters, ref::ReflectedType::reflectedType = reflectedType, super core::Object::•()
      ;
    @core::override
    get hashCode() → core::int
      return core3::hash3(this.{ref::ReflectedType::name}, this.{ref::ReflectedType::typeParameters}, this.{ref::ReflectedType::reflectedType});
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ref::ReflectedType && other{ref::ReflectedType}.{ref::ReflectedType::name}.{core::String::==}(this.{ref::ReflectedType::name}) && const equ::ListEquality::•<ref::ReflectedTypeParameter>().{equ::ListEquality::equals}(other{ref::ReflectedType}.{ref::ReflectedType::typeParameters}, this.{ref::ReflectedType::typeParameters}) && other{ref::ReflectedType}.{ref::ReflectedType::reflectedType}.{core::Object::==}(this.{ref::ReflectedType::reflectedType});
    abstract method newInstance(core::String constructorName, core::List<dynamic> positionalArguments, [core::Map<core::String, dynamic> namedArguments = null, core::List<core::Type> typeArguments = null]) → ref::ReflectedInstance;
    abstract method isAssignableTo(ref::ReflectedType other) → core::bool;
  }
  abstract class ReflectedClass extends ref::ReflectedType {
    final field core::List<ref::ReflectedInstance> annotations;
    final field core::List<ref::ReflectedFunction> constructors;
    final field core::List<ref::ReflectedDeclaration> declarations;
    const constructor •(core::String name, core::List<ref::ReflectedTypeParameter> typeParameters, core::List<ref::ReflectedInstance> annotations, core::List<ref::ReflectedFunction> constructors, core::List<ref::ReflectedDeclaration> declarations, core::Type reflectedType) → void
      : ref::ReflectedClass::annotations = annotations, ref::ReflectedClass::constructors = constructors, ref::ReflectedClass::declarations = declarations, super ref::ReflectedType::•(name, typeParameters, reflectedType)
      ;
    @core::override
    get hashCode() → core::int
      return core3::hash4(super.{ref::ReflectedType::hashCode}, this.{ref::ReflectedClass::annotations}, this.{ref::ReflectedClass::constructors}, this.{ref::ReflectedClass::declarations});
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ref::ReflectedClass && super.{ref::ReflectedType::==}(other{ref::ReflectedClass}) && const equ::ListEquality::•<ref::ReflectedInstance>().{equ::ListEquality::equals}(other{ref::ReflectedClass}.{ref::ReflectedClass::annotations}, this.{ref::ReflectedClass::annotations}) && const equ::ListEquality::•<ref::ReflectedFunction>().{equ::ListEquality::equals}(other{ref::ReflectedClass}.{ref::ReflectedClass::constructors}, this.{ref::ReflectedClass::constructors}) && const equ::ListEquality::•<ref::ReflectedDeclaration>().{equ::ListEquality::equals}(other{ref::ReflectedClass}.{ref::ReflectedClass::declarations}, this.{ref::ReflectedClass::declarations});
  }
  class ReflectedDeclaration extends core::Object {
    final field core::String name;
    final field core::bool isStatic;
    final field ref::ReflectedFunction function;
    const constructor •(core::String name, core::bool isStatic, ref::ReflectedFunction function) → void
      : ref::ReflectedDeclaration::name = name, ref::ReflectedDeclaration::isStatic = isStatic, ref::ReflectedDeclaration::function = function, super core::Object::•()
      ;
    @core::override
    get hashCode() → core::int
      return core3::hash3(this.{ref::ReflectedDeclaration::name}, this.{ref::ReflectedDeclaration::isStatic}, this.{ref::ReflectedDeclaration::function});
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ref::ReflectedDeclaration && other{ref::ReflectedDeclaration}.{ref::ReflectedDeclaration::name}.{core::String::==}(this.{ref::ReflectedDeclaration::name}) && other{ref::ReflectedDeclaration}.{ref::ReflectedDeclaration::isStatic}.{core::Object::==}(this.{ref::ReflectedDeclaration::isStatic}) && other{ref::ReflectedDeclaration}.{ref::ReflectedDeclaration::function}.{ref::ReflectedFunction::==}(this.{ref::ReflectedDeclaration::function});
  }
  abstract class ReflectedFunction extends core::Object {
    final field core::String name;
    final field core::List<ref::ReflectedTypeParameter> typeParameters;
    final field core::List<ref::ReflectedInstance> annotations;
    final field ref::ReflectedType returnType;
    final field core::List<ref::ReflectedParameter> parameters;
    final field core::bool isGetter;
    final field core::bool isSetter;
    const constructor •(core::String name, core::List<ref::ReflectedTypeParameter> typeParameters, core::List<ref::ReflectedInstance> annotations, ref::ReflectedType returnType, core::List<ref::ReflectedParameter> parameters, core::bool isGetter, core::bool isSetter) → void
      : ref::ReflectedFunction::name = name, ref::ReflectedFunction::typeParameters = typeParameters, ref::ReflectedFunction::annotations = annotations, ref::ReflectedFunction::returnType = returnType, ref::ReflectedFunction::parameters = parameters, ref::ReflectedFunction::isGetter = isGetter, ref::ReflectedFunction::isSetter = isSetter, super core::Object::•()
      ;
    @core::override
    get hashCode() → core::int
      return core3::hashObjects(<dynamic>[this.{ref::ReflectedFunction::name}, this.{ref::ReflectedFunction::typeParameters}, this.{ref::ReflectedFunction::annotations}, this.{ref::ReflectedFunction::returnType}, this.{ref::ReflectedFunction::parameters}, this.{ref::ReflectedFunction::isGetter}, this.{ref::ReflectedFunction::isSetter}]);
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ref::ReflectedFunction && other{ref::ReflectedFunction}.{ref::ReflectedFunction::name}.{core::String::==}(this.{ref::ReflectedFunction::name}) && const equ::ListEquality::•<ref::ReflectedTypeParameter>().{equ::ListEquality::equals}(other{ref::ReflectedFunction}.{ref::ReflectedFunction::typeParameters}, this.{ref::ReflectedFunction::typeParameters}) && const equ::ListEquality::•<ref::ReflectedInstance>().{equ::ListEquality::equals}(other{ref::ReflectedFunction}.{ref::ReflectedFunction::annotations}, this.{ref::ReflectedFunction::annotations}) && other{ref::ReflectedFunction}.{ref::ReflectedFunction::returnType}.{ref::ReflectedType::==}(this.{ref::ReflectedFunction::returnType}) && const equ::ListEquality::•<ref::ReflectedParameter>().{equ::ListEquality::equals}(other{ref::ReflectedFunction}.{ref::ReflectedFunction::parameters}, other{ref::ReflectedFunction}.{ref::ReflectedFunction::parameters}) && other{ref::ReflectedFunction}.{ref::ReflectedFunction::isGetter}.{core::Object::==}(this.{ref::ReflectedFunction::isGetter}) && other{ref::ReflectedFunction}.{ref::ReflectedFunction::isSetter}.{core::Object::==}(this.{ref::ReflectedFunction::isSetter});
    abstract method invoke(core::Invocation invocation) → ref::ReflectedInstance;
  }
  class ReflectedParameter extends core::Object {
    final field core::String name;
    final field core::List<ref::ReflectedInstance> annotations;
    final field ref::ReflectedType type;
    final field core::bool isRequired;
    final field core::bool isNamed;
    const constructor •(core::String name, core::List<ref::ReflectedInstance> annotations, ref::ReflectedType type, core::bool isRequired, core::bool isNamed) → void
      : ref::ReflectedParameter::name = name, ref::ReflectedParameter::annotations = annotations, ref::ReflectedParameter::type = type, ref::ReflectedParameter::isRequired = isRequired, ref::ReflectedParameter::isNamed = isNamed, super core::Object::•()
      ;
    @core::override
    get hashCode() → core::int
      return core3::hashObjects(<dynamic>[this.{ref::ReflectedParameter::name}, this.{ref::ReflectedParameter::annotations}, this.{ref::ReflectedParameter::type}, this.{ref::ReflectedParameter::isRequired}, this.{ref::ReflectedParameter::isNamed}]);
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ref::ReflectedParameter && other{ref::ReflectedParameter}.{ref::ReflectedParameter::name}.{core::String::==}(this.{ref::ReflectedParameter::name}) && const equ::ListEquality::•<ref::ReflectedInstance>().{equ::ListEquality::equals}(other{ref::ReflectedParameter}.{ref::ReflectedParameter::annotations}, this.{ref::ReflectedParameter::annotations}) && other{ref::ReflectedParameter}.{ref::ReflectedParameter::type}.{ref::ReflectedType::==}(this.{ref::ReflectedParameter::type}) && other{ref::ReflectedParameter}.{ref::ReflectedParameter::isRequired}.{core::Object::==}(this.{ref::ReflectedParameter::isRequired}) && other{ref::ReflectedParameter}.{ref::ReflectedParameter::isNamed}.{core::Object::==}(this.{ref::ReflectedParameter::isNamed});
  }
  class ReflectedTypeParameter extends core::Object {
    final field core::String name;
    const constructor •(core::String name) → void
      : ref::ReflectedTypeParameter::name = name, super core::Object::•()
      ;
    @core::override
    get hashCode() → core::int
      return core3::hashObjects(<dynamic>[this.{ref::ReflectedTypeParameter::name}]);
    @core::override
    operator ==(dynamic other) → core::bool
      return other is ref::ReflectedTypeParameter && other{ref::ReflectedTypeParameter}.{ref::ReflectedTypeParameter::name}.{core::String::==}(this.{ref::ReflectedTypeParameter::name});
  }
}
library from "package:io/src/ansi_code.dart" as ans {
  import "dart:async";
  import "dart:io" as io;
  class AnsiCodeType extends core::Object {
    final field core::String _name;
    static const field ans::AnsiCodeType foreground = const ans::AnsiCodeType::_("foreground");
    static const field ans::AnsiCodeType style = const ans::AnsiCodeType::_("style");
    static const field ans::AnsiCodeType background = const ans::AnsiCodeType::_("background");
    static const field ans::AnsiCodeType reset = const ans::AnsiCodeType::_("reset");
    const constructor _(core::String _name) → void
      : ans::AnsiCodeType::_name = _name, super core::Object::•()
      ;
    @core::override
    method toString() → core::String
      return "AnsiType.${this.{ans::AnsiCodeType::_name}}";
  }
  class AnsiCode extends core::Object {
    final field core::int code;
    final field ans::AnsiCode reset;
    final field core::String name;
    final field ans::AnsiCodeType type;
    const constructor _(core::String name, ans::AnsiCodeType type, core::int code, ans::AnsiCode reset) → void
      : ans::AnsiCode::name = name, ans::AnsiCode::type = type, ans::AnsiCode::code = code, ans::AnsiCode::reset = reset, super core::Object::•()
      ;
    get escape() → core::String
      return "${ans::_ansiEscapeLiteral}[${this.{ans::AnsiCode::code}}m";
    get escapeForScript() → core::String
      return "${ans::_ansiEscapeForScript}[${this.{ans::AnsiCode::code}}m";
    method _escapeValue({core::bool forScript = false}) → core::String {
      forScript.{core::Object::==}(null) ?{core::bool} forScript = false : null;
      return forScript ?{core::String} this.{ans::AnsiCode::escapeForScript} : this.{ans::AnsiCode::escape};
    }
    method wrap(core::String value, {core::bool forScript = false}) → core::String
      return ans::_isNoop(this.{ans::AnsiCode::type}.{core::Object::==}(ans::AnsiCodeType::reset), value, forScript) ?{core::String} value : "${this.{ans::AnsiCode::_escapeValue}(forScript: forScript)}${value}${this.{ans::AnsiCode::reset}.{ans::AnsiCode::_escapeValue}(forScript: forScript)}";
    @core::override
    method toString() → core::String
      return "${this.{ans::AnsiCode::name}} ${this.{ans::AnsiCode::type}.{ans::AnsiCodeType::_name}} (${this.{ans::AnsiCode::code}})";
  }
  static const field core::String _ansiEscapeLiteral = "\u0027";
  static const field core::String _ansiEscapeForScript = "\\033";
  static const field ans::AnsiCode styleBold = const ans::AnsiCode::_("bold", ans::AnsiCodeType::style, 1, ans::resetBold);
  static const field ans::AnsiCode styleDim = const ans::AnsiCode::_("dim", ans::AnsiCodeType::style, 2, ans::resetDim);
  static const field ans::AnsiCode styleItalic = const ans::AnsiCode::_("italic", ans::AnsiCodeType::style, 3, ans::resetItalic);
  static const field ans::AnsiCode styleUnderlined = const ans::AnsiCode::_("underlined", ans::AnsiCodeType::style, 4, ans::resetUnderlined);
  static const field ans::AnsiCode styleBlink = const ans::AnsiCode::_("blink", ans::AnsiCodeType::style, 5, ans::resetBlink);
  static const field ans::AnsiCode styleReverse = const ans::AnsiCode::_("reverse", ans::AnsiCodeType::style, 7, ans::resetReverse);
  static const field ans::AnsiCode styleHidden = const ans::AnsiCode::_("hidden", ans::AnsiCodeType::style, 8, ans::resetHidden);
  static const field ans::AnsiCode styleCrossedOut = const ans::AnsiCode::_("crossed out", ans::AnsiCodeType::style, 9, ans::resetCrossedOut);
  static const field ans::AnsiCode resetAll = const ans::AnsiCode::_("all", ans::AnsiCodeType::reset, 0, null);
  static const field ans::AnsiCode resetBold = const ans::AnsiCode::_("bold", ans::AnsiCodeType::reset, 22, null);
  static const field ans::AnsiCode resetDim = const ans::AnsiCode::_("dim", ans::AnsiCodeType::reset, 22, null);
  static const field ans::AnsiCode resetItalic = const ans::AnsiCode::_("italic", ans::AnsiCodeType::reset, 23, null);
  static const field ans::AnsiCode resetUnderlined = const ans::AnsiCode::_("underlined", ans::AnsiCodeType::reset, 24, null);
  static const field ans::AnsiCode resetBlink = const ans::AnsiCode::_("blink", ans::AnsiCodeType::reset, 25, null);
  static const field ans::AnsiCode resetReverse = const ans::AnsiCode::_("reverse", ans::AnsiCodeType::reset, 27, null);
  static const field ans::AnsiCode resetHidden = const ans::AnsiCode::_("hidden", ans::AnsiCodeType::reset, 28, null);
  static const field ans::AnsiCode resetCrossedOut = const ans::AnsiCode::_("crossed out", ans::AnsiCodeType::reset, 29, null);
  static const field ans::AnsiCode black = const ans::AnsiCode::_("black", ans::AnsiCodeType::foreground, 30, ans::resetAll);
  static const field ans::AnsiCode red = const ans::AnsiCode::_("red", ans::AnsiCodeType::foreground, 31, ans::resetAll);
  static const field ans::AnsiCode green = const ans::AnsiCode::_("green", ans::AnsiCodeType::foreground, 32, ans::resetAll);
  static const field ans::AnsiCode yellow = const ans::AnsiCode::_("yellow", ans::AnsiCodeType::foreground, 33, ans::resetAll);
  static const field ans::AnsiCode blue = const ans::AnsiCode::_("blue", ans::AnsiCodeType::foreground, 34, ans::resetAll);
  static const field ans::AnsiCode magenta = const ans::AnsiCode::_("magenta", ans::AnsiCodeType::foreground, 35, ans::resetAll);
  static const field ans::AnsiCode cyan = const ans::AnsiCode::_("cyan", ans::AnsiCodeType::foreground, 36, ans::resetAll);
  static const field ans::AnsiCode lightGray = const ans::AnsiCode::_("light gray", ans::AnsiCodeType::foreground, 37, ans::resetAll);
  static const field ans::AnsiCode defaultForeground = const ans::AnsiCode::_("default", ans::AnsiCodeType::foreground, 39, ans::resetAll);
  static const field ans::AnsiCode darkGray = const ans::AnsiCode::_("dark gray", ans::AnsiCodeType::foreground, 90, ans::resetAll);
  static const field ans::AnsiCode lightRed = const ans::AnsiCode::_("light red", ans::AnsiCodeType::foreground, 91, ans::resetAll);
  static const field ans::AnsiCode lightGreen = const ans::AnsiCode::_("light green", ans::AnsiCodeType::foreground, 92, ans::resetAll);
  static const field ans::AnsiCode lightYellow = const ans::AnsiCode::_("light yellow", ans::AnsiCodeType::foreground, 93, ans::resetAll);
  static const field ans::AnsiCode lightBlue = const ans::AnsiCode::_("light blue", ans::AnsiCodeType::foreground, 94, ans::resetAll);
  static const field ans::AnsiCode lightMagenta = const ans::AnsiCode::_("light magenta", ans::AnsiCodeType::foreground, 95, ans::resetAll);
  static const field ans::AnsiCode lightCyan = const ans::AnsiCode::_("light cyan", ans::AnsiCodeType::foreground, 96, ans::resetAll);
  static const field ans::AnsiCode white = const ans::AnsiCode::_("white", ans::AnsiCodeType::foreground, 97, ans::resetAll);
  static const field ans::AnsiCode backgroundBlack = const ans::AnsiCode::_("black", ans::AnsiCodeType::background, 40, ans::resetAll);
  static const field ans::AnsiCode backgroundRed = const ans::AnsiCode::_("red", ans::AnsiCodeType::background, 41, ans::resetAll);
  static const field ans::AnsiCode backgroundGreen = const ans::AnsiCode::_("green", ans::AnsiCodeType::background, 42, ans::resetAll);
  static const field ans::AnsiCode backgroundYellow = const ans::AnsiCode::_("yellow", ans::AnsiCodeType::background, 43, ans::resetAll);
  static const field ans::AnsiCode backgroundBlue = const ans::AnsiCode::_("blue", ans::AnsiCodeType::background, 44, ans::resetAll);
  static const field ans::AnsiCode backgroundMagenta = const ans::AnsiCode::_("magenta", ans::AnsiCodeType::background, 45, ans::resetAll);
  static const field ans::AnsiCode backgroundCyan = const ans::AnsiCode::_("cyan", ans::AnsiCodeType::background, 46, ans::resetAll);
  static const field ans::AnsiCode backgroundLightGray = const ans::AnsiCode::_("light gray", ans::AnsiCodeType::background, 47, ans::resetAll);
  static const field ans::AnsiCode backgroundDefault = const ans::AnsiCode::_("default", ans::AnsiCodeType::background, 49, ans::resetAll);
  static const field ans::AnsiCode backgroundDarkGray = const ans::AnsiCode::_("dark gray", ans::AnsiCodeType::background, 100, ans::resetAll);
  static const field ans::AnsiCode backgroundLightRed = const ans::AnsiCode::_("light red", ans::AnsiCodeType::background, 101, ans::resetAll);
  static const field ans::AnsiCode backgroundLightGreen = const ans::AnsiCode::_("light green", ans::AnsiCodeType::background, 102, ans::resetAll);
  static const field ans::AnsiCode backgroundLightYellow = const ans::AnsiCode::_("light yellow", ans::AnsiCodeType::background, 103, ans::resetAll);
  static const field ans::AnsiCode backgroundLightBlue = const ans::AnsiCode::_("light blue", ans::AnsiCodeType::background, 104, ans::resetAll);
  static const field ans::AnsiCode backgroundLightMagenta = const ans::AnsiCode::_("light magenta", ans::AnsiCodeType::background, 105, ans::resetAll);
  static const field ans::AnsiCode backgroundLightCyan = const ans::AnsiCode::_("light cyan", ans::AnsiCodeType::background, 106, ans::resetAll);
  static const field ans::AnsiCode backgroundWhite = const ans::AnsiCode::_("white", ans::AnsiCodeType::background, 107, ans::resetAll);
  static const field core::List<ans::AnsiCode> styles = const <ans::AnsiCode>[ans::styleBold, ans::styleDim, ans::styleItalic, ans::styleUnderlined, ans::styleBlink, ans::styleReverse, ans::styleHidden, ans::styleCrossedOut];
  static const field core::List<ans::AnsiCode> foregroundColors = const <ans::AnsiCode>[ans::black, ans::red, ans::green, ans::yellow, ans::blue, ans::magenta, ans::cyan, ans::lightGray, ans::defaultForeground, ans::darkGray, ans::lightRed, ans::lightGreen, ans::lightYellow, ans::lightBlue, ans::lightMagenta, ans::lightCyan, ans::white];
  static const field core::List<ans::AnsiCode> backgroundColors = const <ans::AnsiCode>[ans::backgroundBlack, ans::backgroundRed, ans::backgroundGreen, ans::backgroundYellow, ans::backgroundBlue, ans::backgroundMagenta, ans::backgroundCyan, ans::backgroundLightGray, ans::backgroundDefault, ans::backgroundDarkGray, ans::backgroundLightRed, ans::backgroundLightGreen, ans::backgroundLightYellow, ans::backgroundLightBlue, ans::backgroundLightMagenta, ans::backgroundLightCyan, ans::backgroundWhite];
  static get ansiOutputEnabled() → core::bool
    return let final core::bool #t292 = asy::Zone::current.{asy::Zone::[]}(ans::AnsiCode) as core::bool in #t292.==(null) ?{core::bool} io::stdout.{io::Stdout::supportsAnsiEscapes} && io::stderr.{io::Stdout::supportsAnsiEscapes} : #t292;
  static method _isNoop(core::bool skip, core::String input, core::bool forScript) → core::bool
    return skip || input.{core::String::==}(null) || input.{core::String::isEmpty} || !((let final core::bool #t293 = forScript in #t293.==(null) ?{core::bool} false : #t293) || ans::ansiOutputEnabled);
  static method overrideAnsiOutput<T extends core::Object = dynamic>(core::bool enableAnsiOutput, () → ans::overrideAnsiOutput::T body) → ans::overrideAnsiOutput::T
    return asy::runZoned<ans::overrideAnsiOutput::T>(body, zoneValues: <core::Object, core::Object>{ans::AnsiCode: enableAnsiOutput});
  static method wrapWith(core::String value, core::Iterable<ans::AnsiCode> codes, {core::bool forScript = false}) → core::String {
    forScript.{core::Object::==}(null) ?{core::bool} forScript = false : null;
    final core::Set<ans::AnsiCode> myCodes = codes.{core::Iterable::toSet}();
    if(ans::_isNoop(myCodes.{core::Iterable::isEmpty}, value, forScript)) {
      return value;
    }
    core::int foreground = 0;
    core::int background = 0;
    for (ans::AnsiCode code in myCodes) {
      #L34:
      switch(code.{ans::AnsiCode::type}) {
        #L35:
        case ans::AnsiCodeType::foreground:
          {
            foreground = foreground.{core::num::+}(1);
            if(foreground.{core::num::>}(1)) {
              throw new core::ArgumentError::value(codes, "codes", "Cannot contain more than one foreground color code.");
            }
            break #L34;
          }
        #L36:
        case ans::AnsiCodeType::background:
          {
            background = background.{core::num::+}(1);
            if(background.{core::num::>}(1)) {
              throw new core::ArgumentError::value(codes, "codes", "Cannot contain more than one foreground color code.");
            }
            break #L34;
          }
        #L37:
        case ans::AnsiCodeType::reset:
          {
            throw new core::ArgumentError::value(codes, "codes", "Cannot contain reset codes.");
            break #L34;
          }
      }
    }
    final core::List<core::int> sortedCodes = let final core::List<core::int> #t294 = myCodes.{core::Iterable::map}<core::int>((ans::AnsiCode ac) → core::int => ac.{ans::AnsiCode::code}).{core::Iterable::toList}() in let final dynamic #t295 = #t294.{core::List::sort}() in #t294;
    final core::String escapeValue = forScript ?{core::String} ans::_ansiEscapeForScript : ans::_ansiEscapeLiteral;
    return "${escapeValue}[${sortedCodes.{core::Iterable::join}(";")}m${value}${ans::resetAll.{ans::AnsiCode::_escapeValue}(forScript: forScript)}";
  }
}
library from "package:io/src/copy_path.dart" as cop {
  import "dart:async";
  import "dart:io";
  import "package:path/path.dart" as p;
  static method _doNothing(core::String from, core::String to) → core::bool {
    if(path::canonicalize(from).{core::String::==}(path::canonicalize(to))) {
      return true;
    }
    if(path::isWithin(from, to)) {
      throw new core::ArgumentError::•("Cannot copy from ${from} to ${to}");
    }
    return false;
  }
  static method copyPath(core::String from, core::String to) → asy::Future<core::Null> async {
    if(cop::_doNothing(from, to)) {
      return;
    }
    await io::Directory::•(to).{io::Directory::create}(recursive: true);
    await for (final io::FileSystemEntity file in io::Directory::•(from).{io::Directory::list}(recursive: true)) {
      final core::String copyTo = path::join(to, path::relative(file.{io::FileSystemEntity::path}, from: from));
      if(file is io::Directory) {
        await io::Directory::•(copyTo).{io::Directory::create}(recursive: true);
      }
      else
        if(file is io::File) {
          await io::File::•(file{io::File}.{io::File::path}).{io::File::copy}(copyTo);
        }
        else
          if(file is io::Link) {
            await io::Link::•(copyTo).{io::Link::create}(await file{io::Link}.{io::Link::target}(), recursive: true);
          }
    }
  }
  static method copyPathSync(core::String from, core::String to) → void {
    if(cop::_doNothing(from, to)) {
      return;
    }
    io::Directory::•(to).{io::Directory::createSync}(recursive: true);
    for (final io::FileSystemEntity file in io::Directory::•(from).{io::Directory::listSync}(recursive: true)) {
      final core::String copyTo = path::join(to, path::relative(file.{io::FileSystemEntity::path}, from: from));
      if(file is io::Directory) {
        io::Directory::•(copyTo).{io::Directory::createSync}(recursive: true);
      }
      else
        if(file is io::File) {
          io::File::•(file{io::File}.{io::File::path}).{io::File::copySync}(copyTo);
        }
        else
          if(file is io::Link) {
            io::Link::•(copyTo).{io::Link::createSync}(file{io::Link}.{io::Link::targetSync}(), recursive: true);
          }
    }
  }
}
library from "package:io/src/exit_code.dart" as exi {
  class ExitCode extends core::Object {
    static const field exi::ExitCode success = const exi::ExitCode::_(0, "success");
    static const field exi::ExitCode usage = const exi::ExitCode::_(64, "usage");
    static const field exi::ExitCode data = const exi::ExitCode::_(65, "data");
    static const field exi::ExitCode noInput = const exi::ExitCode::_(66, "noInput");
    static const field exi::ExitCode noUser = const exi::ExitCode::_(67, "noUser");
    static const field exi::ExitCode noHost = const exi::ExitCode::_(68, "noHost");
    static const field exi::ExitCode unavailable = const exi::ExitCode::_(69, "unavailable");
    static const field exi::ExitCode software = const exi::ExitCode::_(70, "software");
    static const field exi::ExitCode osError = const exi::ExitCode::_(71, "osError");
    static const field exi::ExitCode osFile = const exi::ExitCode::_(72, "osFile");
    static const field exi::ExitCode cantCreate = const exi::ExitCode::_(73, "cantCreate");
    static const field exi::ExitCode ioError = const exi::ExitCode::_(74, "ioError");
    static const field exi::ExitCode tempFail = const exi::ExitCode::_(75, "tempFail");
    static const field exi::ExitCode noPerm = const exi::ExitCode::_(77, "noPerm");
    static const field exi::ExitCode config = const exi::ExitCode::_(78, "config");
    final field core::int code;
    final field core::String _name;
    const constructor _(core::int code, core::String _name) → void
      : exi::ExitCode::code = code, exi::ExitCode::_name = _name, super core::Object::•()
      ;
    @core::override
    method toString() → core::String
      return "${this.{exi::ExitCode::_name}}: ${this.{exi::ExitCode::code}}";
  }
}
library from "package:io/src/permissions.dart" as per {
  import "dart:async";
  import "dart:io";
  class _FilePermission extends core::Object {
    final field core::int index;
    final field core::String _name;
    static const field core::List<per::_FilePermission> values = const <per::_FilePermission>[per::_FilePermission::execute, per::_FilePermission::write, per::_FilePermission::read, per::_FilePermission::setGid, per::_FilePermission::setUid, per::_FilePermission::sticky];
    static const field per::_FilePermission execute = const per::_FilePermission::•(0, "_FilePermission.execute");
    static const field per::_FilePermission write = const per::_FilePermission::•(1, "_FilePermission.write");
    static const field per::_FilePermission read = const per::_FilePermission::•(2, "_FilePermission.read");
    static const field per::_FilePermission setGid = const per::_FilePermission::•(3, "_FilePermission.setGid");
    static const field per::_FilePermission setUid = const per::_FilePermission::•(4, "_FilePermission.setUid");
    static const field per::_FilePermission sticky = const per::_FilePermission::•(5, "_FilePermission.sticky");
    const constructor •(core::int index, core::String _name) → void
      : per::_FilePermission::index = index, per::_FilePermission::_name = _name, super core::Object::•()
      ;
    method toString() → core::String
      return this.{=per::_FilePermission::_name};
  }
  class _FilePermissionRole extends core::Object {
    final field core::int index;
    final field core::String _name;
    static const field core::List<per::_FilePermissionRole> values = const <per::_FilePermissionRole>[per::_FilePermissionRole::world, per::_FilePermissionRole::group, per::_FilePermissionRole::user];
    static const field per::_FilePermissionRole world = const per::_FilePermissionRole::•(0, "_FilePermissionRole.world");
    static const field per::_FilePermissionRole group = const per::_FilePermissionRole::•(1, "_FilePermissionRole.group");
    static const field per::_FilePermissionRole user = const per::_FilePermissionRole::•(2, "_FilePermissionRole.user");
    const constructor •(core::int index, core::String _name) → void
      : per::_FilePermissionRole::index = index, per::_FilePermissionRole::_name = _name, super core::Object::•()
      ;
    method toString() → core::String
      return this.{=per::_FilePermissionRole::_name};
  }
  static method _hasPermission(io::FileStat stat, per::_FilePermission permission, {per::_FilePermissionRole role = per::_FilePermissionRole::world}) → core::bool {
    final core::int index = per::_permissionBitIndex(permission, role);
    return !stat.{io::FileStat::mode}.{core::int::&}(1.{core::int::<<}(index)).{core::num::==}(0);
  }
  static method _permissionBitIndex(per::_FilePermission permission, per::_FilePermissionRole role) → core::int {
    switch(permission) {
      #L38:
      case per::_FilePermission::setUid:
        {
          return 11;
        }
      #L39:
      case per::_FilePermission::setGid:
        {
          return 10;
        }
      #L40:
      case per::_FilePermission::sticky:
        {
          return 9;
        }
      #L41:
      default:
        {
          return role.{per::_FilePermissionRole::index}.{core::num::*}(3).{core::num::+}(permission.{per::_FilePermission::index});
        }
    }
  }
  static method isExecutable(core::String path, {core::bool isWindows = null, (core::String) → asy::FutureOr<io::FileStat> getStat = io::FileStat::stat}) → asy::FutureOr<core::bool> {
    if(let final core::bool #t296 = isWindows in #t296.==(null) ?{core::bool} io::Platform::isWindows : #t296)
      return true;
    final asy::FutureOr<io::FileStat> stat = getStat.call(path);
    if(stat is io::FileStat) {
      return per::_isExecutable(stat{io::FileStat});
    }
    return (stat as asy::Future<io::FileStat>).{asy::Future::then}<core::bool>(per::_isExecutable);
  }
  static method _isExecutable(io::FileStat stat) → core::bool
    return stat.{io::FileStat::type}.{core::Object::==}(io::FileSystemEntityType::file) && per::_FilePermissionRole::values.{core::Iterable::any}((per::_FilePermissionRole role) → core::bool => per::_hasPermission(stat, per::_FilePermission::execute, role: role));
}
library from "package:io/src/process_manager.dart" as pro2 {
  import "dart:async";
  import "dart:io" as io;
  import "package:meta/meta.dart";
  import "package:io/src/shared_stdin.dart";
  typedef StartProcess = (core::String, core::List<core::String>, {environment: core::Map<core::String, core::String>, includeParentEnvironment: core::bool, mode: io::ProcessStartMode, runInShell: core::bool, workingDirectory: core::String}) → asy::Future<io::Process>;
  abstract class ProcessManager extends core::Object {
    final field asy::Stream<core::List<core::int>> _stdin;
    final field io::IOSink _stdout;
    final field io::IOSink _stderr;
    const constructor _(asy::Stream<core::List<core::int>> _stdin, io::IOSink _stdout, io::IOSink _stderr) → void
      : pro2::ProcessManager::_stdin = _stdin, pro2::ProcessManager::_stdout = _stdout, pro2::ProcessManager::_stderr = _stderr, super core::Object::•()
      ;
    static method terminateStdIn() → asy::Future<core::Null> async {
      await sha2::sharedStdIn.{sha2::SharedStdIn::terminate}();
    }
    static factory •({asy::Stream<core::List<core::int>> stdin = null, io::IOSink stdout = null, io::IOSink stderr = null, core::bool isWindows = null}) → pro2::ProcessManager {
      stdin.{core::Object::==}(null) ?{asy::Stream<core::List<core::int>>} stdin = sha2::sharedStdIn : null;
      stdout.{core::Object::==}(null) ?{io::IOSink} stdout = io::stdout : null;
      stderr.{core::Object::==}(null) ?{io::IOSink} stderr = io::stderr : null;
      isWindows.{core::Object::==}(null) ?{core::bool} isWindows = io::Platform::isWindows : null;
      if(isWindows) {
        return new pro2::_WindowsProcessManager::•(stdin, stdout, stderr);
      }
      return new pro2::_UnixProcessManager::•(stdin, stdout, stderr);
    }
    method spawn(core::String executable, core::Iterable<core::String> arguments, {core::String workingDirectory = null, core::Map<core::String, core::String> environment = null, core::bool includeParentEnvironment = true, core::bool runInShell = false, io::ProcessStartMode mode = io::ProcessStartMode::normal}) → asy::Future<io::Process> async {
      final asy::Future<io::Process> process = io::Process::start(executable, arguments.{core::Iterable::toList}(), workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, mode: mode);
      return pro2::_ForwardingSpawn::•(await process, this.{pro2::ProcessManager::_stdin}, this.{pro2::ProcessManager::_stdout}, this.{pro2::ProcessManager::_stderr});
    }
    method spawnBackground(core::String executable, core::Iterable<core::String> arguments, {core::String workingDirectory = null, core::Map<core::String, core::String> environment = null, core::bool includeParentEnvironment = true, core::bool runInShell = false, io::ProcessStartMode mode = io::ProcessStartMode::normal}) → asy::Future<io::Process> async {
      final asy::Future<io::Process> process = io::Process::start(executable, arguments.{core::Iterable::toList}(), workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, mode: mode);
      return pro2::_ForwardingSpawn::•(await process, const asy::_EmptyStream::•<core::List<core::int>>(), this.{pro2::ProcessManager::_stdout}, this.{pro2::ProcessManager::_stderr});
    }
    method spawnDetached(core::String executable, core::Iterable<core::String> arguments, {core::String workingDirectory = null, core::Map<core::String, core::String> environment = null, core::bool includeParentEnvironment = true, core::bool runInShell = false, io::ProcessStartMode mode = io::ProcessStartMode::normal}) → asy::Future<io::Process> async {
      return io::Process::start(executable, arguments.{core::Iterable::toList}(), workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, mode: mode);
    }
  }
  class Spawn extends core::Object implements io::Process {
    final field io::Process _delegate;
    constructor _(io::Process _delegate) → void
      : pro2::Spawn::_delegate = _delegate, super core::Object::•() {
      this.{pro2::Spawn::_delegate}.{io::Process::exitCode}.{asy::Future::then}<void>((core::int _) → void => this.{pro2::Spawn::_onClosed}());
    }
    @meta::mustCallSuper
    method _onClosed() → void {}
    @core::override
    method kill([io::ProcessSignal signal = io::ProcessSignal::sigterm]) → core::bool
      return this.{pro2::Spawn::_delegate}.{io::Process::kill}(signal);
    @core::override
    get exitCode() → asy::Future<core::int>
      return this.{pro2::Spawn::_delegate}.{io::Process::exitCode};
    @core::override
    get pid() → core::int
      return this.{pro2::Spawn::_delegate}.{io::Process::pid};
    @core::override
    get stderr() → asy::Stream<core::List<core::int>>
      return this.{pro2::Spawn::_delegate}.{io::Process::stderr};
    @core::override
    get stdin() → io::IOSink
      return this.{pro2::Spawn::_delegate}.{io::Process::stdin};
    @core::override
    get stdout() → asy::Stream<core::List<core::int>>
      return this.{pro2::Spawn::_delegate}.{io::Process::stdout};
  }
  class _ForwardingSpawn extends pro2::Spawn {
    final field asy::StreamSubscription<dynamic> _stdInSub;
    final field asy::StreamSubscription<dynamic> _stdOutSub;
    final field asy::StreamSubscription<dynamic> _stdErrSub;
    final field asy::StreamController<core::List<core::int>> _stdOut;
    final field asy::StreamController<core::List<core::int>> _stdErr;
    constructor _delegate(io::Process delegate, asy::StreamSubscription<dynamic> _stdInSub, asy::StreamSubscription<dynamic> _stdOutSub, asy::StreamSubscription<dynamic> _stdErrSub, asy::StreamController<core::List<core::int>> _stdOut, asy::StreamController<core::List<core::int>> _stdErr) → void
      : pro2::_ForwardingSpawn::_stdInSub = _stdInSub, pro2::_ForwardingSpawn::_stdOutSub = _stdOutSub, pro2::_ForwardingSpawn::_stdErrSub = _stdErrSub, pro2::_ForwardingSpawn::_stdOut = _stdOut, pro2::_ForwardingSpawn::_stdErr = _stdErr, super pro2::Spawn::_(delegate)
      ;
    static factory •(io::Process delegate, asy::Stream<core::List<core::int>> stdin, io::IOSink stdout, io::IOSink stderr) → pro2::_ForwardingSpawn {
      final asy::StreamController<core::List<core::int>> stdoutSelf = asy::StreamController::•<core::List<core::int>>();
      final asy::StreamController<core::List<core::int>> stderrSelf = asy::StreamController::•<core::List<core::int>>();
      final asy::StreamSubscription<core::List<core::int>> stdInSub = stdin.{asy::Stream::listen}(delegate.{io::Process::stdin}.{io::IOSink::add});
      final asy::StreamSubscription<core::List<core::int>> stdOutSub = delegate.{io::Process::stdout}.{asy::Stream::listen}((core::List<core::int> event) → core::Null {
        stdout.{io::IOSink::add}(event);
        stdoutSelf.{asy::StreamController::add}(event);
      });
      final asy::StreamSubscription<core::List<core::int>> stdErrSub = delegate.{io::Process::stderr}.{asy::Stream::listen}((core::List<core::int> event) → core::Null {
        stderr.{io::IOSink::add}(event);
        stderrSelf.{asy::StreamController::add}(event);
      });
      return new pro2::_ForwardingSpawn::_delegate(delegate, stdInSub, stdOutSub, stdErrSub, stdoutSelf, stderrSelf);
    }
    @core::override
    method _onClosed() → void {
      this.{pro2::_ForwardingSpawn::_stdInSub}.{asy::StreamSubscription::cancel}();
      this.{pro2::_ForwardingSpawn::_stdOutSub}.{asy::StreamSubscription::cancel}();
      this.{pro2::_ForwardingSpawn::_stdErrSub}.{asy::StreamSubscription::cancel}();
      super.{pro2::Spawn::_onClosed}();
    }
    @core::override
    get stdout() → asy::Stream<core::List<core::int>>
      return this.{pro2::_ForwardingSpawn::_stdOut}.{asy::StreamController::stream};
    @core::override
    get stderr() → asy::Stream<core::List<core::int>>
      return this.{pro2::_ForwardingSpawn::_stdErr}.{asy::StreamController::stream};
  }
  class _UnixProcessManager extends pro2::ProcessManager {
    const constructor •(asy::Stream<core::List<core::int>> stdin, io::IOSink stdout, io::IOSink stderr) → void
      : super pro2::ProcessManager::_(stdin, stdout, stderr)
      ;
  }
  class _WindowsProcessManager extends pro2::ProcessManager {
    const constructor •(asy::Stream<core::List<core::int>> stdin, io::IOSink stdout, io::IOSink stderr) → void
      : super pro2::ProcessManager::_(stdin, stdout, stderr)
      ;
  }
}
library from "package:io/src/shared_stdin.dart" as sha2 {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:meta/meta.dart";
  @meta::visibleForTesting
  class SharedStdIn extends asy::Stream<core::List<core::int>> {
    field asy::StreamController<core::List<core::int>> _current = null;
    field asy::StreamSubscription<core::List<core::int>> _sub = null;
    constructor •([asy::Stream<core::List<core::int>> stream = null]) → void
      : super asy::Stream::•() {
      this.{sha2::SharedStdIn::_sub} = (let final asy::Stream<core::List<core::int>> #t297 = stream in #t297.{core::Object::==}(null) ?{asy::Stream<core::List<core::int>>} stream = io::stdin : #t297).{asy::Stream::listen}(this.{sha2::SharedStdIn::_onInput});
    }
    method nextLine({con2::Encoding encoding = io::systemEncoding}) → asy::Future<core::String> {
      return this.{sha2::SharedStdIn::lines}(encoding: encoding).{asy::Stream::first};
    }
    method lines({con2::Encoding encoding = io::systemEncoding}) → asy::Stream<core::String> {
      return this.{asy::Stream::transform}<core::String>(con2::utf8.{con2::Utf8Codec::decoder}).{asy::Stream::transform}<core::String>(const con2::LineSplitter::•());
    }
    method _onInput(core::List<core::int> event) → void
      return this.{sha2::SharedStdIn::_getCurrent}().{asy::StreamController::add}(event);
    method _getCurrent() → asy::StreamController<core::List<core::int>> {
      if(this.{sha2::SharedStdIn::_current}.{core::Object::==}(null)) {
        this.{sha2::SharedStdIn::_current} = asy::StreamController::•<core::List<core::int>>(onCancel: () → core::Null {
          this.{sha2::SharedStdIn::_current} = null;
        }, sync: true);
      }
      return this.{sha2::SharedStdIn::_current};
    }
    @core::override
    method listen((core::List<core::int>) → void onData, {core::Function onError = null, () → void onDone = null, core::bool cancelOnError = null}) → asy::StreamSubscription<core::List<core::int>> {
      if(this.{sha2::SharedStdIn::_sub}.{core::Object::==}(null)) {
        throw new core::StateError::•("Stdin has already been terminated.");
      }
      final asy::StreamController<core::List<core::int>> controller = this.{sha2::SharedStdIn::_getCurrent}();
      if(controller.{asy::StreamController::hasListener}) {
        throw new core::StateError::•("Subscriber already listening. The existing subscriber must cancel before another may be added.");
      }
      return controller.{asy::StreamController::stream}.{asy::Stream::listen}(onData, onDone: onDone, onError: onError, cancelOnError: cancelOnError);
    }
    method terminate() → asy::Future<core::Null> async {
      if(this.{sha2::SharedStdIn::_sub}.{core::Object::==}(null)) {
        throw new core::StateError::•("Stdin has already been terminated.");
      }
      await this.{sha2::SharedStdIn::_sub}.{asy::StreamSubscription::cancel}();
      await let final asy::StreamController<core::List<core::int>> #t298 = this.{sha2::SharedStdIn::_current} in #t298.==(null) ?{asy::Future<dynamic>} null : #t298.{asy::StreamController::close}();
      this.{sha2::SharedStdIn::_sub} = null;
    }
  }
  static final field sha2::SharedStdIn sharedStdIn = new sha2::SharedStdIn::•(io::stdin);
}
library from "package:io/src/shell_words.dart" as she {
  import "package:charcode/charcode.dart";
  import "package:string_scanner/string_scanner.dart";
  static method shellSplit(core::String command) → core::List<core::String> {
    final str::StringScanner scanner = new str::StringScanner::•(command);
    final core::List<core::String> results = <core::String>[];
    final core::StringBuffer token = new core::StringBuffer::•();
    core::bool hasToken = false;
    while (!scanner.{str::StringScanner::isDone}) {
      final core::int next = scanner.{str::StringScanner::readChar}();
      #L42:
      switch(next) {
        #L43:
        case dol::$backslash:
          {
            if(scanner.{str::StringScanner::scanChar}(dol::$lf))
              break #L42;
            hasToken = true;
            token.{core::StringBuffer::writeCharCode}(scanner.{str::StringScanner::readChar}());
            break #L42;
          }
        #L44:
        case dol::$single_quote:
          {
            hasToken = true;
            final core::int firstQuote = scanner.{str::StringScanner::position}.{core::num::-}(1);
            while (!scanner.{str::StringScanner::scanChar}(dol::$single_quote)) {
              she::_checkUnmatchedQuote(scanner, firstQuote);
              token.{core::StringBuffer::writeCharCode}(scanner.{str::StringScanner::readChar}());
            }
            break #L42;
          }
        #L45:
        case dol::$double_quote:
          {
            hasToken = true;
            final core::int firstQuote = scanner.{str::StringScanner::position}.{core::num::-}(1);
            while (!scanner.{str::StringScanner::scanChar}(dol::$double_quote))
              #L46:
              {
                she::_checkUnmatchedQuote(scanner, firstQuote);
                if(scanner.{str::StringScanner::scanChar}(dol::$backslash)) {
                  she::_checkUnmatchedQuote(scanner, firstQuote);
                  final core::int next = scanner.{str::StringScanner::readChar}();
                  if(next.{core::num::==}(dol::$lf))
                    break #L46;
                  if(next.{core::num::==}(dol::$dollar) || next.{core::num::==}(dol::$backquote) || next.{core::num::==}(dol::$double_quote) || next.{core::num::==}(dol::$backslash)) {
                    token.{core::StringBuffer::writeCharCode}(next);
                  }
                  else {
                    let final core::StringBuffer #t299 = token in let final dynamic #t300 = #t299.{core::StringBuffer::writeCharCode}(dol::$backslash) in let final dynamic #t301 = #t299.{core::StringBuffer::writeCharCode}(next) in #t299;
                  }
                }
                else {
                  token.{core::StringBuffer::writeCharCode}(scanner.{str::StringScanner::readChar}());
                }
              }
            break #L42;
          }
        #L47:
        case dol::$hash:
          {
            if(hasToken) {
              token.{core::StringBuffer::writeCharCode}(dol::$hash);
              break #L42;
            }
            while (!scanner.{str::StringScanner::isDone} && !scanner.{str::StringScanner::peekChar}().{core::num::==}(dol::$lf)) {
              scanner.{str::StringScanner::readChar}();
            }
            break #L42;
          }
        #L48:
        case dol::$space:
        case dol::$tab:
        case dol::$lf:
          {
            if(hasToken)
              results.{core::List::add}(token.{core::StringBuffer::toString}());
            hasToken = false;
            token.{core::StringBuffer::clear}();
            break #L42;
          }
        #L49:
        default:
          {
            hasToken = true;
            token.{core::StringBuffer::writeCharCode}(next);
            break #L42;
          }
      }
    }
    if(hasToken)
      results.{core::List::add}(token.{core::StringBuffer::toString}());
    return results;
  }
  static method _checkUnmatchedQuote(str::StringScanner scanner, core::int openingQuote) → void {
    if(!scanner.{str::StringScanner::isDone})
      return;
    final core::String type = scanner.{str::StringScanner::substring}(openingQuote, openingQuote.{core::num::+}(1)).{core::String::==}("\"") ?{core::String} "double" : "single";
    scanner.{str::StringScanner::error}("Unmatched ${type} quote.", position: openingQuote, length: 1);
  }
}
library from "package:pub_sub/src/isolate/client.dart" as cli3 {
  import "dart:async";
  import "dart:collection";
  import "dart:isolate";
  import "package:uuid/uuid.dart";
  import "package:pub_sub/pub_sub.dart";
  class IsolateClient extends cli::Client {
    final field col::Queue<asy::Completer<core::String>> _onConnect = new col::ListQueue::•<asy::Completer<core::String>>();
    final field core::Map<core::String, asy::Completer<core::Map<dynamic, dynamic>>> _requests = <core::String, asy::Completer<core::Map<dynamic, dynamic>>>{};
    final field core::List<cli3::_IsolateClientSubscription> _subscriptions = <cli3::_IsolateClientSubscription>[];
    final field Uuid::Uuid _uuid = new Uuid::Uuid::•();
    field core::String _id = null;
    final field core::String clientId;
    final field iso::SendPort serverSendPort;
    final field iso::ReceivePort receivePort = new iso::_ReceivePort::•();
    constructor •(core::String clientId, iso::SendPort serverSendPort) → void
      : cli3::IsolateClient::clientId = clientId, cli3::IsolateClient::serverSendPort = serverSendPort, super cli::Client::•() {
      this.{cli3::IsolateClient::receivePort}.{iso::ReceivePort::listen}((dynamic data) → core::Null {
        if(data is core::Map<dynamic, dynamic> && data{core::Map<dynamic, dynamic>}.{core::Map::[]}("request_id") is core::String) {
          core::String requestId = data{core::Map<dynamic, dynamic>}.{core::Map::[]}("request_id") as core::String;
          asy::Completer<core::Map<dynamic, dynamic>> c = this.{cli3::IsolateClient::_requests}.{core::Map::remove}(requestId);
          if(!c.{core::Object::==}(null) && !c.{asy::Completer::isCompleted}) {
            if(!(data{core::Map<dynamic, dynamic>}.{core::Map::[]}("status") is core::bool)) {
              c.{asy::Completer::completeError}(new core::FormatException::•("The server sent an invalid response."));
            }
            else
              if(!(data{core::Map<dynamic, dynamic>}.{core::Map::[]}("status") as core::bool)) {
                c.{asy::Completer::completeError}(new cli::PubSubException::•(let final core::String #t302 = let final dynamic #t303 = data{core::Map<dynamic, dynamic>}.{core::Map::[]}("error_message") in #t303.==(null) ?{core::String} null : #t303.{core::Object::toString}() in #t302.==(null) ?{core::String} "The server sent a failure response, but did not provide an error message." : #t302));
              }
              else
                if(!(data{core::Map<dynamic, dynamic>}.{core::Map::[]}("result") is core::Map<dynamic, dynamic>)) {
                  c.{asy::Completer::completeError}(new core::FormatException::•("The server sent a success response, but did not include a result."));
                }
                else {
                  c.{asy::Completer::complete}(data{core::Map<dynamic, dynamic>}.{core::Map::[]}("result") as core::Map<dynamic, dynamic>);
                }
          }
        }
        else
          if(data is core::Map<dynamic, dynamic> && data{core::Map<dynamic, dynamic>}.{core::Map::[]}("id") is core::String && this.{cli3::IsolateClient::_id}.{core::String::==}(null)) {
            this.{cli3::IsolateClient::_id} = data{core::Map<dynamic, dynamic>}.{core::Map::[]}("id") as core::String;
            for (asy::Completer<core::String> c in this.{cli3::IsolateClient::_onConnect}) {
              if(!c.{asy::Completer::isCompleted})
                c.{asy::Completer::complete}(this.{cli3::IsolateClient::_id});
            }
            this.{cli3::IsolateClient::_onConnect}.{col::Queue::clear}();
          }
          else
            if(data is core::List<dynamic> && data{core::List<dynamic>}.{core::List::length}.{core::num::==}(2) && data{core::List<dynamic>}.{core::List::[]}(0) is core::String) {
              core::String eventName = data{core::List<dynamic>}.{core::List::[]}(0) as core::String;
              dynamic event = data{core::List<dynamic>}.{core::List::[]}(1);
              for (cli3::_IsolateClientSubscription s in this.{cli3::IsolateClient::_subscriptions}.{core::Iterable::where}((cli3::_IsolateClientSubscription s) → core::bool => s.{cli3::_IsolateClientSubscription::eventName}.{core::String::==}(eventName))) {
                if(!s.{cli3::_IsolateClientSubscription::_stream}.{asy::StreamController::isClosed})
                  s.{cli3::_IsolateClientSubscription::_stream}.{asy::StreamController::add}(event);
              }
            }
      });
      this.{cli3::IsolateClient::serverSendPort}.{iso::SendPort::send}(this.{cli3::IsolateClient::receivePort}.{iso::ReceivePort::sendPort});
    }
    method _whenConnected<T extends core::Object = dynamic>(() → asy::FutureOr<cli3::IsolateClient::_whenConnected::T> callback) → asy::Future<cli3::IsolateClient::_whenConnected::T> {
      if(!this.{cli3::IsolateClient::_id}.{core::String::==}(null))
        return asy::Future::sync<cli3::IsolateClient::_whenConnected::T>(callback);
      else {
        asy::Completer<core::String> c = asy::Completer::•<core::String>();
        this.{cli3::IsolateClient::_onConnect}.{col::Queue::add}(c);
        return c.{asy::Completer::future}.{asy::Future::then}<cli3::IsolateClient::_whenConnected::T>((core::String _) → asy::FutureOr<cli3::IsolateClient::_whenConnected::T> => callback.call());
      }
    }
    @core::override
    method publish(core::String eventName, dynamic value) → asy::Future<dynamic> {
      return this.{cli3::IsolateClient::_whenConnected}<dynamic>(() → asy::Future<core::Map<dynamic, dynamic>> {
        asy::Completer<core::Map<dynamic, dynamic>> c = asy::Completer::•<core::Map<dynamic, dynamic>>();
        core::String requestId = this.{cli3::IsolateClient::_uuid}.{Uuid::Uuid::v4}() as core::String;
        this.{cli3::IsolateClient::_requests}.{core::Map::[]=}(requestId, c);
        this.{cli3::IsolateClient::serverSendPort}.{iso::SendPort::send}(<core::String, core::Object>{"id": this.{cli3::IsolateClient::_id}, "request_id": requestId, "method": "publish", "params": <core::String, dynamic>{"client_id": this.{cli3::IsolateClient::clientId}, "event_name": eventName, "value": value}});
        return c.{asy::Completer::future};
      });
    }
    @core::override
    method subscribe(core::String eventName) → asy::Future<cli::ClientSubscription> {
      return this.{cli3::IsolateClient::_whenConnected}<cli::ClientSubscription>(() → asy::Future<cli::ClientSubscription> {
        asy::Completer<core::Map<dynamic, dynamic>> c = asy::Completer::•<core::Map<dynamic, dynamic>>();
        core::String requestId = this.{cli3::IsolateClient::_uuid}.{Uuid::Uuid::v4}() as core::String;
        this.{cli3::IsolateClient::_requests}.{core::Map::[]=}(requestId, c);
        this.{cli3::IsolateClient::serverSendPort}.{iso::SendPort::send}(<core::String, core::Object>{"id": this.{cli3::IsolateClient::_id}, "request_id": requestId, "method": "subscribe", "params": <core::String, core::String>{"client_id": this.{cli3::IsolateClient::clientId}, "event_name": eventName}});
        return c.{asy::Completer::future}.{asy::Future::then}<cli::ClientSubscription>((core::Map<dynamic, dynamic> result) → cli3::_IsolateClientSubscription {
          cli3::_IsolateClientSubscription s = new cli3::_IsolateClientSubscription::•(eventName, result.{core::Map::[]}("subscription_id") as core::String, this);
          this.{cli3::IsolateClient::_subscriptions}.{core::List::add}(s);
          return s;
        });
      });
    }
    @core::override
    method close() → asy::Future<dynamic> {
      this.{cli3::IsolateClient::receivePort}.{iso::ReceivePort::close}();
      for (asy::Completer<core::String> c in this.{cli3::IsolateClient::_onConnect}) {
        if(!c.{asy::Completer::isCompleted}) {
          c.{asy::Completer::completeError}(new core::StateError::•("The client was closed before the server ever accepted the connection."));
        }
      }
      for (asy::Completer<core::Map<dynamic, dynamic>> c in this.{cli3::IsolateClient::_requests}.{core::Map::values}) {
        if(!c.{asy::Completer::isCompleted}) {
          c.{asy::Completer::completeError}(new core::StateError::•("The client was closed before the server responded to this request."));
        }
      }
      for (cli3::_IsolateClientSubscription s in this.{cli3::IsolateClient::_subscriptions})
        s.{cli3::_IsolateClientSubscription::_close}();
      this.{cli3::IsolateClient::_requests}.{core::Map::clear}();
      return asy::Future::value<dynamic>();
    }
  }
  class _IsolateClientSubscription extends cli::ClientSubscription {
    final field asy::StreamController<dynamic> _stream = asy::StreamController::•<dynamic>();
    final field core::String eventName;
    final field core::String id;
    final field cli3::IsolateClient client;
    constructor •(core::String eventName, core::String id, cli3::IsolateClient client) → void
      : cli3::_IsolateClientSubscription::eventName = eventName, cli3::_IsolateClientSubscription::id = id, cli3::_IsolateClientSubscription::client = client, super cli::ClientSubscription::•()
      ;
    method _close() → void {
      if(!this.{cli3::_IsolateClientSubscription::_stream}.{asy::StreamController::isClosed})
        this.{cli3::_IsolateClientSubscription::_stream}.{asy::StreamController::close}();
    }
    @core::override
    method listen((dynamic) → void onData, {core::Function onError = null, () → void onDone = null, core::bool cancelOnError = null}) → asy::StreamSubscription<dynamic> {
      return this.{cli3::_IsolateClientSubscription::_stream}.{asy::StreamController::stream}.{asy::Stream::listen}(onData, onError: onError, onDone: onDone, cancelOnError: cancelOnError);
    }
    @core::override
    method unsubscribe() → asy::Future<dynamic> {
      return this.{cli3::_IsolateClientSubscription::client}.{cli3::IsolateClient::_whenConnected}<dynamic>(() → asy::Future<dynamic> {
        asy::Completer<core::Map<dynamic, dynamic>> c = asy::Completer::•<core::Map<dynamic, dynamic>>();
        core::String requestId = this.{cli3::_IsolateClientSubscription::client}.{cli3::IsolateClient::_uuid}.{Uuid::Uuid::v4}() as core::String;
        this.{cli3::_IsolateClientSubscription::client}.{cli3::IsolateClient::_requests}.{core::Map::[]=}(requestId, c);
        this.{cli3::_IsolateClientSubscription::client}.{cli3::IsolateClient::serverSendPort}.{iso::SendPort::send}(<core::String, core::Object>{"id": this.{cli3::_IsolateClientSubscription::client}.{cli3::IsolateClient::_id}, "request_id": requestId, "method": "unsubscribe", "params": <core::String, core::String>{"client_id": this.{cli3::_IsolateClientSubscription::client}.{cli3::IsolateClient::clientId}, "subscription_id": this.{cli3::_IsolateClientSubscription::id}}});
        return c.{asy::Completer::future}.{asy::Future::then}<dynamic>((core::Map<dynamic, dynamic> _) → core::Null {
          this.{cli3::_IsolateClientSubscription::_close}();
        });
      });
    }
  }
}
library from "package:pub_sub/src/isolate/server.dart" as ser3 {
  import "dart:async";
  import "dart:isolate";
  import "package:uuid/uuid.dart";
  import "package:pub_sub/pub_sub.dart";
  class IsolateAdapter extends ada::Adapter {
    final field core::Map<core::String, iso::SendPort> _clients = <core::String, iso::SendPort>{};
    final field asy::StreamController<pub2::PublishRequest> _onPublish = asy::StreamController::•<pub2::PublishRequest>();
    final field asy::StreamController<sub::SubscriptionRequest> _onSubscribe = asy::StreamController::•<sub::SubscriptionRequest>();
    final field asy::StreamController<sub::UnsubscriptionRequest> _onUnsubscribe = asy::StreamController::•<sub::UnsubscriptionRequest>();
    final field Uuid::Uuid _uuid = new Uuid::Uuid::•();
    final field iso::ReceivePort receivePort = new iso::_ReceivePort::•();
    synthetic constructor •() → void
      : super ada::Adapter::•()
      ;
    @core::override
    get onPublish() → asy::Stream<pub2::PublishRequest>
      return this.{ser3::IsolateAdapter::_onPublish}.{asy::StreamController::stream};
    @core::override
    get onSubscribe() → asy::Stream<sub::SubscriptionRequest>
      return this.{ser3::IsolateAdapter::_onSubscribe}.{asy::StreamController::stream};
    @core::override
    get onUnsubscribe() → asy::Stream<sub::UnsubscriptionRequest>
      return this.{ser3::IsolateAdapter::_onUnsubscribe}.{asy::StreamController::stream};
    @core::override
    method close() → asy::Future<dynamic> {
      this.{ser3::IsolateAdapter::receivePort}.{iso::ReceivePort::close}();
      this.{ser3::IsolateAdapter::_clients}.{core::Map::clear}();
      this.{ser3::IsolateAdapter::_onPublish}.{asy::StreamController::close}();
      this.{ser3::IsolateAdapter::_onSubscribe}.{asy::StreamController::close}();
      this.{ser3::IsolateAdapter::_onUnsubscribe}.{asy::StreamController::close}();
      return asy::Future::value<dynamic>();
    }
    @core::override
    method start() → void {
      this.{ser3::IsolateAdapter::receivePort}.{iso::ReceivePort::listen}((dynamic data) → core::Null {
        if(data is iso::SendPort) {
          core::String id = this.{ser3::IsolateAdapter::_uuid}.{Uuid::Uuid::v4}() as core::String;
          this.{ser3::IsolateAdapter::_clients}.{core::Map::[]=}(id, data{iso::SendPort});
          data{iso::SendPort}.{iso::SendPort::send}(<core::String, core::Object>{"status": true, "id": id});
        }
        else
          if(data is core::Map<dynamic, dynamic> && data{core::Map<dynamic, dynamic>}.{core::Map::[]}("id") is core::String && data{core::Map<dynamic, dynamic>}.{core::Map::[]}("request_id") is core::String && data{core::Map<dynamic, dynamic>}.{core::Map::[]}("method") is core::String && data{core::Map<dynamic, dynamic>}.{core::Map::[]}("params") is core::Map<dynamic, dynamic>) {
            core::String id = data{core::Map<dynamic, dynamic>}.{core::Map::[]}("id") as{TypeError} core::String;
            core::String requestId = data{core::Map<dynamic, dynamic>}.{core::Map::[]}("request_id") as{TypeError} core::String;
            core::String method = data{core::Map<dynamic, dynamic>}.{core::Map::[]}("method") as{TypeError} core::String;
            core::Map<dynamic, dynamic> params = data{core::Map<dynamic, dynamic>}.{core::Map::[]}("params") as{TypeError} core::Map<dynamic, dynamic>;
            iso::SendPort sp = this.{ser3::IsolateAdapter::_clients}.{core::Map::[]}(id);
            if(sp.{iso::SendPort::==}(null)) {
            }
            else
              if(method.{core::String::==}("publish")) {
                if(params.{core::Map::[]}("client_id") is core::String && params.{core::Map::[]}("event_name") is core::String && params.{core::Map::containsKey}("value")) {
                  core::String clientId = params.{core::Map::[]}("client_id") as{TypeError} core::String;
                  core::String eventName = params.{core::Map::[]}("event_name") as{TypeError} core::String;
                  dynamic value = params.{core::Map::[]}("value");
                  ser3::_IsolatePublishRequestImpl rq = new ser3::_IsolatePublishRequestImpl::•(requestId, clientId, eventName, value, sp);
                  this.{ser3::IsolateAdapter::_onPublish}.{asy::StreamController::add}(rq);
                }
                else {
                  sp.{iso::SendPort::send}(<core::String, core::Object>{"status": false, "request_id": requestId, "error_message": "Expected client_id, event_name, and value."});
                }
              }
              else
                if(method.{core::String::==}("subscribe")) {
                  if(params.{core::Map::[]}("client_id") is core::String && params.{core::Map::[]}("event_name") is core::String) {
                    core::String clientId = params.{core::Map::[]}("client_id") as{TypeError} core::String;
                    core::String eventName = params.{core::Map::[]}("event_name") as{TypeError} core::String;
                    ser3::_IsolateSubscriptionRequestImpl rq = new ser3::_IsolateSubscriptionRequestImpl::•(clientId, eventName, sp, requestId, this.{ser3::IsolateAdapter::_uuid});
                    this.{ser3::IsolateAdapter::_onSubscribe}.{asy::StreamController::add}(rq);
                  }
                  else {
                    sp.{iso::SendPort::send}(<core::String, core::Object>{"status": false, "request_id": requestId, "error_message": "Expected client_id, and event_name."});
                  }
                }
                else
                  if(method.{core::String::==}("unsubscribe")) {
                    if(params.{core::Map::[]}("client_id") is core::String && params.{core::Map::[]}("subscription_id") is core::String) {
                      core::String clientId = params.{core::Map::[]}("client_id") as{TypeError} core::String;
                      core::String subscriptionId = params.{core::Map::[]}("subscription_id") as{TypeError} core::String;
                      ser3::_IsolateUnsubscriptionRequestImpl rq = new ser3::_IsolateUnsubscriptionRequestImpl::•(clientId, subscriptionId, sp, requestId);
                      this.{ser3::IsolateAdapter::_onUnsubscribe}.{asy::StreamController::add}(rq);
                    }
                    else {
                      sp.{iso::SendPort::send}(<core::String, core::Object>{"status": false, "request_id": requestId, "error_message": "Expected client_id, and subscription_id."});
                    }
                  }
                  else {
                    sp.{iso::SendPort::send}(<core::String, core::Object>{"status": false, "request_id": requestId, "error_message": "Unrecognized method \"${method}\". Or, you omitted id, request_id, method, or params."});
                  }
          }
      });
    }
  }
  class _IsolatePublishRequestImpl extends pub2::PublishRequest {
    @core::override
    final field core::String clientId;
    @core::override
    final field core::String eventName;
    @core::override
    final field dynamic value;
    final field iso::SendPort sendPort;
    final field core::String requestId;
    constructor •(core::String requestId, core::String clientId, core::String eventName, dynamic value, iso::SendPort sendPort) → void
      : ser3::_IsolatePublishRequestImpl::requestId = requestId, ser3::_IsolatePublishRequestImpl::clientId = clientId, ser3::_IsolatePublishRequestImpl::eventName = eventName, ser3::_IsolatePublishRequestImpl::value = value, ser3::_IsolatePublishRequestImpl::sendPort = sendPort, super pub2::PublishRequest::•()
      ;
    @core::override
    method accept(pub2::PublishResponse response) → void {
      this.{ser3::_IsolatePublishRequestImpl::sendPort}.{iso::SendPort::send}(<core::String, core::Object>{"status": true, "request_id": this.{ser3::_IsolatePublishRequestImpl::requestId}, "result": <core::String, core::int>{"listeners": response.{pub2::PublishResponse::listeners}}});
    }
    @core::override
    method reject(core::String errorMessage) → void {
      this.{ser3::_IsolatePublishRequestImpl::sendPort}.{iso::SendPort::send}(<core::String, core::Object>{"status": false, "request_id": this.{ser3::_IsolatePublishRequestImpl::requestId}, "error_message": errorMessage});
    }
  }
  class _IsolateSubscriptionRequestImpl extends sub::SubscriptionRequest {
    @core::override
    final field core::String clientId;
    @core::override
    final field core::String eventName;
    final field iso::SendPort sendPort;
    final field core::String requestId;
    final field Uuid::Uuid _uuid;
    constructor •(core::String clientId, core::String eventName, iso::SendPort sendPort, core::String requestId, Uuid::Uuid _uuid) → void
      : ser3::_IsolateSubscriptionRequestImpl::clientId = clientId, ser3::_IsolateSubscriptionRequestImpl::eventName = eventName, ser3::_IsolateSubscriptionRequestImpl::sendPort = sendPort, ser3::_IsolateSubscriptionRequestImpl::requestId = requestId, ser3::_IsolateSubscriptionRequestImpl::_uuid = _uuid, super sub::SubscriptionRequest::•()
      ;
    @core::override
    method reject(core::String errorMessage) → void {
      this.{ser3::_IsolateSubscriptionRequestImpl::sendPort}.{iso::SendPort::send}(<core::String, core::Object>{"status": false, "request_id": this.{ser3::_IsolateSubscriptionRequestImpl::requestId}, "error_message": errorMessage});
    }
    @core::override
    method accept() → asy::FutureOr<sub::Subscription> {
      core::String id = this.{ser3::_IsolateSubscriptionRequestImpl::_uuid}.{Uuid::Uuid::v4}() as core::String;
      this.{ser3::_IsolateSubscriptionRequestImpl::sendPort}.{iso::SendPort::send}(<core::String, core::Object>{"status": true, "request_id": this.{ser3::_IsolateSubscriptionRequestImpl::requestId}, "result": <core::String, core::String>{"subscription_id": id}});
      return new ser3::_IsolateSubscriptionImpl::•(this.{ser3::_IsolateSubscriptionRequestImpl::clientId}, id, this.{ser3::_IsolateSubscriptionRequestImpl::eventName}, this.{ser3::_IsolateSubscriptionRequestImpl::sendPort});
    }
  }
  class _IsolateSubscriptionImpl extends sub::Subscription {
    @core::override
    final field core::String clientId;
    @core::override
    final field core::String id;
    final field core::String eventName;
    final field iso::SendPort sendPort;
    constructor •(core::String clientId, core::String id, core::String eventName, iso::SendPort sendPort) → void
      : ser3::_IsolateSubscriptionImpl::clientId = clientId, ser3::_IsolateSubscriptionImpl::id = id, ser3::_IsolateSubscriptionImpl::eventName = eventName, ser3::_IsolateSubscriptionImpl::sendPort = sendPort, super sub::Subscription::•()
      ;
    @core::override
    method dispatch(dynamic event) → void {
      this.{ser3::_IsolateSubscriptionImpl::sendPort}.{iso::SendPort::send}(<dynamic>[this.{ser3::_IsolateSubscriptionImpl::eventName}, event]);
    }
  }
  class _IsolateUnsubscriptionRequestImpl extends sub::UnsubscriptionRequest {
    @core::override
    final field core::String clientId;
    @core::override
    final field core::String subscriptionId;
    final field iso::SendPort sendPort;
    final field core::String requestId;
    constructor •(core::String clientId, core::String subscriptionId, iso::SendPort sendPort, core::String requestId) → void
      : ser3::_IsolateUnsubscriptionRequestImpl::clientId = clientId, ser3::_IsolateUnsubscriptionRequestImpl::subscriptionId = subscriptionId, ser3::_IsolateUnsubscriptionRequestImpl::sendPort = sendPort, ser3::_IsolateUnsubscriptionRequestImpl::requestId = requestId, super sub::UnsubscriptionRequest::•()
      ;
    @core::override
    method reject(core::String errorMessage) → void {
      this.{ser3::_IsolateUnsubscriptionRequestImpl::sendPort}.{iso::SendPort::send}(<core::String, core::Object>{"status": false, "request_id": this.{ser3::_IsolateUnsubscriptionRequestImpl::requestId}, "error_message": errorMessage});
    }
    @core::override
    method accept() → asy::FutureOr<dynamic> {
      this.{ser3::_IsolateUnsubscriptionRequestImpl::sendPort}.{iso::SendPort::send}(<core::String, core::Object>{"status": true, "request_id": this.{ser3::_IsolateUnsubscriptionRequestImpl::requestId}, "result": <dynamic, dynamic>{}});
    }
  }
}
library from "package:pub_sub/src/protocol/client/client.dart" as cli {
  import "dart:async";
  abstract class Client extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract method publish(core::String eventName, dynamic value) → asy::Future<dynamic>;
    abstract method subscribe(core::String eventName) → asy::Future<cli::ClientSubscription>;
    abstract method close() → asy::Future<dynamic>;
  }
  abstract class ClientSubscription extends asy::Stream<dynamic> {
    synthetic constructor •() → void
      : super asy::Stream::•()
      ;
    abstract method unsubscribe() → asy::Future<dynamic>;
  }
  class PubSubException extends core::Object implements core::Exception {
    final field core::String message;
    const constructor •(core::String message) → void
      : cli::PubSubException::message = message, super core::Object::•()
      ;
    @core::override
    method toString() → core::String
      return "`pub_sub` exception: ${this.{cli::PubSubException::message}}";
  }
}
library from "package:pub_sub/src/protocol/server/adapter.dart" as ada {
  import "dart:async";
  import "package:pub_sub/src/protocol/server/publish.dart";
  import "package:pub_sub/src/protocol/server/subscription.dart";
  abstract class Adapter extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get onPublish() → asy::Stream<pub2::PublishRequest>;
    abstract get onSubscribe() → asy::Stream<sub::SubscriptionRequest>;
    abstract get onUnsubscribe() → asy::Stream<sub::UnsubscriptionRequest>;
    abstract method close() → asy::Future<dynamic>;
    abstract method start() → void;
  }
}
library from "package:pub_sub/src/protocol/server/client.dart" as cli2 {
  class ClientInfo extends core::Object {
    final field core::String id;
    final field core::bool canPublish;
    final field core::bool canSubscribe;
    const constructor •(core::String id, {core::bool canPublish = true, core::bool canSubscribe = true}) → void
      : cli2::ClientInfo::id = id, cli2::ClientInfo::canPublish = canPublish, cli2::ClientInfo::canSubscribe = canSubscribe, super core::Object::•()
      ;
  }
}
library from "package:pub_sub/src/protocol/server/publish.dart" as pub2 {
  abstract class PublishRequest extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get clientId() → core::String;
    abstract get eventName() → core::String;
    abstract get value() → dynamic;
    abstract method accept(pub2::PublishResponse response) → void;
    abstract method reject(core::String errorMessage) → void;
  }
  class PublishResponse extends core::Object {
    final field core::int listeners;
    const constructor •(core::int listeners) → void
      : pub2::PublishResponse::listeners = listeners, super core::Object::•()
      ;
  }
}
library from "package:pub_sub/src/protocol/server/server.dart" as ser2 {
  import "dart:async";
  import "package:pub_sub/src/protocol/server/adapter.dart";
  import "package:pub_sub/src/protocol/server/client.dart";
  import "package:pub_sub/src/protocol/server/publish.dart";
  import "package:pub_sub/src/protocol/server/subscription.dart";
  class Server extends core::Object {
    final field core::List<ada::Adapter> _adapters = <ada::Adapter>[];
    final field core::List<cli2::ClientInfo> _clients = <cli2::ClientInfo>[];
    final field core::Map<core::String, core::List<sub::Subscription>> _subscriptions = <core::String, core::List<sub::Subscription>>{};
    field core::bool _started = false;
    constructor •([core::Iterable<ada::Adapter> adapters = const <ada::Adapter>[]]) → void
      : super core::Object::•() {
      this.{ser2::Server::_adapters}.{core::List::addAll}(let final core::Iterable<ada::Adapter> #t304 = adapters in #t304.==(null) ?{core::Iterable<ada::Adapter>} <ada::Adapter>[] : #t304);
    }
    method addAdapter(ada::Adapter adapter) → void {
      if(this.{ser2::Server::_started})
        throw new core::StateError::•("You cannot add new adapters after the server has started listening.");
      else {
        this.{ser2::Server::_adapters}.{core::List::add}(adapter);
      }
    }
    method registerClient(cli2::ClientInfo client) → void {
      if(this.{ser2::Server::_started})
        throw new core::StateError::•("You cannot register new clients after the server has started listening.");
      else {
        this.{ser2::Server::_clients}.{core::List::add}(client);
      }
    }
    method close() → asy::Future<dynamic> {
      asy::Future::wait<dynamic>(this.{ser2::Server::_adapters}.{core::Iterable::map}<asy::Future<dynamic>>((ada::Adapter a) → asy::Future<dynamic> => a.{ada::Adapter::close}()));
      this.{ser2::Server::_adapters}.{core::List::clear}();
      this.{ser2::Server::_clients}.{core::List::clear}();
      this.{ser2::Server::_subscriptions}.{core::Map::clear}();
      return asy::Future::value<dynamic>();
    }
    method start() → void {
      if(this.{ser2::Server::_adapters}.{core::Iterable::isEmpty})
        throw new core::StateError::•("Cannot start a SyncServer that has no adapters attached.");
      else
        if(this.{ser2::Server::_started})
          throw new core::StateError::•("A SyncServer may only be started once.");
      this.{ser2::Server::_started} = true;
      for (ada::Adapter adapter in this.{ser2::Server::_adapters}) {
        adapter.{ada::Adapter::start}();
      }
      for (ada::Adapter adapter in this.{ser2::Server::_adapters}) {
        adapter.{ada::Adapter::onPublish}.{asy::Stream::listen}((pub2::PublishRequest rq) → core::Null {
          cli2::ClientInfo client = this.{ser2::Server::_clients}.{core::Iterable::firstWhere}((cli2::ClientInfo c) → core::bool => c.{cli2::ClientInfo::id}.{core::String::==}(rq.{pub2::PublishRequest::clientId}), orElse: () → core::Null => null);
          if(client.{core::Object::==}(null)) {
            rq.{pub2::PublishRequest::reject}("Unrecognized client ID \"${rq.{pub2::PublishRequest::clientId}}\".");
          }
          else
            if(!client.{cli2::ClientInfo::canPublish}) {
              rq.{pub2::PublishRequest::reject}("You are not allowed to publish events.");
            }
            else {
              core::Iterable<sub::Subscription> listeners = let final core::Iterable<sub::Subscription> #t305 = let final core::List<sub::Subscription> #t306 = this.{ser2::Server::_subscriptions}.{core::Map::[]}(rq.{pub2::PublishRequest::eventName}) in #t306.==(null) ?{core::Iterable<sub::Subscription>} null : #t306.{core::Iterable::where}((sub::Subscription s) → core::bool => !s.{sub::Subscription::clientId}.{core::String::==}(rq.{pub2::PublishRequest::clientId})) in #t305.==(null) ?{core::Iterable<sub::Subscription>} <sub::Subscription>[] : #t305;
              if(listeners.{core::Iterable::isEmpty}) {
                rq.{pub2::PublishRequest::accept}(const pub2::PublishResponse::•(0));
              }
              else {
                for (sub::Subscription listener in listeners) {
                  listener.{sub::Subscription::dispatch}(rq.{pub2::PublishRequest::value});
                }
                rq.{pub2::PublishRequest::accept}(new pub2::PublishResponse::•(listeners.{core::Iterable::length}));
              }
            }
        });
        adapter.{ada::Adapter::onSubscribe}.{asy::Stream::listen}((sub::SubscriptionRequest rq) → asy::Future<core::Null> async {
          cli2::ClientInfo client = this.{ser2::Server::_clients}.{core::Iterable::firstWhere}((cli2::ClientInfo c) → core::bool => c.{cli2::ClientInfo::id}.{core::String::==}(rq.{sub::SubscriptionRequest::clientId}), orElse: () → core::Null => null);
          if(client.{core::Object::==}(null)) {
            rq.{sub::SubscriptionRequest::reject}("Unrecognized client ID \"${rq.{sub::SubscriptionRequest::clientId}}\".");
          }
          else
            if(!client.{cli2::ClientInfo::canSubscribe}) {
              rq.{sub::SubscriptionRequest::reject}("You are not allowed to subscribe to events.");
            }
            else {
              sub::Subscription sub = await rq.{sub::SubscriptionRequest::accept}();
              core::List<sub::Subscription> list = this.{ser2::Server::_subscriptions}.{core::Map::putIfAbsent}(rq.{sub::SubscriptionRequest::eventName}, () → core::List<sub::Subscription> => <sub::Subscription>[]);
              list.{core::List::add}(sub);
            }
        });
        adapter.{ada::Adapter::onUnsubscribe}.{asy::Stream::listen}((sub::UnsubscriptionRequest rq) → core::Null {
          sub::Subscription toRemove;
          core::List<sub::Subscription> sourceList;
          #L50:
          for (core::List<sub::Subscription> list in this.{ser2::Server::_subscriptions}.{core::Map::values}) {
            toRemove = list.{core::Iterable::firstWhere}((sub::Subscription s) → core::bool => s.{sub::Subscription::id}.{core::String::==}(rq.{sub::UnsubscriptionRequest::subscriptionId}), orElse: () → core::Null => null);
            if(!toRemove.{core::Object::==}(null)) {
              sourceList = list;
              break #L50;
            }
          }
          if(toRemove.{core::Object::==}(null)) {
            rq.{sub::UnsubscriptionRequest::reject}("The specified subscription does not exist.");
          }
          else
            if(!toRemove.{sub::Subscription::clientId}.{core::String::==}(rq.{sub::UnsubscriptionRequest::clientId})) {
              rq.{sub::UnsubscriptionRequest::reject}("That is not your subscription to cancel.");
            }
            else {
              sourceList.{core::List::remove}(toRemove);
              rq.{sub::UnsubscriptionRequest::accept}();
            }
        });
      }
    }
  }
}
library from "package:pub_sub/src/protocol/server/subscription.dart" as sub {
  import "dart:async";
  abstract class SubscriptionRequest extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get clientId() → core::String;
    abstract get eventName() → core::String;
    abstract method accept() → asy::FutureOr<sub::Subscription>;
    abstract method reject(core::String errorMessage) → void;
  }
  abstract class UnsubscriptionRequest extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get clientId() → core::String;
    abstract get subscriptionId() → core::String;
    abstract method accept() → asy::FutureOr<dynamic>;
    abstract method reject(core::String errorMessage) → void;
  }
  abstract class Subscription extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get id() → core::String;
    abstract get clientId() → core::String;
    abstract method dispatch(dynamic event) → void;
  }
}
library from "package:http_parser/src/authentication_challenge.dart" as aut {
  import "dart:collection";
  import "package:string_scanner/string_scanner.dart";
  import "package:http_parser/src/case_insensitive_map.dart";
  import "package:http_parser/src/scan.dart";
  import "package:http_parser/src/utils.dart";
  class AuthenticationChallenge extends core::Object {
    final field core::String scheme;
    final field core::Map<core::String, core::String> parameters;
    constructor •(core::String scheme, core::Map<core::String, core::String> parameters) → void
      : aut::AuthenticationChallenge::scheme = scheme, aut::AuthenticationChallenge::parameters = new col::UnmodifiableMapView::•<core::String, core::String>(new cas::CaseInsensitiveMap::from<core::String>(parameters)), super core::Object::•()
      ;
    static method parseHeader(core::String header) → core::List<aut::AuthenticationChallenge> {
      return uti::wrapFormatException<core::List<aut::AuthenticationChallenge>>("authentication header", header, () → core::List<aut::AuthenticationChallenge> {
        str::StringScanner scanner = new str::StringScanner::•(header);
        scanner.{str::StringScanner::scan}(scan::whitespace);
        core::List<aut::AuthenticationChallenge> challenges = scan::parseList<aut::AuthenticationChallenge>(scanner, () → aut::AuthenticationChallenge {
          core::String scheme = aut::AuthenticationChallenge::_scanScheme(scanner, whitespaceName: "\" \" or \"=\"");
          core::Map<core::String, core::String> params = <core::String, core::String>{};
          while (scanner.{str::StringScanner::scan}(",")) {
            scanner.{str::StringScanner::scan}(scan::whitespace);
          }
          aut::AuthenticationChallenge::_scanAuthParam(scanner, params);
          core::int beforeComma = scanner.{str::StringScanner::position};
          #L51:
          while (scanner.{str::StringScanner::scan}(","))
            #L52:
            {
              scanner.{str::StringScanner::scan}(scan::whitespace);
              if(scanner.{str::StringScanner::matches}(",") || scanner.{str::StringScanner::isDone})
                break #L52;
              scanner.{str::StringScanner::expect}(scan::token, name: "a token");
              core::String name = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0);
              scanner.{str::StringScanner::scan}(scan::whitespace);
              if(!scanner.{str::StringScanner::scan}("=")) {
                scanner.{str::StringScanner::position} = beforeComma;
                break #L51;
              }
              scanner.{str::StringScanner::scan}(scan::whitespace);
              if(scanner.{str::StringScanner::scan}(scan::token)) {
                params.{core::Map::[]=}(name, scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0));
              }
              else {
                params.{core::Map::[]=}(name, scan::expectQuotedString(scanner, name: "a token or a quoted string"));
              }
              scanner.{str::StringScanner::scan}(scan::whitespace);
              beforeComma = scanner.{str::StringScanner::position};
            }
          return new aut::AuthenticationChallenge::•(scheme, params);
        });
        scanner.{str::StringScanner::expectDone}();
        return challenges;
      });
    }
    static factory parse(core::String challenge) → aut::AuthenticationChallenge {
      return uti::wrapFormatException<aut::AuthenticationChallenge>("authentication challenge", challenge, () → aut::AuthenticationChallenge {
        str::StringScanner scanner = new str::StringScanner::•(challenge);
        scanner.{str::StringScanner::scan}(scan::whitespace);
        core::String scheme = aut::AuthenticationChallenge::_scanScheme(scanner);
        core::Map<core::String, core::String> params = <core::String, core::String>{};
        scan::parseList<void>(scanner, () → void => aut::AuthenticationChallenge::_scanAuthParam(scanner, params));
        scanner.{str::StringScanner::expectDone}();
        return new aut::AuthenticationChallenge::•(scheme, params);
      });
    }
    static method _scanScheme(str::StringScanner scanner, {core::String whitespaceName = null}) → core::String {
      scanner.{str::StringScanner::expect}(scan::token, name: "a token");
      core::String scheme = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0).{core::String::toLowerCase}();
      scanner.{str::StringScanner::scan}(scan::whitespace);
      if(scanner.{str::StringScanner::lastMatch}.{core::Object::==}(null) || !scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0).{core::String::contains}(" ")) {
        scanner.{str::StringScanner::expect}(" ", name: whitespaceName);
      }
      return scheme;
    }
    static method _scanAuthParam(str::StringScanner scanner, core::Map<dynamic, dynamic> params) → void {
      scanner.{str::StringScanner::expect}(scan::token, name: "a token");
      core::String name = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0);
      scanner.{str::StringScanner::scan}(scan::whitespace);
      scanner.{str::StringScanner::expect}("=");
      scanner.{str::StringScanner::scan}(scan::whitespace);
      if(scanner.{str::StringScanner::scan}(scan::token)) {
        params.{core::Map::[]=}(name, scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0));
      }
      else {
        params.{core::Map::[]=}(name, scan::expectQuotedString(scanner, name: "a token or a quoted string"));
      }
      scanner.{str::StringScanner::scan}(scan::whitespace);
    }
  }
}
library from "package:http_parser/src/case_insensitive_map.dart" as cas {
  import "package:collection/collection.dart";
  class CaseInsensitiveMap<V extends core::Object = dynamic> extends can::CanonicalizedMap<core::String, core::String, cas::CaseInsensitiveMap::V> {
    constructor •() → void
      : super can::CanonicalizedMap::•((core::String key) → core::String => key.{core::String::toLowerCase}(), isValidKey: (core::Object key) → core::bool => !key.{core::Object::==}(null))
      ;
    constructor from(core::Map<core::String, cas::CaseInsensitiveMap::V> other) → void
      : super can::CanonicalizedMap::from(other, (core::String key) → core::String => key.{core::String::toLowerCase}(), isValidKey: (core::Object key) → core::bool => !key.{core::Object::==}(null))
      ;
  }
}
library from "package:http_parser/src/chunked_coding.dart" as chu {
  import "dart:convert";
  import "package:http_parser/src/chunked_coding/encoder.dart";
  import "package:http_parser/src/chunked_coding/decoder.dart";
  export "package:http_parser/src/chunked_coding/encoder.dart";
  export "package:http_parser/src/chunked_coding/decoder.dart";
  class ChunkedCodingCodec extends con2::Codec<core::List<core::int>, core::List<core::int>> {
    const constructor _() → void
      : super con2::Codec::•()
      ;
    get encoder() → enc::ChunkedCodingEncoder
      return enc::chunkedCodingEncoder;
    get decoder() → dec::ChunkedCodingDecoder
      return dec::chunkedCodingDecoder;
  }
  static const field chu::ChunkedCodingCodec chunkedCoding = const chu::ChunkedCodingCodec::_();
}
library from "package:http_parser/src/http_date.dart" as htt5 {
  import "package:string_scanner/string_scanner.dart";
  import "package:http_parser/src/utils.dart";
  static const field core::List<core::String> _WEEKDAYS = const <core::String>["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  static const field core::List<core::String> _MONTHS = const <core::String>["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  static final field core::RegExp _shortWeekdayRegExp = core::RegExp::•("Mon|Tue|Wed|Thu|Fri|Sat|Sun");
  static final field core::RegExp _longWeekdayRegExp = core::RegExp::•("Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday");
  static final field core::RegExp _monthRegExp = core::RegExp::•("Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec");
  static final field core::RegExp _digitRegExp = core::RegExp::•("\\d+");
  static method formatHttpDate(core::DateTime date) → core::String {
    date = date.{core::DateTime::toUtc}();
    core::StringBuffer buffer = let final core::StringBuffer #t307 = new core::StringBuffer::•() in let final dynamic #t308 = #t307.{core::StringBuffer::write}(htt5::_WEEKDAYS.{core::List::[]}(date.{core::DateTime::weekday}.{core::num::-}(1))) in let final dynamic #t309 = #t307.{core::StringBuffer::write}(", ") in let final dynamic #t310 = #t307.{core::StringBuffer::write}(date.{core::DateTime::day}.{core::num::<=}(9) ?{core::String} "0" : "") in let final dynamic #t311 = #t307.{core::StringBuffer::write}(date.{core::DateTime::day}.{core::int::toString}()) in let final dynamic #t312 = #t307.{core::StringBuffer::write}(" ") in let final dynamic #t313 = #t307.{core::StringBuffer::write}(htt5::_MONTHS.{core::List::[]}(date.{core::DateTime::month}.{core::num::-}(1))) in let final dynamic #t314 = #t307.{core::StringBuffer::write}(" ") in let final dynamic #t315 = #t307.{core::StringBuffer::write}(date.{core::DateTime::year}.{core::int::toString}()) in let final dynamic #t316 = #t307.{core::StringBuffer::write}(date.{core::DateTime::hour}.{core::num::<=}(9) ?{core::String} " 0" : " ") in let final dynamic #t317 = #t307.{core::StringBuffer::write}(date.{core::DateTime::hour}.{core::int::toString}()) in let final dynamic #t318 = #t307.{core::StringBuffer::write}(date.{core::DateTime::minute}.{core::num::<=}(9) ?{core::String} ":0" : ":") in let final dynamic #t319 = #t307.{core::StringBuffer::write}(date.{core::DateTime::minute}.{core::int::toString}()) in let final dynamic #t320 = #t307.{core::StringBuffer::write}(date.{core::DateTime::second}.{core::num::<=}(9) ?{core::String} ":0" : ":") in let final dynamic #t321 = #t307.{core::StringBuffer::write}(date.{core::DateTime::second}.{core::int::toString}()) in let final dynamic #t322 = #t307.{core::StringBuffer::write}(" GMT") in #t307;
    return buffer.{core::StringBuffer::toString}();
  }
  static method parseHttpDate(core::String date) → core::DateTime {
    return uti::wrapFormatException<core::DateTime>("HTTP date", date, () → core::DateTime {
      str::StringScanner scanner = new str::StringScanner::•(date);
      if(scanner.{str::StringScanner::scan}(htt5::_longWeekdayRegExp)) {
        scanner.{str::StringScanner::expect}(", ");
        core::int day = htt5::_parseInt(scanner, 2);
        scanner.{str::StringScanner::expect}("-");
        core::int month = htt5::_parseMonth(scanner);
        scanner.{str::StringScanner::expect}("-");
        core::int year = 1900.{core::num::+}(htt5::_parseInt(scanner, 2));
        scanner.{str::StringScanner::expect}(" ");
        core::DateTime time = htt5::_parseTime(scanner);
        scanner.{str::StringScanner::expect}(" GMT");
        scanner.{str::StringScanner::expectDone}();
        return htt5::_makeDateTime(year, month, day, time);
      }
      scanner.{str::StringScanner::expect}(htt5::_shortWeekdayRegExp);
      if(scanner.{str::StringScanner::scan}(", ")) {
        core::int day = htt5::_parseInt(scanner, 2);
        scanner.{str::StringScanner::expect}(" ");
        core::int month = htt5::_parseMonth(scanner);
        scanner.{str::StringScanner::expect}(" ");
        core::int year = htt5::_parseInt(scanner, 4);
        scanner.{str::StringScanner::expect}(" ");
        core::DateTime time = htt5::_parseTime(scanner);
        scanner.{str::StringScanner::expect}(" GMT");
        scanner.{str::StringScanner::expectDone}();
        return htt5::_makeDateTime(year, month, day, time);
      }
      scanner.{str::StringScanner::expect}(" ");
      core::int month = htt5::_parseMonth(scanner);
      scanner.{str::StringScanner::expect}(" ");
      core::int day = scanner.{str::StringScanner::scan}(" ") ?{core::int} htt5::_parseInt(scanner, 1) : htt5::_parseInt(scanner, 2);
      scanner.{str::StringScanner::expect}(" ");
      core::DateTime time = htt5::_parseTime(scanner);
      scanner.{str::StringScanner::expect}(" ");
      core::int year = htt5::_parseInt(scanner, 4);
      scanner.{str::StringScanner::expectDone}();
      return htt5::_makeDateTime(year, month, day, time);
    });
  }
  static method _parseMonth(str::StringScanner scanner) → core::int {
    scanner.{str::StringScanner::expect}(htt5::_monthRegExp);
    return htt5::_MONTHS.{core::List::indexOf}(scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0)).{core::num::+}(1);
  }
  static method _parseInt(str::StringScanner scanner, core::int digits) → core::int {
    scanner.{str::StringScanner::expect}(htt5::_digitRegExp);
    if(!scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0).{core::String::length}.{core::num::==}(digits)) {
      scanner.{str::StringScanner::error}("expected a ${digits}-digit number.");
    }
    return core::int::parse(scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0));
  }
  static method _parseTime(str::StringScanner scanner) → core::DateTime {
    core::int hours = htt5::_parseInt(scanner, 2);
    if(hours.{core::num::>=}(24))
      scanner.{str::StringScanner::error}("hours may not be greater than 24.");
    scanner.{str::StringScanner::expect}(":");
    core::int minutes = htt5::_parseInt(scanner, 2);
    if(minutes.{core::num::>=}(60))
      scanner.{str::StringScanner::error}("minutes may not be greater than 60.");
    scanner.{str::StringScanner::expect}(":");
    core::int seconds = htt5::_parseInt(scanner, 2);
    if(seconds.{core::num::>=}(60))
      scanner.{str::StringScanner::error}("seconds may not be greater than 60.");
    return new core::DateTime::•(1, 1, 1, hours, minutes, seconds);
  }
  static method _makeDateTime(core::int year, core::int month, core::int day, core::DateTime time) → core::DateTime {
    core::DateTime dateTime = new core::DateTime::utc(year, month, day, time.{core::DateTime::hour}, time.{core::DateTime::minute}, time.{core::DateTime::second});
    if(!dateTime.{core::DateTime::month}.{core::num::==}(month)) {
      throw new core::FormatException::•("invalid day '${day}' for month '${month}'.");
    }
    return dateTime;
  }
}
library from "package:http_parser/src/media_type.dart" as med {
  import "package:collection/collection.dart";
  import "package:string_scanner/string_scanner.dart";
  import "package:http_parser/src/case_insensitive_map.dart";
  import "package:http_parser/src/scan.dart";
  import "package:http_parser/src/utils.dart";
  class MediaType extends core::Object {
    final field core::String type;
    final field core::String subtype;
    final field core::Map<core::String, core::String> parameters;
    constructor •(core::String type, core::String subtype, [core::Map<core::String, core::String> parameters = null]) → void
      : med::MediaType::type = type.{core::String::toLowerCase}(), med::MediaType::subtype = subtype.{core::String::toLowerCase}(), med::MediaType::parameters = new col::UnmodifiableMapView::•<core::String, core::String>(parameters.{core::Object::==}(null) ?{core::Map<core::String, core::String>} <core::String, core::String>{} : new cas::CaseInsensitiveMap::from<core::String>(parameters)), super core::Object::•()
      ;
    get mimeType() → core::String
      return "${this.{med::MediaType::type}}/${this.{med::MediaType::subtype}}";
    static factory parse(core::String mediaType) → med::MediaType {
      return uti::wrapFormatException<med::MediaType>("media type", mediaType, () → med::MediaType {
        str::StringScanner scanner = new str::StringScanner::•(mediaType);
        scanner.{str::StringScanner::scan}(scan::whitespace);
        scanner.{str::StringScanner::expect}(scan::token);
        core::String type = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0);
        scanner.{str::StringScanner::expect}("/");
        scanner.{str::StringScanner::expect}(scan::token);
        core::String subtype = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0);
        scanner.{str::StringScanner::scan}(scan::whitespace);
        core::Map<core::String, core::String> parameters = <core::String, core::String>{};
        while (scanner.{str::StringScanner::scan}(";")) {
          scanner.{str::StringScanner::scan}(scan::whitespace);
          scanner.{str::StringScanner::expect}(scan::token);
          core::String attribute = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0);
          scanner.{str::StringScanner::expect}("=");
          core::String value;
          if(scanner.{str::StringScanner::scan}(scan::token)) {
            value = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0);
          }
          else {
            value = scan::expectQuotedString(scanner);
          }
          scanner.{str::StringScanner::scan}(scan::whitespace);
          parameters.{core::Map::[]=}(attribute, value);
        }
        scanner.{str::StringScanner::expectDone}();
        return new med::MediaType::•(type, subtype, parameters);
      });
    }
    method change({core::String type = null, core::String subtype = null, core::String mimeType = null, core::Map<core::String, core::String> parameters = null, core::bool clearParameters = false}) → med::MediaType {
      if(!mimeType.{core::String::==}(null)) {
        if(!type.{core::String::==}(null)) {
          throw new core::ArgumentError::•("You may not pass both [type] and [mimeType].");
        }
        else
          if(!subtype.{core::String::==}(null)) {
            throw new core::ArgumentError::•("You may not pass both [subtype] and [mimeType].");
          }
        core::List<core::String> segments = mimeType.{core::String::split}("/");
        if(!segments.{core::List::length}.{core::num::==}(2)) {
          throw new core::FormatException::•("Invalid mime type \"${mimeType}\".");
        }
        type = segments.{core::List::[]}(0);
        subtype = segments.{core::List::[]}(1);
      }
      if(type.{core::String::==}(null))
        type = this.{med::MediaType::type};
      if(subtype.{core::String::==}(null))
        subtype = this.{med::MediaType::subtype};
      if(parameters.{core::Object::==}(null))
        parameters = <core::String, core::String>{};
      if(!clearParameters) {
        core::Map<core::String, core::String> newParameters = parameters;
        parameters = col::LinkedHashMap::from<core::String, core::String>(this.{med::MediaType::parameters});
        parameters.{core::Map::addAll}(newParameters);
      }
      return new med::MediaType::•(type, subtype, parameters);
    }
    method toString() → core::String {
      core::StringBuffer buffer = let final core::StringBuffer #t323 = new core::StringBuffer::•() in let final dynamic #t324 = #t323.{core::StringBuffer::write}(this.{med::MediaType::type}) in let final dynamic #t325 = #t323.{core::StringBuffer::write}("/") in let final dynamic #t326 = #t323.{core::StringBuffer::write}(this.{med::MediaType::subtype}) in #t323;
      this.{med::MediaType::parameters}.{core::Map::forEach}((core::String attribute, core::String value) → core::Null {
        buffer.{core::StringBuffer::write}("; ${attribute}=");
        if(scan::nonToken.{core::RegExp::hasMatch}(value)) {
          let final core::StringBuffer #t327 = buffer in let final dynamic #t328 = #t327.{core::StringBuffer::write}("\"") in let final dynamic #t329 = #t327.{core::StringBuffer::write}(value.{core::String::replaceAllMapped}(med::_escapedChar, (core::Match match) → core::String => "\\".{core::String::+}(match.{core::Match::[]}(0)))) in let final dynamic #t330 = #t327.{core::StringBuffer::write}("\"") in #t327;
        }
        else {
          buffer.{core::StringBuffer::write}(value);
        }
      });
      return buffer.{core::StringBuffer::toString}();
    }
  }
  static final field core::RegExp _escapedChar = core::RegExp::•("[\"\\x00-\\x1F\\x7F]");
}
library from "package:path/src/context.dart" as con5 {
  import "dart:math" as math;
  import "package:path/src/characters.dart" as chars;
  import "package:path/src/internal_style.dart";
  import "package:path/src/style.dart";
  import "package:path/src/parsed_path.dart";
  import "package:path/src/path_exception.dart";
  import "package:path/path.dart" as p;
  class Context extends core::Object {
    final field int::InternalStyle style;
    final field core::String _current;
    constructor _internal() → void
      : con5::Context::style = sty::Style::platform as int::InternalStyle, con5::Context::_current = null, super core::Object::•()
      ;
    constructor _(int::InternalStyle style, core::String _current) → void
      : con5::Context::style = style, con5::Context::_current = _current, super core::Object::•()
      ;
    static factory •({sty::Style style = null, core::String current = null}) → con5::Context {
      if(current.{core::String::==}(null)) {
        if(style.{core::Object::==}(null)) {
          current = path::current;
        }
        else {
          current = ".";
        }
      }
      if(style.{core::Object::==}(null)) {
        style = sty::Style::platform;
      }
      else
        if(!(style is int::InternalStyle)) {
          throw new core::ArgumentError::•("Only styles defined by the path package are allowed.");
        }
      return new con5::Context::_(style as int::InternalStyle, current);
    }
    get current() → core::String
      return !this.{con5::Context::_current}.{core::String::==}(null) ?{core::String} this.{con5::Context::_current} : path::current;
    get separator() → core::String
      return this.{con5::Context::style}.{int::InternalStyle::separator};
    method absolute(core::String part1, [core::String part2 = null, core::String part3 = null, core::String part4 = null, core::String part5 = null, core::String part6 = null, core::String part7 = null]) → core::String {
      con5::_validateArgList("absolute", <core::String>[part1, part2, part3, part4, part5, part6, part7]);
      if(part2.{core::String::==}(null) && this.{con5::Context::isAbsolute}(part1) && !this.{con5::Context::isRootRelative}(part1)) {
        return part1;
      }
      return this.{con5::Context::join}(this.{con5::Context::current}, part1, part2, part3, part4, part5, part6, part7);
    }
    method basename(core::String path) → core::String
      return this.{con5::Context::_parse}(path).{par3::ParsedPath::basename};
    method basenameWithoutExtension(core::String path) → core::String
      return this.{con5::Context::_parse}(path).{par3::ParsedPath::basenameWithoutExtension};
    method dirname(core::String path) → core::String {
      par3::ParsedPath parsed = this.{con5::Context::_parse}(path);
      parsed.{par3::ParsedPath::removeTrailingSeparators}();
      if(parsed.{par3::ParsedPath::parts}.{core::Iterable::isEmpty})
        return parsed.{par3::ParsedPath::root}.{core::String::==}(null) ?{core::String} "." : parsed.{par3::ParsedPath::root};
      if(parsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::==}(1)) {
        return parsed.{par3::ParsedPath::root}.{core::String::==}(null) ?{core::String} "." : parsed.{par3::ParsedPath::root};
      }
      parsed.{par3::ParsedPath::parts}.{core::List::removeLast}();
      parsed.{par3::ParsedPath::separators}.{core::List::removeLast}();
      parsed.{par3::ParsedPath::removeTrailingSeparators}();
      return parsed.{par3::ParsedPath::toString}();
    }
    method extension(core::String path) → core::String
      return this.{con5::Context::_parse}(path).{par3::ParsedPath::extension};
    method rootPrefix(core::String path) → core::String
      return path.{core::String::substring}(0, this.{con5::Context::style}.{int::InternalStyle::rootLength}(path));
    method isAbsolute(core::String path) → core::bool
      return this.{con5::Context::style}.{int::InternalStyle::rootLength}(path).{core::num::>}(0);
    method isRelative(core::String path) → core::bool
      return !this.{con5::Context::isAbsolute}(path);
    method isRootRelative(core::String path) → core::bool
      return this.{con5::Context::style}.{int::InternalStyle::isRootRelative}(path);
    method join(core::String part1, [core::String part2 = null, core::String part3 = null, core::String part4 = null, core::String part5 = null, core::String part6 = null, core::String part7 = null, core::String part8 = null]) → core::String {
      core::List<core::String> parts = <core::String>[part1, part2, part3, part4, part5, part6, part7, part8];
      con5::_validateArgList("join", parts);
      return this.{con5::Context::joinAll}(parts.{core::Iterable::where}((core::String part) → core::bool => !part.{core::String::==}(null)));
    }
    method joinAll(core::Iterable<core::String> parts) → core::String {
      core::StringBuffer buffer = new core::StringBuffer::•();
      core::bool needsSeparator = false;
      core::bool isAbsoluteAndNotRootRelative = false;
      for (core::String part in parts.{core::Iterable::where}((core::String part) → core::bool => !part.{core::String::==}(""))) {
        if(this.{con5::Context::isRootRelative}(part) && isAbsoluteAndNotRootRelative) {
          par3::ParsedPath parsed = this.{con5::Context::_parse}(part);
          core::String path = buffer.{core::StringBuffer::toString}();
          parsed.{par3::ParsedPath::root} = path.{core::String::substring}(0, this.{con5::Context::style}.{int::InternalStyle::rootLength}(path, withDrive: true));
          if(this.{con5::Context::style}.{int::InternalStyle::needsSeparator}(parsed.{par3::ParsedPath::root})) {
            parsed.{par3::ParsedPath::separators}.{core::List::[]=}(0, this.{con5::Context::style}.{int::InternalStyle::separator});
          }
          buffer.{core::StringBuffer::clear}();
          buffer.{core::StringBuffer::write}(parsed.{par3::ParsedPath::toString}());
        }
        else
          if(this.{con5::Context::isAbsolute}(part)) {
            isAbsoluteAndNotRootRelative = !this.{con5::Context::isRootRelative}(part);
            buffer.{core::StringBuffer::clear}();
            buffer.{core::StringBuffer::write}(part);
          }
          else {
            if(part.{core::String::length}.{core::num::>}(0) && this.{con5::Context::style}.{int::InternalStyle::containsSeparator}(part.{core::String::[]}(0))) {
            }
            else
              if(needsSeparator) {
                buffer.{core::StringBuffer::write}(this.{con5::Context::separator});
              }
            buffer.{core::StringBuffer::write}(part);
          }
        needsSeparator = this.{con5::Context::style}.{int::InternalStyle::needsSeparator}(part);
      }
      return buffer.{core::StringBuffer::toString}();
    }
    method split(core::String path) → core::List<core::String> {
      par3::ParsedPath parsed = this.{con5::Context::_parse}(path);
      parsed.{par3::ParsedPath::parts} = parsed.{par3::ParsedPath::parts}.{core::Iterable::where}((core::String part) → core::bool => !part.{core::String::isEmpty}).{core::Iterable::toList}();
      if(!parsed.{par3::ParsedPath::root}.{core::String::==}(null))
        parsed.{par3::ParsedPath::parts}.{core::List::insert}(0, parsed.{par3::ParsedPath::root});
      return parsed.{par3::ParsedPath::parts};
    }
    method canonicalize(core::String path) → core::String {
      path = this.{con5::Context::absolute}(path);
      if(!this.{con5::Context::style}.{core::Object::==}(sty::Style::windows) && !this.{con5::Context::_needsNormalization}(path))
        return path;
      par3::ParsedPath parsed = this.{con5::Context::_parse}(path);
      parsed.{par3::ParsedPath::normalize}(canonicalize: true);
      return parsed.{par3::ParsedPath::toString}();
    }
    method normalize(core::String path) → core::String {
      if(!this.{con5::Context::_needsNormalization}(path))
        return path;
      par3::ParsedPath parsed = this.{con5::Context::_parse}(path);
      parsed.{par3::ParsedPath::normalize}();
      return parsed.{par3::ParsedPath::toString}();
    }
    method _needsNormalization(core::String path) → core::bool {
      core::int start = 0;
      core::List<core::int> codeUnits = path.{core::String::codeUnits};
      core::int previousPrevious;
      core::int previous;
      core::int root = this.{con5::Context::style}.{int::InternalStyle::rootLength}(path);
      if(!root.{core::num::==}(0)) {
        start = root;
        previous = cha::SLASH;
        if(this.{con5::Context::style}.{core::Object::==}(sty::Style::windows)) {
          for (core::int i = 0; i.{core::num::<}(root); i = i.{core::num::+}(1)) {
            if(codeUnits.{core::List::[]}(i).{core::num::==}(cha::SLASH))
              return true;
          }
        }
      }
      for (core::int i = start; i.{core::num::<}(codeUnits.{core::List::length}); i = i.{core::num::+}(1)) {
        core::int codeUnit = codeUnits.{core::List::[]}(i);
        if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(codeUnit)) {
          if(this.{con5::Context::style}.{core::Object::==}(sty::Style::windows) && codeUnit.{core::num::==}(cha::SLASH))
            return true;
          if(!previous.{core::num::==}(null) && this.{con5::Context::style}.{int::InternalStyle::isSeparator}(previous))
            return true;
          if(previous.{core::num::==}(cha::PERIOD) && (previousPrevious.{core::num::==}(null) || previousPrevious.{core::num::==}(cha::PERIOD) || this.{con5::Context::style}.{int::InternalStyle::isSeparator}(previousPrevious))) {
            return true;
          }
        }
        previousPrevious = previous;
        previous = codeUnit;
      }
      if(previous.{core::num::==}(null))
        return true;
      if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(previous))
        return true;
      if(previous.{core::num::==}(cha::PERIOD) && (previousPrevious.{core::num::==}(null) || this.{con5::Context::style}.{int::InternalStyle::isSeparator}(previousPrevious) || previousPrevious.{core::num::==}(cha::PERIOD))) {
        return true;
      }
      return false;
    }
    method relative(core::String path, {core::String from = null}) → core::String {
      if(from.{core::String::==}(null) && this.{con5::Context::isRelative}(path))
        return this.{con5::Context::normalize}(path);
      from = from.{core::String::==}(null) ?{core::String} this.{con5::Context::current} : this.{con5::Context::absolute}(from);
      if(this.{con5::Context::isRelative}(from) && this.{con5::Context::isAbsolute}(path)) {
        return this.{con5::Context::normalize}(path);
      }
      if(this.{con5::Context::isRelative}(path) || this.{con5::Context::isRootRelative}(path)) {
        path = this.{con5::Context::absolute}(path);
      }
      if(this.{con5::Context::isRelative}(path) && this.{con5::Context::isAbsolute}(from)) {
        throw new pat::PathException::•("Unable to find a path to \"${path}\" from \"${from}\".");
      }
      par3::ParsedPath fromParsed = let final par3::ParsedPath #t331 = this.{con5::Context::_parse}(from) in let final dynamic #t332 = #t331.{par3::ParsedPath::normalize}() in #t331;
      par3::ParsedPath pathParsed = let final par3::ParsedPath #t333 = this.{con5::Context::_parse}(path) in let final dynamic #t334 = #t333.{par3::ParsedPath::normalize}() in #t333;
      if(fromParsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::>}(0) && fromParsed.{par3::ParsedPath::parts}.{core::List::[]}(0).{core::String::==}(".")) {
        return pathParsed.{par3::ParsedPath::toString}();
      }
      if(!fromParsed.{par3::ParsedPath::root}.{core::String::==}(pathParsed.{par3::ParsedPath::root}) && (fromParsed.{par3::ParsedPath::root}.{core::String::==}(null) || pathParsed.{par3::ParsedPath::root}.{core::String::==}(null) || !this.{con5::Context::style}.{int::InternalStyle::pathsEqual}(fromParsed.{par3::ParsedPath::root}, pathParsed.{par3::ParsedPath::root}))) {
        return pathParsed.{par3::ParsedPath::toString}();
      }
      while (fromParsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::>}(0) && pathParsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::>}(0) && this.{con5::Context::style}.{int::InternalStyle::pathsEqual}(fromParsed.{par3::ParsedPath::parts}.{core::List::[]}(0), pathParsed.{par3::ParsedPath::parts}.{core::List::[]}(0))) {
        fromParsed.{par3::ParsedPath::parts}.{core::List::removeAt}(0);
        fromParsed.{par3::ParsedPath::separators}.{core::List::removeAt}(1);
        pathParsed.{par3::ParsedPath::parts}.{core::List::removeAt}(0);
        pathParsed.{par3::ParsedPath::separators}.{core::List::removeAt}(1);
      }
      if(fromParsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::>}(0) && fromParsed.{par3::ParsedPath::parts}.{core::List::[]}(0).{core::String::==}("..")) {
        throw new pat::PathException::•("Unable to find a path to \"${path}\" from \"${from}\".");
      }
      pathParsed.{par3::ParsedPath::parts}.{core::List::insertAll}(0, core::List::filled<core::String>(fromParsed.{par3::ParsedPath::parts}.{core::List::length}, ".."));
      pathParsed.{par3::ParsedPath::separators}.{core::List::[]=}(0, "");
      pathParsed.{par3::ParsedPath::separators}.{core::List::insertAll}(1, core::List::filled<core::String>(fromParsed.{par3::ParsedPath::parts}.{core::List::length}, this.{con5::Context::style}.{int::InternalStyle::separator}));
      if(pathParsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::==}(0))
        return ".";
      if(pathParsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::>}(1) && pathParsed.{par3::ParsedPath::parts}.{core::Iterable::last}.{core::String::==}(".")) {
        pathParsed.{par3::ParsedPath::parts}.{core::List::removeLast}();
        let final core::List<core::String> #t335 = pathParsed.{par3::ParsedPath::separators} in let final dynamic #t336 = #t335.{core::List::removeLast}() in let final dynamic #t337 = #t335.{core::List::removeLast}() in let final dynamic #t338 = #t335.{core::List::add}("") in #t335;
      }
      pathParsed.{par3::ParsedPath::root} = "";
      pathParsed.{par3::ParsedPath::removeTrailingSeparators}();
      return pathParsed.{par3::ParsedPath::toString}();
    }
    method isWithin(core::String parent, core::String child) → core::bool
      return this.{con5::Context::_isWithinOrEquals}(parent, child).{core::Object::==}(con5::_PathRelation::within);
    method equals(core::String path1, core::String path2) → core::bool
      return this.{con5::Context::_isWithinOrEquals}(path1, path2).{core::Object::==}(con5::_PathRelation::equal);
    method _isWithinOrEquals(core::String parent, core::String child) → con5::_PathRelation {
      core::bool parentIsAbsolute = this.{con5::Context::isAbsolute}(parent);
      core::bool childIsAbsolute = this.{con5::Context::isAbsolute}(child);
      if(parentIsAbsolute && !childIsAbsolute) {
        child = this.{con5::Context::absolute}(child);
        if(this.{con5::Context::style}.{int::InternalStyle::isRootRelative}(parent))
          parent = this.{con5::Context::absolute}(parent);
      }
      else
        if(childIsAbsolute && !parentIsAbsolute) {
          parent = this.{con5::Context::absolute}(parent);
          if(this.{con5::Context::style}.{int::InternalStyle::isRootRelative}(child))
            child = this.{con5::Context::absolute}(child);
        }
        else
          if(childIsAbsolute && parentIsAbsolute) {
            core::bool childIsRootRelative = this.{con5::Context::style}.{int::InternalStyle::isRootRelative}(child);
            core::bool parentIsRootRelative = this.{con5::Context::style}.{int::InternalStyle::isRootRelative}(parent);
            if(childIsRootRelative && !parentIsRootRelative) {
              child = this.{con5::Context::absolute}(child);
            }
            else
              if(parentIsRootRelative && !childIsRootRelative) {
                parent = this.{con5::Context::absolute}(parent);
              }
          }
      con5::_PathRelation result = this.{con5::Context::_isWithinOrEqualsFast}(parent, child);
      if(!result.{core::Object::==}(con5::_PathRelation::inconclusive))
        return result;
      core::String relative;
      try {
        relative = this.{con5::Context::relative}(child, from: parent);
      }
      on pat::PathException catch(final pat::PathException _) {
        return con5::_PathRelation::different;
      }
      if(!this.{con5::Context::isRelative}(relative))
        return con5::_PathRelation::different;
      if(relative.{core::String::==}("."))
        return con5::_PathRelation::equal;
      if(relative.{core::String::==}(".."))
        return con5::_PathRelation::different;
      return relative.{core::String::length}.{core::num::>=}(3) && relative.{core::String::startsWith}("..") && this.{con5::Context::style}.{int::InternalStyle::isSeparator}(relative.{core::String::codeUnitAt}(2)) ?{con5::_PathRelation} con5::_PathRelation::different : con5::_PathRelation::within;
    }
    method _isWithinOrEqualsFast(core::String parent, core::String child) → con5::_PathRelation {
      if(parent.{core::String::==}("."))
        parent = "";
      core::int parentRootLength = this.{con5::Context::style}.{int::InternalStyle::rootLength}(parent);
      core::int childRootLength = this.{con5::Context::style}.{int::InternalStyle::rootLength}(child);
      if(!parentRootLength.{core::num::==}(childRootLength))
        return con5::_PathRelation::different;
      for (core::int i = 0; i.{core::num::<}(parentRootLength); i = i.{core::num::+}(1)) {
        core::int parentCodeUnit = parent.{core::String::codeUnitAt}(i);
        core::int childCodeUnit = child.{core::String::codeUnitAt}(i);
        if(!this.{con5::Context::style}.{int::InternalStyle::codeUnitsEqual}(parentCodeUnit, childCodeUnit)) {
          return con5::_PathRelation::different;
        }
      }
      core::int lastCodeUnit = cha::SLASH;
      core::int lastParentSeparator;
      core::int parentIndex = parentRootLength;
      core::int childIndex = childRootLength;
      #L53:
      while (parentIndex.{core::num::<}(parent.{core::String::length}) && childIndex.{core::num::<}(child.{core::String::length}))
        #L54:
        {
          core::int parentCodeUnit = parent.{core::String::codeUnitAt}(parentIndex);
          core::int childCodeUnit = child.{core::String::codeUnitAt}(childIndex);
          if(this.{con5::Context::style}.{int::InternalStyle::codeUnitsEqual}(parentCodeUnit, childCodeUnit)) {
            if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(parentCodeUnit)) {
              lastParentSeparator = parentIndex;
            }
            lastCodeUnit = parentCodeUnit;
            parentIndex = parentIndex.{core::num::+}(1);
            childIndex = childIndex.{core::num::+}(1);
            break #L54;
          }
          if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(parentCodeUnit) && this.{con5::Context::style}.{int::InternalStyle::isSeparator}(lastCodeUnit)) {
            lastParentSeparator = parentIndex;
            parentIndex = parentIndex.{core::num::+}(1);
            break #L54;
          }
          else
            if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(childCodeUnit) && this.{con5::Context::style}.{int::InternalStyle::isSeparator}(lastCodeUnit)) {
              childIndex = childIndex.{core::num::+}(1);
              break #L54;
            }
          if(parentCodeUnit.{core::num::==}(cha::PERIOD) && this.{con5::Context::style}.{int::InternalStyle::isSeparator}(lastCodeUnit)) {
            parentIndex = parentIndex.{core::num::+}(1);
            if(parentIndex.{core::num::==}(parent.{core::String::length}))
              break #L53;
            parentCodeUnit = parent.{core::String::codeUnitAt}(parentIndex);
            if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(parentCodeUnit)) {
              lastParentSeparator = parentIndex;
              parentIndex = parentIndex.{core::num::+}(1);
              break #L54;
            }
            if(parentCodeUnit.{core::num::==}(cha::PERIOD)) {
              parentIndex = parentIndex.{core::num::+}(1);
              if(parentIndex.{core::num::==}(parent.{core::String::length}) || this.{con5::Context::style}.{int::InternalStyle::isSeparator}(parent.{core::String::codeUnitAt}(parentIndex))) {
                return con5::_PathRelation::inconclusive;
              }
            }
          }
          if(childCodeUnit.{core::num::==}(cha::PERIOD) && this.{con5::Context::style}.{int::InternalStyle::isSeparator}(lastCodeUnit)) {
            childIndex = childIndex.{core::num::+}(1);
            if(childIndex.{core::num::==}(child.{core::String::length}))
              break #L53;
            childCodeUnit = child.{core::String::codeUnitAt}(childIndex);
            if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(childCodeUnit)) {
              childIndex = childIndex.{core::num::+}(1);
              break #L54;
            }
            if(childCodeUnit.{core::num::==}(cha::PERIOD)) {
              childIndex = childIndex.{core::num::+}(1);
              if(childIndex.{core::num::==}(child.{core::String::length}) || this.{con5::Context::style}.{int::InternalStyle::isSeparator}(child.{core::String::codeUnitAt}(childIndex))) {
                return con5::_PathRelation::inconclusive;
              }
            }
          }
          con5::_PathDirection childDirection = this.{con5::Context::_pathDirection}(child, childIndex);
          if(!childDirection.{core::Object::==}(con5::_PathDirection::belowRoot)) {
            return con5::_PathRelation::inconclusive;
          }
          con5::_PathDirection parentDirection = this.{con5::Context::_pathDirection}(parent, parentIndex);
          if(!parentDirection.{core::Object::==}(con5::_PathDirection::belowRoot)) {
            return con5::_PathRelation::inconclusive;
          }
          return con5::_PathRelation::different;
        }
      if(childIndex.{core::num::==}(child.{core::String::length})) {
        if(parentIndex.{core::num::==}(parent.{core::String::length}) || this.{con5::Context::style}.{int::InternalStyle::isSeparator}(parent.{core::String::codeUnitAt}(parentIndex))) {
          lastParentSeparator = parentIndex;
        }
        else {
          lastParentSeparator.{core::num::==}(null) ?{core::int} lastParentSeparator = math::max<core::int>(0, parentRootLength.{core::num::-}(1)) : null;
        }
        con5::_PathDirection direction = this.{con5::Context::_pathDirection}(parent, let final core::int #t339 = lastParentSeparator in #t339.==(null) ?{core::int} parentRootLength.{core::num::-}(1) : #t339);
        if(direction.{core::Object::==}(con5::_PathDirection::atRoot))
          return con5::_PathRelation::equal;
        return direction.{core::Object::==}(con5::_PathDirection::aboveRoot) ?{con5::_PathRelation} con5::_PathRelation::inconclusive : con5::_PathRelation::different;
      }
      con5::_PathDirection direction = this.{con5::Context::_pathDirection}(child, childIndex);
      if(direction.{core::Object::==}(con5::_PathDirection::atRoot))
        return con5::_PathRelation::equal;
      if(direction.{core::Object::==}(con5::_PathDirection::aboveRoot)) {
        return con5::_PathRelation::inconclusive;
      }
      return this.{con5::Context::style}.{int::InternalStyle::isSeparator}(child.{core::String::codeUnitAt}(childIndex)) || this.{con5::Context::style}.{int::InternalStyle::isSeparator}(lastCodeUnit) ?{con5::_PathRelation} con5::_PathRelation::within : con5::_PathRelation::different;
    }
    method _pathDirection(core::String path, core::int index) → con5::_PathDirection {
      core::int depth = 0;
      core::bool reachedRoot = false;
      core::int i = index;
      #L55:
      while (i.{core::num::<}(path.{core::String::length})) {
        while (i.{core::num::<}(path.{core::String::length}) && this.{con5::Context::style}.{int::InternalStyle::isSeparator}(path.{core::String::codeUnitAt}(i))) {
          i = i.{core::num::+}(1);
        }
        if(i.{core::num::==}(path.{core::String::length}))
          break #L55;
        core::int start = i;
        while (i.{core::num::<}(path.{core::String::length}) && !this.{con5::Context::style}.{int::InternalStyle::isSeparator}(path.{core::String::codeUnitAt}(i))) {
          i = i.{core::num::+}(1);
        }
        if(i.{core::num::-}(start).{core::num::==}(1) && path.{core::String::codeUnitAt}(start).{core::num::==}(cha::PERIOD)) {
        }
        else
          if(i.{core::num::-}(start).{core::num::==}(2) && path.{core::String::codeUnitAt}(start).{core::num::==}(cha::PERIOD) && path.{core::String::codeUnitAt}(start.{core::num::+}(1)).{core::num::==}(cha::PERIOD)) {
            depth = depth.{core::num::-}(1);
            if(depth.{core::num::<}(0))
              break #L55;
            if(depth.{core::num::==}(0))
              reachedRoot = true;
          }
          else {
            depth = depth.{core::num::+}(1);
          }
        if(i.{core::num::==}(path.{core::String::length}))
          break #L55;
        i = i.{core::num::+}(1);
      }
      if(depth.{core::num::<}(0))
        return con5::_PathDirection::aboveRoot;
      if(depth.{core::num::==}(0))
        return con5::_PathDirection::atRoot;
      if(reachedRoot)
        return con5::_PathDirection::reachesRoot;
      return con5::_PathDirection::belowRoot;
    }
    method hash(core::String path) → core::int {
      path = this.{con5::Context::absolute}(path);
      core::int result = this.{con5::Context::_hashFast}(path);
      if(!result.{core::num::==}(null))
        return result;
      par3::ParsedPath parsed = this.{con5::Context::_parse}(path);
      parsed.{par3::ParsedPath::normalize}();
      return this.{con5::Context::_hashFast}(parsed.{par3::ParsedPath::toString}());
    }
    method _hashFast(core::String path) → core::int {
      core::int hash = 4603;
      core::bool beginning = true;
      core::bool wasSeparator = true;
      #L56:
      for (core::int i = 0; i.{core::num::<}(path.{core::String::length}); i = i.{core::num::+}(1))
        #L57:
        {
          core::int codeUnit = this.{con5::Context::style}.{int::InternalStyle::canonicalizeCodeUnit}(path.{core::String::codeUnitAt}(i));
          if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(codeUnit)) {
            wasSeparator = true;
            break #L57;
          }
          if(codeUnit.{core::num::==}(cha::PERIOD) && wasSeparator) {
            if(i.{core::num::+}(1).{core::num::==}(path.{core::String::length}))
              break #L56;
            core::int next = path.{core::String::codeUnitAt}(i.{core::num::+}(1));
            if(this.{con5::Context::style}.{int::InternalStyle::isSeparator}(next))
              break #L57;
            if(!beginning && next.{core::num::==}(cha::PERIOD) && (i.{core::num::+}(2).{core::num::==}(path.{core::String::length}) || this.{con5::Context::style}.{int::InternalStyle::isSeparator}(path.{core::String::codeUnitAt}(i.{core::num::+}(2))))) {
              return null;
            }
          }
          hash = hash.{core::int::&}(67108863);
          hash = hash.{core::num::*}(33);
          hash = hash.{core::int::^}(codeUnit);
          wasSeparator = false;
          beginning = false;
        }
      return hash;
    }
    method withoutExtension(core::String path) → core::String {
      par3::ParsedPath parsed = this.{con5::Context::_parse}(path);
      #L58:
      for (core::int i = parsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::-}(1); i.{core::num::>=}(0); i = i.{core::num::-}(1)) {
        if(!parsed.{par3::ParsedPath::parts}.{core::List::[]}(i).{core::String::isEmpty}) {
          parsed.{par3::ParsedPath::parts}.{core::List::[]=}(i, parsed.{par3::ParsedPath::basenameWithoutExtension});
          break #L58;
        }
      }
      return parsed.{par3::ParsedPath::toString}();
    }
    method setExtension(core::String path, core::String extension) → core::String
      return this.{con5::Context::withoutExtension}(path).{core::String::+}(extension);
    method fromUri(dynamic uri) → core::String
      return this.{con5::Context::style}.{int::InternalStyle::pathFromUri}(con5::_parseUri(uri));
    method toUri(core::String path) → core::Uri {
      if(this.{con5::Context::isRelative}(path)) {
        return this.{con5::Context::style}.{int::InternalStyle::relativePathToUri}(path);
      }
      else {
        return this.{con5::Context::style}.{int::InternalStyle::absolutePathToUri}(this.{con5::Context::join}(this.{con5::Context::current}, path));
      }
    }
    method prettyUri(dynamic uri) → core::String {
      core::Uri typedUri = con5::_parseUri(uri);
      if(typedUri.{core::Uri::scheme}.{core::String::==}("file") && this.{con5::Context::style}.{core::Object::==}(sty::Style::url)) {
        return typedUri.{core::Uri::toString}();
      }
      else
        if(!typedUri.{core::Uri::scheme}.{core::String::==}("file") && !typedUri.{core::Uri::scheme}.{core::String::==}("") && !this.{con5::Context::style}.{core::Object::==}(sty::Style::url)) {
          return typedUri.{core::Uri::toString}();
        }
      core::String path = this.{con5::Context::normalize}(this.{con5::Context::fromUri}(typedUri));
      core::String rel = this.{con5::Context::relative}(path);
      return this.{con5::Context::split}(rel).{core::List::length}.{core::num::>}(this.{con5::Context::split}(path).{core::List::length}) ?{core::String} path : rel;
    }
    method _parse(core::String path) → par3::ParsedPath
      return par3::ParsedPath::parse(path, this.{con5::Context::style});
  }
  class _PathDirection extends core::Object {
    static const field con5::_PathDirection aboveRoot = const con5::_PathDirection::•("above root");
    static const field con5::_PathDirection atRoot = const con5::_PathDirection::•("at root");
    static const field con5::_PathDirection reachesRoot = const con5::_PathDirection::•("reaches root");
    static const field con5::_PathDirection belowRoot = const con5::_PathDirection::•("below root");
    final field core::String name;
    const constructor •(core::String name) → void
      : con5::_PathDirection::name = name, super core::Object::•()
      ;
    method toString() → core::String
      return this.{con5::_PathDirection::name};
  }
  class _PathRelation extends core::Object {
    static const field con5::_PathRelation within = const con5::_PathRelation::•("within");
    static const field con5::_PathRelation equal = const con5::_PathRelation::•("equal");
    static const field con5::_PathRelation different = const con5::_PathRelation::•("different");
    static const field con5::_PathRelation inconclusive = const con5::_PathRelation::•("inconclusive");
    final field core::String name;
    const constructor •(core::String name) → void
      : con5::_PathRelation::name = name, super core::Object::•()
      ;
    method toString() → core::String
      return this.{con5::_PathRelation::name};
  }
  static method createInternal() → con5::Context
    return new con5::Context::_internal();
  static method _parseUri(dynamic uri) → core::Uri {
    if(uri is core::String)
      return core::Uri::parse(uri{core::String});
    if(uri is core::Uri)
      return uri{core::Uri};
    throw new core::ArgumentError::value(uri, "uri", "Value must be a String or a Uri");
  }
  static method _validateArgList(core::String method, core::List<core::String> args) → void {
    for (core::int i = 1; i.{core::num::<}(args.{core::List::length}); i = i.{core::num::+}(1))
      #L59:
      {
        if(args.{core::List::[]}(i).{core::String::==}(null) || !args.{core::List::[]}(i.{core::num::-}(1)).{core::String::==}(null))
          break #L59;
        core::int numArgs;
        #L60:
        for (final dynamic #t340 = numArgs = args.{core::List::length}; numArgs.{core::num::>=}(1); numArgs = numArgs.{core::num::-}(1)) {
          if(!args.{core::List::[]}(numArgs.{core::num::-}(1)).{core::String::==}(null))
            break #L60;
        }
        core::StringBuffer message = new core::StringBuffer::•();
        message.{core::StringBuffer::write}("${method}(");
        message.{core::StringBuffer::write}(args.{core::Iterable::take}(numArgs).{core::Iterable::map}<core::String>((core::String arg) → core::String => arg.{core::String::==}(null) ?{core::String} "null" : "\"${arg}\"").{core::Iterable::join}(", "));
        message.{core::StringBuffer::write}("): part ${i.{core::num::-}(1)} was null, but part ${i} was not.");
        throw new core::ArgumentError::•(message.{core::StringBuffer::toString}());
      }
  }
}
library from "package:path/src/style.dart" as sty {
  import "package:path/src/context.dart";
  import "package:path/src/style/posix.dart";
  import "package:path/src/style/url.dart";
  import "package:path/src/style/windows.dart";
  abstract class Style extends core::Object {
    static final field sty::Style posix = new pos::PosixStyle::•();
    static final field sty::Style windows = new win::WindowsStyle::•();
    static final field sty::Style url = new url::UrlStyle::•();
    static final field sty::Style platform = sty::Style::_getPlatformStyle();
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    static method _getPlatformStyle() → sty::Style {
      if(!core::Uri::base.{core::Uri::scheme}.{core::String::==}("file"))
        return sty::Style::url;
      if(!core::Uri::base.{core::Uri::path}.{core::String::endsWith}("/"))
        return sty::Style::url;
      if(core::_Uri::•(path: "a/b").{core::Uri::toFilePath}().{core::String::==}("a\\b"))
        return sty::Style::windows;
      return sty::Style::posix;
    }
    abstract get name() → core::String;
    get context() → con5::Context
      return con5::Context::•(style: this);
    @core::Deprecated::•("Most Style members will be removed in path 2.0.")
    abstract get separator() → core::String;
    @core::Deprecated::•("Most Style members will be removed in path 2.0.")
    abstract get separatorPattern() → core::Pattern;
    @core::Deprecated::•("Most Style members will be removed in path 2.0.")
    abstract get needsSeparatorPattern() → core::Pattern;
    @core::Deprecated::•("Most Style members will be removed in path 2.0.")
    abstract get rootPattern() → core::Pattern;
    @core::Deprecated::•("Most Style members will be removed in path 2.0.")
    abstract get relativeRootPattern() → core::Pattern;
    @core::Deprecated::•("Most style members will be removed in path 2.0.")
    abstract method getRoot(core::String path) → core::String;
    @core::Deprecated::•("Most style members will be removed in path 2.0.")
    abstract method getRelativeRoot(core::String path) → core::String;
    @core::Deprecated::•("Most style members will be removed in path 2.0.")
    abstract method pathFromUri(core::Uri uri) → core::String;
    @core::Deprecated::•("Most style members will be removed in path 2.0.")
    abstract method relativePathToUri(core::String path) → core::Uri;
    @core::Deprecated::•("Most style members will be removed in path 2.0.")
    abstract method absolutePathToUri(core::String path) → core::Uri;
    method toString() → core::String
      return this.{sty::Style::name};
  }
}
library from "package:path/src/path_exception.dart" as pat {
  class PathException extends core::Object implements core::Exception {
    field core::String message;
    constructor •(core::String message) → void
      : pat::PathException::message = message, super core::Object::•()
      ;
    method toString() → core::String
      return "PathException: ${this.{pat::PathException::message}}";
  }
}
library from "package:path/src/path_map.dart" as pat2 {
  import "dart:collection";
  import "package:path/path.dart" as p;
  class PathMap<V extends core::Object = dynamic> extends col::MapView<core::String, pat2::PathMap::V> {
    constructor •({con5::Context context = null}) → void
      : super col::MapView::•(pat2::PathMap::_create<pat2::PathMap::V>(context))
      ;
    constructor of(core::Map<core::String, pat2::PathMap::V> other, {con5::Context context = null}) → void
      : super col::MapView::•(let final core::Map<core::String, pat2::PathMap::V> #t341 = pat2::PathMap::_create<pat2::PathMap::V>(context) in let final dynamic #t342 = #t341.{core::Map::addAll}(other) in #t341)
      ;
    static method _create<V extends core::Object = dynamic>(con5::Context context) → core::Map<core::String, pat2::PathMap::_create::V> {
      context.{core::Object::==}(null) ?{con5::Context} context = path::context : null;
      return col::LinkedHashMap::•<core::String, pat2::PathMap::_create::V>(equals: (core::String path1, core::String path2) → core::bool {
        if(path1.{core::String::==}(null))
          return path2.{core::String::==}(null);
        if(path2.{core::String::==}(null))
          return false;
        return context.{con5::Context::equals}(path1, path2);
      }, hashCode: (core::String path) → core::int => path.{core::String::==}(null) ?{core::int} 0 : context.{con5::Context::hash}(path), isValidKey: (core::Object path) → core::bool => path is core::String || path.{core::Object::==}(null));
    }
  }
}
library from "package:path/src/path_set.dart" as pat3 {
  import "dart:collection";
  import "package:path/path.dart" as p;
  class PathSet extends col::IterableBase<core::String> implements core::Set<core::String> {
    final field core::Set<core::String> _inner;
    constructor •({con5::Context context = null}) → void
      : pat3::PathSet::_inner = pat3::PathSet::_create(context), super col::IterableBase::•()
      ;
    constructor of(core::Iterable<core::String> other, {con5::Context context = null}) → void
      : pat3::PathSet::_inner = let final core::Set<core::String> #t343 = pat3::PathSet::_create(context) in let final dynamic #t344 = #t343.{core::Set::addAll}(other) in #t343, super col::IterableBase::•()
      ;
    static method _create(con5::Context context) → core::Set<core::String> {
      context.{core::Object::==}(null) ?{con5::Context} context = path::context : null;
      return col::LinkedHashSet::•<core::String>(equals: (core::String path1, core::String path2) → core::bool {
        if(path1.{core::String::==}(null))
          return path2.{core::String::==}(null);
        if(path2.{core::String::==}(null))
          return false;
        return context.{con5::Context::equals}(path1, path2);
      }, hashCode: (core::String path) → core::int => path.{core::String::==}(null) ?{core::int} 0 : context.{con5::Context::hash}(path), isValidKey: (core::Object path) → core::bool => path is core::String || path.{core::Object::==}(null));
    }
    get iterator() → core::Iterator<core::String>
      return this.{pat3::PathSet::_inner}.{core::Set::iterator};
    get length() → core::int
      return this.{pat3::PathSet::_inner}.{_in::EfficientLengthIterable::length};
    method add(generic-covariant-impl core::String value) → core::bool
      return this.{pat3::PathSet::_inner}.{core::Set::add}(value);
    method addAll(generic-covariant-impl core::Iterable<core::String> elements) → void
      return this.{pat3::PathSet::_inner}.{core::Set::addAll}(elements);
    method cast<T extends core::Object = dynamic>() → core::Set<pat3::PathSet::cast::T>
      return this.{pat3::PathSet::_inner}.{core::Set::cast}<pat3::PathSet::cast::T>();
    method clear() → void
      return this.{pat3::PathSet::_inner}.{core::Set::clear}();
    method contains(core::Object other) → core::bool
      return this.{pat3::PathSet::_inner}.{core::Set::contains}(other);
    method containsAll(core::Iterable<core::Object> other) → core::bool
      return this.{pat3::PathSet::_inner}.{core::Set::containsAll}(other);
    method difference(core::Set<core::Object> other) → core::Set<core::String>
      return this.{pat3::PathSet::_inner}.{core::Set::difference}(other);
    method intersection(core::Set<core::Object> other) → core::Set<core::String>
      return this.{pat3::PathSet::_inner}.{core::Set::intersection}(other);
    method lookup(core::Object element) → core::String
      return this.{pat3::PathSet::_inner}.{core::Set::lookup}(element);
    method remove(core::Object value) → core::bool
      return this.{pat3::PathSet::_inner}.{core::Set::remove}(value);
    method removeAll(core::Iterable<core::Object> elements) → void
      return this.{pat3::PathSet::_inner}.{core::Set::removeAll}(elements);
    method removeWhere((core::String) → core::bool test) → void
      return this.{pat3::PathSet::_inner}.{core::Set::removeWhere}(test);
    method retainAll(core::Iterable<core::Object> elements) → void
      return this.{pat3::PathSet::_inner}.{core::Set::retainAll}(elements);
    method retainWhere((core::String) → core::bool test) → void
      return this.{pat3::PathSet::_inner}.{core::Set::retainWhere}(test);
    method union(generic-covariant-impl core::Set<core::String> other) → core::Set<core::String>
      return this.{pat3::PathSet::_inner}.{core::Set::union}(other);
    method toSet() → core::Set<core::String>
      return this.{pat3::PathSet::_inner}.{core::Set::toSet}();
  }
}
library from "package:file/src/forwarding.dart" as for {
  export "package:file/src/forwarding/forwarding_directory.dart";
  export "package:file/src/forwarding/forwarding_file.dart";
  export "package:file/src/forwarding/forwarding_file_system.dart";
  export "package:file/src/forwarding/forwarding_file_system_entity.dart";
  export "package:file/src/forwarding/forwarding_link.dart";
}
library file.src.interface from "package:file/src/interface.dart" as int2 {
  export "package:file/src/interface/directory.dart";
  export "package:file/src/interface/error_codes.dart";
  export "package:file/src/interface/file.dart";
  export "package:file/src/interface/file_system.dart";
  export "package:file/src/interface/file_system_entity.dart";
  export "package:file/src/interface/link.dart";
  export "package:file/src/io.dart";
}
library mime.multipart_transformer from "package:mime/src/mime_multipart_transformer.dart" as mul {
  import "dart:async";
  import "dart:typed_data";
  import "package:mime/src/bound_multipart_stream.dart";
  import "package:mime/src/char_code.dart";
  import "package:mime/src/mime_shared.dart";
  class MimeMultipartTransformer extends asy::StreamTransformerBase<core::List<core::int>, sha::MimeMultipart> {
    final field core::List<core::int> _boundary;
    constructor •(core::String boundary) → void
      : mul::MimeMultipartTransformer::_boundary = mul::_getBoundary(boundary), super asy::StreamTransformerBase::•()
      ;
    method bind(generic-covariant-impl asy::Stream<core::List<core::int>> stream) → asy::Stream<sha::MimeMultipart> {
      return new bou::BoundMultipartStream::•(this.{mul::MimeMultipartTransformer::_boundary}, stream).{bou::BoundMultipartStream::stream};
    }
  }
  static method _getBoundary(core::String boundary) → typ2::Uint8List {
    core::List<core::int> charCodes = boundary.{core::String::codeUnits};
    typ2::Uint8List boundaryList = imp::NativeUint8List::•(4.{core::num::+}(charCodes.{core::List::length}));
    boundaryList.{core::List::[]=}(0, cha2::CharCode::CR);
    boundaryList.{core::List::[]=}(1, cha2::CharCode::LF);
    boundaryList.{core::List::[]=}(2, cha2::CharCode::DASH);
    boundaryList.{core::List::[]=}(3, cha2::CharCode::DASH);
    boundaryList.{core::List::setRange}(4, 4.{core::num::+}(charCodes.{core::List::length}), charCodes);
    return boundaryList;
  }
}
library mime.shared from "package:mime/src/mime_shared.dart" as sha {
  import "dart:async";
  class MimeMultipartException extends core::Object implements core::Exception {
    final field core::String message;
    const constructor •([core::String message = ""]) → void
      : sha::MimeMultipartException::message = message, super core::Object::•()
      ;
    method toString() → core::String
      return "MimeMultipartException: ${this.{sha::MimeMultipartException::message}}";
  }
  abstract class MimeMultipart extends asy::Stream<core::List<core::int>> {
    synthetic constructor •() → void
      : super asy::Stream::•()
      ;
    abstract get headers() → core::Map<core::String, core::String>;
  }
}
library mime.mime_type from "package:mime/src/mime_type.dart" as mim {
  import "package:mime/src/default_extension_map.dart";
  import "package:mime/src/magic_number.dart";
  class MimeTypeResolver extends core::Object {
    final field core::Map<core::String, core::String> _extensionMap = <core::String, core::String>{};
    final field core::List<mag::MagicNumber> _magicNumbers = <mag::MagicNumber>[];
    final field core::bool _useDefault;
    field core::int _magicNumbersMaxLength;
    constructor empty() → void
      : mim::MimeTypeResolver::_useDefault = false, mim::MimeTypeResolver::_magicNumbersMaxLength = 0, super core::Object::•()
      ;
    constructor •() → void
      : mim::MimeTypeResolver::_useDefault = true, mim::MimeTypeResolver::_magicNumbersMaxLength = mag::DEFAULT_MAGIC_NUMBERS_MAX_LENGTH, super core::Object::•()
      ;
    get magicNumbersMaxLength() → core::int
      return this.{mim::MimeTypeResolver::_magicNumbersMaxLength};
    method lookup(core::String path, {core::List<core::int> headerBytes = null}) → core::String {
      core::String result;
      if(!headerBytes.{core::Object::==}(null)) {
        result = mim::MimeTypeResolver::_matchMagic(headerBytes, this.{mim::MimeTypeResolver::_magicNumbers});
        if(!result.{core::String::==}(null))
          return result;
        if(this.{mim::MimeTypeResolver::_useDefault}) {
          result = mim::MimeTypeResolver::_matchMagic(headerBytes, mag::DEFAULT_MAGIC_NUMBERS);
          if(!result.{core::String::==}(null))
            return result;
        }
      }
      core::String ext = mim::MimeTypeResolver::_ext(path);
      result = this.{mim::MimeTypeResolver::_extensionMap}.{core::Map::[]}(ext);
      if(!result.{core::String::==}(null))
        return result;
      if(this.{mim::MimeTypeResolver::_useDefault}) {
        result = ext::defaultExtensionMap.{core::Map::[]}(ext);
        if(!result.{core::String::==}(null))
          return result;
      }
      return null;
    }
    method addExtension(core::String extension, core::String mimeType) → void {
      this.{mim::MimeTypeResolver::_extensionMap}.{core::Map::[]=}(extension, mimeType);
    }
    method addMagicNumber(core::List<core::int> bytes, core::String mimeType, {core::List<core::int> mask = null}) → void {
      if(!mask.{core::Object::==}(null) && !bytes.{core::List::length}.{core::num::==}(mask.{core::List::length})) {
        throw new core::ArgumentError::•("Bytes and mask are of different lengths");
      }
      if(bytes.{core::List::length}.{core::num::>}(this.{mim::MimeTypeResolver::_magicNumbersMaxLength})) {
        this.{mim::MimeTypeResolver::_magicNumbersMaxLength} = bytes.{core::List::length};
      }
      this.{mim::MimeTypeResolver::_magicNumbers}.{core::List::add}(new mag::MagicNumber::•(mimeType, bytes, mask: mask));
    }
    static method _matchMagic(core::List<core::int> headerBytes, core::List<mag::MagicNumber> magicNumbers) → core::String {
      for (mag::MagicNumber mn in magicNumbers) {
        if(mn.{mag::MagicNumber::matches}(headerBytes))
          return mn.{mag::MagicNumber::mimeType};
      }
      return null;
    }
    static method _ext(core::String path) → core::String {
      core::int index = path.{core::String::lastIndexOf}(".");
      if(index.{core::num::<}(0) || index.{core::num::+}(1).{core::num::>=}(path.{core::String::length}))
        return path;
      return path.{core::String::substring}(index.{core::num::+}(1)).{core::String::toLowerCase}();
    }
  }
  static final field mim::MimeTypeResolver _globalResolver = new mim::MimeTypeResolver::•();
  static get defaultMagicNumbersMaxLength() → core::int
    return mim::_globalResolver.{mim::MimeTypeResolver::magicNumbersMaxLength};
  static method lookupMimeType(core::String path, {core::List<core::int> headerBytes = null}) → core::String
    return mim::_globalResolver.{mim::MimeTypeResolver::lookup}(path, headerBytes: headerBytes);
}
library lex.src.combinator from "package:combinator/src/combinator/combinator.dart" as com {
  import "dart:collection";
  import "package:code_buffer/code_buffer.dart";
  import "package:matcher/matcher.dart";
  import "package:source_span/source_span.dart";
  import "package:string_scanner/string_scanner.dart";
  import "package:tuple/tuple.dart";
  import "package:combinator/src/error.dart";
  class ParseArgs extends core::Object {
    final field com::Trampoline trampoline;
    final field spa::SpanScanner scanner;
    final field core::int depth;
    constructor •(com::Trampoline trampoline, spa::SpanScanner scanner, core::int depth) → void
      : com::ParseArgs::trampoline = trampoline, com::ParseArgs::scanner = scanner, com::ParseArgs::depth = depth, super core::Object::•()
      ;
    method increaseDepth() → com::ParseArgs
      return new com::ParseArgs::•(this.{com::ParseArgs::trampoline}, this.{com::ParseArgs::scanner}, this.{com::ParseArgs::depth}.{core::num::+}(1));
  }
  abstract class Parser<T extends core::Object = dynamic> extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract method __parse(com::ParseArgs args) → com::ParseResult<com::Parser::T>;
    method _parse(com::ParseArgs args) → com::ParseResult<com::Parser::T> {
      core::int pos = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      if(args.{com::ParseArgs::trampoline}.{com::Trampoline::hasMemoized}(this, pos))
        return args.{com::ParseArgs::trampoline}.{com::Trampoline::getMemoized}<com::Parser::T>(this, pos);
      if(args.{com::ParseArgs::trampoline}.{com::Trampoline::isActive}(this, pos))
        return new com::ParseResult::•<com::Parser::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, <err::SyntaxError>[]);
      args.{com::ParseArgs::trampoline}.{com::Trampoline::enter}(this, pos);
      com::ParseResult<com::Parser::T> result = this.{com::Parser::__parse}(args);
      args.{com::ParseArgs::trampoline}.{com::Trampoline::memoize}(this, pos, result);
      args.{com::ParseArgs::trampoline}.{com::Trampoline::exit}(this);
      return result;
    }
    method parse(spa::SpanScanner scanner, [core::int depth = 1]) → com::ParseResult<com::Parser::T> {
      com::ParseArgs args = new com::ParseArgs::•(new com::Trampoline::•(), scanner, depth);
      return this.{com::Parser::_parse}(args);
    }
    method forward(core::int amount) → com::Parser<com::Parser::T>
      return new com::_Advance::•<com::Parser::T>(this, amount);
    method back(core::int amount) → com::Parser<com::Parser::T>
      return new com::_Advance::•<com::Parser::T>(this, amount.{core::num::*}(1.{core::int::unary-}()));
    method cast<generic-covariant-impl U extends com::Parser::T = com::Parser::T>() → com::Parser<com::Parser::cast::U>
      return new com::_Cast::•<com::Parser::T, com::Parser::cast::U>(this);
    method castDynamic() → com::Parser<dynamic>
      return new com::_CastDynamic::•<com::Parser::T>(this);
    method change<U extends core::Object = dynamic>((com::ParseResult<com::Parser::T>) → com::ParseResult<com::Parser::change::U> f) → com::Parser<com::Parser::change::U> {
      return new com::_Change::•<com::Parser::T, com::Parser::change::U>(this, f);
    }
    method check(int3::Matcher matcher, {core::String errorMessage = null, err::SyntaxErrorSeverity severity = null}) → com::Parser<com::Parser::T>
      return new com::_Check::•<com::Parser::T>(this, matcher, errorMessage, let final err::SyntaxErrorSeverity #t345 = severity in #t345.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t345);
    method error({core::String errorMessage = null, err::SyntaxErrorSeverity severity = null}) → com::Parser<com::Parser::T>
      return new com::_Alt::•<com::Parser::T>(this, errorMessage, let final err::SyntaxErrorSeverity #t346 = severity in #t346.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t346);
    method foldErrors({(err::SyntaxError, err::SyntaxError) → core::bool equal = null}) → com::Parser<com::Parser::T> {
      equal.{core::Object::==}(null) ?{(err::SyntaxError, err::SyntaxError) → core::bool} equal = (err::SyntaxError b, err::SyntaxError e) → core::bool => b.{err::SyntaxError::span}.{file3::FileSpan::start}.{file3::FileLocation::offset}.{core::num::==}(e.{err::SyntaxError::span}.{file3::FileSpan::start}.{file3::FileLocation::offset}) : null;
      return new com::_FoldErrors::•<com::Parser::T>(this, equal);
    }
    method map<U extends core::Object = dynamic>((com::ParseResult<com::Parser::T>) → com::Parser::map::U f) → com::Parser<com::Parser::map::U> {
      return new com::_Map::•<com::Parser::T, com::Parser::map::U>(this, f);
    }
    method maxDepth(core::int depth) → com::Parser<com::Parser::T>
      return new com::_MaxDepth::•<com::Parser::T>(this, depth);
    operator ~() → com::Parser<com::Parser::T>
      return this.{com::Parser::negate}();
    method negate({core::String errorMessage = null, err::SyntaxErrorSeverity severity = null}) → com::Parser<com::Parser::T>
      return new com::_Negate::•<com::Parser::T>(this, errorMessage, let final err::SyntaxErrorSeverity #t347 = severity in #t347.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t347);
    method cache() → com::Parser<com::Parser::T>
      return new com::_Cache::•<com::Parser::T>(this);
    operator &(generic-covariant-impl com::Parser<com::Parser::T> other) → com::Parser<com::Parser::T>
      return this.{com::Parser::and}(other);
    method and(com::Parser<dynamic> other) → com::Parser<com::Parser::T>
      return this.{com::Parser::then}(other).{com::Parser::change}<com::Parser::T>((com::ParseResult<core::List<dynamic>> r) → com::ParseResult<com::Parser::T> {
        return new com::ParseResult::•<com::Parser::T>(r.{com::ParseResult::trampoline}, r.{com::ParseResult::scanner}, this, r.{com::ParseResult::successful}, r.{com::ParseResult::errors}, span: r.{com::ParseResult::span}, value: (!r.{com::ParseResult::value}.{core::Object::==}(null) ?{dynamic} r.{com::ParseResult::value}.{core::List::[]}(0) : r.{com::ParseResult::value}) as com::Parser::T);
      });
    operator |(generic-covariant-impl com::Parser<com::Parser::T> other) → com::Parser<com::Parser::T>
      return this.{com::Parser::or}<dynamic>(other);
    method or<U extends core::Object = dynamic>(generic-covariant-impl com::Parser<com::Parser::T> other) → com::Parser<com::Parser::T>
      return com::any<com::Parser::T>(<com::Parser<com::Parser::T>>[this, other]);
    method plus() → com::ListParser<com::Parser::T>
      return this.{com::Parser::times}(1, exact: false);
    method safe({core::bool backtrack = true, core::String errorMessage = null, err::SyntaxErrorSeverity severity = null}) → com::Parser<com::Parser::T>
      return new com::_Safe::•<com::Parser::T>(this, backtrack, errorMessage, let final err::SyntaxErrorSeverity #t348 = severity in #t348.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t348);
    method separatedByComma() → com::Parser<core::List<com::Parser::T>>
      return this.{com::Parser::separatedBy}(com::match<core::List<com::Parser::T>>(",").{com::Parser::space}());
    method separatedBy(com::Parser<dynamic> other) → com::Parser<core::List<com::Parser::T>> {
      com::Parser<com::Parser::T> suffix = other.{com::Parser::then}(this).{com::ListParser::index}(1).{com::Parser::cast}<com::Parser::T>();
      return this.{com::Parser::then}(suffix.{com::Parser::star}()).{com::Parser::map}<core::List<com::Parser::T>>((com::ParseResult<core::List<dynamic>> r) → core::List<com::Parser::T> {
        core::List<dynamic> preceding = r.{com::ParseResult::value}.{core::Iterable::isEmpty} ?{core::List<dynamic>} <dynamic>[] : r.{com::ParseResult::value}.{core::List::[]}(0).{core::Object::==}(null) ?{core::List<dynamic>} <dynamic>[] : <dynamic>[r.{com::ParseResult::value}.{core::List::[]}(0)];
        core::List<com::Parser::T> out = core::List::from<com::Parser::T>(preceding);
        if(!r.{com::ParseResult::value}.{core::List::[]}(1).{core::Object::==}(null))
          out.{core::List::addAll}(r.{com::ParseResult::value}.{core::List::[]}(1) as core::Iterable<com::Parser::T>);
        return out;
      });
    }
    method surroundedByCurlyBraces({generic-covariant-impl com::Parser::T defaultValue = null}) → com::Parser<com::Parser::T>
      return this.{com::Parser::opt}().{com::Parser::surroundedBy}(com::match<dynamic>("{").{com::Parser::space}(), com::match<dynamic>("}").{com::Parser::space}()).{com::Parser::map}<com::Parser::T>((com::ParseResult<com::Parser::T> r) → com::Parser::T => let final com::Parser::T #t349 = r.{com::ParseResult::value} in #t349.==(null) ?{com::Parser::T} defaultValue : #t349);
    method surroundedBySquareBrackets({generic-covariant-impl com::Parser::T defaultValue = null}) → com::Parser<com::Parser::T>
      return this.{com::Parser::opt}().{com::Parser::surroundedBy}(com::match<dynamic>("[").{com::Parser::space}(), com::match<dynamic>("]").{com::Parser::space}()).{com::Parser::map}<com::Parser::T>((com::ParseResult<com::Parser::T> r) → com::Parser::T => let final com::Parser::T #t350 = r.{com::ParseResult::value} in #t350.==(null) ?{com::Parser::T} defaultValue : #t350);
    method surroundedBy(com::Parser<dynamic> left, [com::Parser<dynamic> right = null]) → com::Parser<com::Parser::T> {
      return com::chain<dynamic>(<com::Parser<dynamic>>[left, this, let final com::Parser<dynamic> #t351 = right in #t351.==(null) ?{com::Parser<dynamic>} left : #t351]).{com::ListParser::index}(1).{com::Parser::castDynamic}().{com::Parser::cast}<com::Parser::T>();
    }
    method maybeParenthesized() → com::Parser<com::Parser::T> {
      return com::any<com::Parser::T>(<com::Parser<com::Parser::T>>[this.{com::Parser::parenthesized}(), this]);
    }
    method parenthesized() → com::Parser<com::Parser::T>
      return this.{com::Parser::surroundedBy}(com::match<dynamic>("(").{com::Parser::space}(), com::match<dynamic>(")").{com::Parser::space}());
    method space() → com::Parser<com::Parser::T>
      return this.{com::Parser::trail}(core::RegExp::•("[ \\n\\r\\t]+"));
    method star({core::bool backtrack = true}) → com::ListParser<com::Parser::T>
      return this.{com::Parser::times}(1, exact: false, backtrack: backtrack).{com::ListParser::opt}();
    method then(com::Parser<dynamic> other) → com::ListParser<dynamic>
      return com::chain<dynamic>(<com::Parser<dynamic>>[this, other]);
    method toList() → com::ListParser<com::Parser::T>
      return new com::_ToList::•<com::Parser::T>(this);
    method trail(core::Pattern pattern) → com::Parser<com::Parser::T>
      return this.{com::Parser::then}(com::match<dynamic>(pattern).{com::Parser::opt}()).{com::ListParser::first}().{com::Parser::cast}<com::Parser::T>();
    method times(core::int count, {core::bool exact = true, core::String tooFew = null, core::String tooMany = null, core::bool backtrack = true, err::SyntaxErrorSeverity severity = null}) → com::ListParser<com::Parser::T> {
      return new com::_Repeat::•<com::Parser::T>(this, count, exact, tooFew, tooMany, backtrack, let final err::SyntaxErrorSeverity #t352 = severity in #t352.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t352);
    }
    method opt({core::bool backtrack = true}) → com::Parser<com::Parser::T>
      return new com::_Opt::•<com::Parser::T>(this, backtrack);
    method value(generic-covariant-impl (com::ParseResult<com::Parser::T>) → com::Parser::T f) → com::Parser<com::Parser::T> {
      return new com::_Value::•<com::Parser::T>(this, f);
    }
    abstract method stringify(cod::CodeBuffer buffer) → void;
    @core::override
    method toString() → core::String {
      return super.{core::Object::toString}();
      cod::CodeBuffer b = new cod::CodeBuffer::•();
      this.{com::Parser::stringify}(b);
      return b.{cod::CodeBuffer::toString}();
    }
  }
  abstract class ListParser<T extends core::Object = dynamic> extends com::Parser<core::List<com::ListParser::T>> {
    synthetic constructor •() → void
      : super com::Parser::•()
      ;
    method first() → com::Parser<com::ListParser::T>
      return this.{com::ListParser::index}(0);
    method index(core::int i) → com::Parser<com::ListParser::T>
      return new com::_Index::•<com::ListParser::T>(this, i);
    method last() → com::Parser<com::ListParser::T>
      return this.{com::ListParser::index}(1.{core::int::unary-}());
    method reduce(generic-covariant-impl (com::ListParser::T, com::ListParser::T) → com::ListParser::T combine) → com::Parser<com::ListParser::T>
      return new com::_Reduce::•<com::ListParser::T>(this, combine);
    method sort((com::ListParser::T, com::ListParser::T) → core::int compare) → com::ListParser<com::ListParser::T>
      return new com::_Compare::•<com::ListParser::T>(this, compare);
    @core::override
    method opt({core::bool backtrack = true}) → com::ListParser<com::ListParser::T>
      return new com::_ListOpt::•<com::ListParser::T>(this, backtrack);
    method where((com::ListParser::T) → core::bool f) → com::Parser<core::List<com::ListParser::T>>
      return this.{com::Parser::map}<core::List<com::ListParser::T>>((com::ParseResult<core::List<com::ListParser::T>> r) → core::List<com::ListParser::T> => r.{com::ParseResult::value}.{core::Iterable::where}(f).{core::Iterable::toList}());
    method flatten() → com::Parser<core::String>
      return this.{com::Parser::map}<core::String>((com::ParseResult<core::List<com::ListParser::T>> r) → core::String => r.{com::ParseResult::span}.{span::SourceSpanBase::text});
  }
  class Trampoline extends core::Object {
    final field core::Map<com::Parser<dynamic>, col::Queue<core::int>> _active = <com::Parser<dynamic>, col::Queue<core::int>>{};
    final field core::Map<com::Parser<dynamic>, core::List<tup::Tuple2<core::int, com::ParseResult<dynamic>>>> _memo = <com::Parser<dynamic>, core::List<tup::Tuple2<core::int, com::ParseResult<dynamic>>>>{};
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    method hasMemoized(com::Parser<dynamic> parser, core::int position) → core::bool {
      core::List<tup::Tuple2<core::int, com::ParseResult<dynamic>>> list = this.{com::Trampoline::_memo}.{core::Map::[]}(parser);
      return (let final core::List<tup::Tuple2<core::int, com::ParseResult<dynamic>>> #t353 = list in #t353.==(null) ?{core::bool} null : #t353.{core::Iterable::any}((tup::Tuple2<core::int, com::ParseResult<dynamic>> t) → core::bool => t.{tup::Tuple2::item1}.{core::num::==}(position))).{core::Object::==}(true);
    }
    method getMemoized<T extends core::Object = dynamic>(com::Parser<dynamic> parser, core::int position) → com::ParseResult<com::Trampoline::getMemoized::T> {
      return this.{com::Trampoline::_memo}.{core::Map::[]}(parser).{core::Iterable::firstWhere}((tup::Tuple2<core::int, com::ParseResult<dynamic>> t) → core::bool => t.{tup::Tuple2::item1}.{core::num::==}(position)).{tup::Tuple2::item2} as com::ParseResult<com::Trampoline::getMemoized::T>;
    }
    method memoize(com::Parser<dynamic> parser, core::int position, com::ParseResult<dynamic> result) → void {
      if(!result.{core::Object::==}(null)) {
        core::List<tup::Tuple2<core::int, com::ParseResult<dynamic>>> list = this.{com::Trampoline::_memo}.{core::Map::putIfAbsent}(parser, () → core::List<tup::Tuple2<core::int, com::ParseResult<dynamic>>> => <tup::Tuple2<core::int, com::ParseResult<dynamic>>>[]);
        tup::Tuple2<core::int, com::ParseResult<dynamic>> tuple = new tup::Tuple2::•<core::int, com::ParseResult<dynamic>>(position, result);
        if(!list.{core::Iterable::contains}(tuple))
          list.{core::List::add}(tuple);
      }
    }
    method isActive(com::Parser<dynamic> parser, core::int position) → core::bool {
      if(!this.{com::Trampoline::_active}.{core::Map::containsKey}(parser))
        return false;
      col::Queue<core::int> q = this.{com::Trampoline::_active}.{core::Map::[]}(parser);
      if(q.{core::Iterable::isEmpty})
        return false;
      return q.{core::Iterable::first}.{core::num::==}(position);
    }
    method enter(com::Parser<dynamic> parser, core::int position) → void {
      this.{com::Trampoline::_active}.{core::Map::putIfAbsent}(parser, () → col::Queue<core::int> => new col::ListQueue::•<core::int>()).{col::Queue::addFirst}(position);
    }
    method exit(com::Parser<dynamic> parser) → void {
      if(this.{com::Trampoline::_active}.{core::Map::containsKey}(parser))
        this.{com::Trampoline::_active}.{core::Map::[]}(parser).{col::Queue::removeFirst}();
    }
  }
  class ParseResult<T extends core::Object = dynamic> extends core::Object {
    final field com::Parser<com::ParseResult::T> parser;
    final field core::bool successful;
    final field core::Iterable<err::SyntaxError> errors;
    final field file3::FileSpan span;
    final field com::ParseResult::T value;
    final field spa::SpanScanner scanner;
    final field com::Trampoline trampoline;
    constructor •(com::Trampoline trampoline, spa::SpanScanner scanner, com::Parser<com::ParseResult::T> parser, core::bool successful, core::Iterable<err::SyntaxError> errors, {file3::FileSpan span = null, com::ParseResult::T value = null}) → void
      : com::ParseResult::trampoline = trampoline, com::ParseResult::scanner = scanner, com::ParseResult::parser = parser, com::ParseResult::successful = successful, com::ParseResult::errors = errors, com::ParseResult::span = span, com::ParseResult::value = value, super core::Object::•()
      ;
    method change({generic-covariant-impl com::Parser<com::ParseResult::T> parser = null, core::bool successful = null, core::Iterable<err::SyntaxError> errors = null, file3::FileSpan span = null, generic-covariant-impl com::ParseResult::T value = null}) → com::ParseResult<com::ParseResult::T> {
      return new com::ParseResult::•<com::ParseResult::T>(this.{com::ParseResult::trampoline}, this.{com::ParseResult::scanner}, let final com::Parser<com::ParseResult::T> #t354 = parser in #t354.==(null) ?{com::Parser<com::ParseResult::T>} this.{com::ParseResult::parser} : #t354, let final core::bool #t355 = successful in #t355.==(null) ?{core::bool} this.{com::ParseResult::successful} : #t355, let final core::Iterable<err::SyntaxError> #t356 = errors in #t356.==(null) ?{core::Iterable<err::SyntaxError>} this.{com::ParseResult::errors} : #t356, span: let final file3::FileSpan #t357 = span in #t357.==(null) ?{file3::FileSpan} this.{com::ParseResult::span} : #t357, value: let final com::ParseResult::T #t358 = value in #t358.==(null) ?{com::ParseResult::T} this.{com::ParseResult::value} : #t358);
    }
    method addErrors(core::Iterable<err::SyntaxError> errors) → com::ParseResult<com::ParseResult::T> {
      return this.{com::ParseResult::change}(errors: let final core::List<err::SyntaxError> #t359 = core::List::from<err::SyntaxError>(this.{com::ParseResult::errors}) in let final dynamic #t360 = #t359.{core::List::addAll}(errors) in #t359);
    }
  }
  class _Any<T extends core::Object = dynamic> extends com::Parser<com::_Any::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/any.dart
    final field core::Iterable<com::Parser<com::_Any::T>> parsers;
    final field core::bool backtrack;
    final field dynamic errorMessage;
    final field err::SyntaxErrorSeverity severity;
    constructor •(core::Iterable<com::Parser<com::_Any::T>> parsers, core::bool backtrack, dynamic errorMessage, err::SyntaxErrorSeverity severity) → void
      : com::_Any::parsers = parsers, com::_Any::backtrack = backtrack, com::_Any::errorMessage = errorMessage, com::_Any::severity = severity, super com::Parser::•()
      ;
    @core::override
    method _parse(com::ParseArgs args) → com::ParseResult<com::_Any::T> {
      core::Iterable<com::Parser<com::_Any::T>> inactive = this.{com::_Any::parsers}.{core::Iterable::where}((com::Parser<com::_Any::T> p) → core::bool => !args.{com::ParseArgs::trampoline}.{com::Trampoline::isActive}(p, args.{com::ParseArgs::scanner}.{str::StringScanner::position}));
      if(inactive.{core::Iterable::isEmpty}) {
        return new com::ParseResult::•<com::_Any::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, <err::SyntaxError>[]);
      }
      core::List<err::SyntaxError> errors = <err::SyntaxError>[];
      core::int replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      for (com::Parser<com::_Any::T> parser in inactive) {
        com::ParseResult<com::_Any::T> result = parser.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
        if(result.{com::ParseResult::successful})
          return result;
        else {
          if(this.{com::_Any::backtrack})
            args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
          if(parser is com::_Alt<dynamic>)
            errors.{core::List::addAll}(result.{com::ParseResult::errors});
        }
      }
      if(!this.{com::_Any::errorMessage}.{core::Object::==}(false)) {
        errors.{core::List::add}(new err::SyntaxError::•(this.{com::_Any::severity}, let final core::String #t361 = let final dynamic #t362 = this.{com::_Any::errorMessage} in #t362.==(null) ?{core::String} null : #t362.{core::Object::toString}() in #t361.==(null) ?{core::String} "No match found for ${this.{com::_Any::parsers}.{core::Iterable::length}} alternative(s)" : #t361, args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan}));
      }
      return new com::ParseResult::•<com::_Any::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, errors);
    }
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Any::T> {
      return null;
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t363 = buffer in let final dynamic #t364 = #t363.{cod::CodeBuffer::writeln}("any(${this.{com::_Any::parsers}.{core::Iterable::length}}) (") in let final dynamic #t365 = #t363.{cod::CodeBuffer::indent}() in #t363;
      core::int i = 1;
      for (com::Parser<com::_Any::T> parser in this.{com::_Any::parsers}) {
        let final cod::CodeBuffer #t366 = buffer in let final dynamic #t367 = #t366.{cod::CodeBuffer::writeln}("#${let final core::int #t368 = i in let final core::int #t369 = i = #t368.{core::num::+}(1) in #t368}:") in let final dynamic #t370 = #t366.{cod::CodeBuffer::indent}() in #t366;
        parser.{com::Parser::stringify}(buffer);
        buffer.{cod::CodeBuffer::outdent}();
      }
      let final cod::CodeBuffer #t371 = buffer in let final dynamic #t372 = #t371.{cod::CodeBuffer::outdent}() in let final dynamic #t373 = #t371.{cod::CodeBuffer::writeln}(")") in #t371;
    }
  }
  class _Advance<T extends core::Object = dynamic> extends com::Parser<com::_Advance::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/advance.dart
    final field com::Parser<com::_Advance::T> parser;
    final field core::int amount;
    constructor •(com::Parser<com::_Advance::T> parser, core::int amount) → void
      : com::_Advance::parser = parser, com::_Advance::amount = amount, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Advance::T> {
      com::ParseResult<com::_Advance::T> result = this.{com::_Advance::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}()).{com::ParseResult::change}(parser: this);
      if(result.{com::ParseResult::successful})
        let final spa::SpanScanner #t374 = args.{com::ParseArgs::scanner} in #t374.{str::StringScanner::position} = #t374.{str::StringScanner::position}.{core::num::+}(this.{com::_Advance::amount});
      return result;
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t375 = buffer in let final dynamic #t376 = #t375.{cod::CodeBuffer::writeln}("advance(${this.{com::_Advance::amount}}) (") in let final dynamic #t377 = #t375.{cod::CodeBuffer::indent}() in #t375;
      this.{com::_Advance::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t378 = buffer in let final dynamic #t379 = #t378.{cod::CodeBuffer::outdent}() in let final dynamic #t380 = #t378.{cod::CodeBuffer::writeln}(")") in #t378;
    }
  }
  class _Cache<T extends core::Object = dynamic> extends com::Parser<com::_Cache::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/cache.dart
    final field core::Map<core::int, com::ParseResult<com::_Cache::T>> _cache = <core::int, com::ParseResult<com::_Cache::T>>{};
    final field com::Parser<com::_Cache::T> parser;
    constructor •(com::Parser<com::_Cache::T> parser) → void
      : com::_Cache::parser = parser, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Cache::T> {
      return this.{com::_Cache::_cache}.{core::Map::putIfAbsent}(args.{com::ParseArgs::scanner}.{str::StringScanner::position}, () → com::ParseResult<com::_Cache::T> {
        return this.{com::_Cache::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      }).{com::ParseResult::change}(parser: this);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t381 = buffer in let final dynamic #t382 = #t381.{cod::CodeBuffer::writeln}("cache(${this.{com::_Cache::_cache}.{core::Map::length}}) (") in let final dynamic #t383 = #t381.{cod::CodeBuffer::indent}() in #t381;
      this.{com::_Cache::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t384 = buffer in let final dynamic #t385 = #t384.{cod::CodeBuffer::outdent}() in let final dynamic #t386 = #t384.{cod::CodeBuffer::writeln}(")") in #t384;
    }
  }
  class _Cast<T extends core::Object = dynamic, U extends com::_Cast::T = dynamic> extends com::Parser<com::_Cast::U> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/cast.dart
    final field com::Parser<com::_Cast::T> parser;
    constructor •(com::Parser<com::_Cast::T> parser) → void
      : com::_Cast::parser = parser, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Cast::U> {
      com::ParseResult<com::_Cast::T> result = this.{com::_Cast::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      return new com::ParseResult::•<com::_Cast::U>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, result.{com::ParseResult::successful}, result.{com::ParseResult::errors}, span: result.{com::ParseResult::span}, value: result.{com::ParseResult::value} as com::_Cast::U);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t387 = buffer in let final dynamic #t388 = #t387.{cod::CodeBuffer::writeln}("cast<${com::_Cast::U}> (") in let final dynamic #t389 = #t387.{cod::CodeBuffer::indent}() in #t387;
      this.{com::_Cast::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t390 = buffer in let final dynamic #t391 = #t390.{cod::CodeBuffer::outdent}() in let final dynamic #t392 = #t390.{cod::CodeBuffer::writeln}(")") in #t390;
    }
  }
  class _CastDynamic<T extends core::Object = dynamic> extends com::Parser<dynamic> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/cast.dart
    final field com::Parser<com::_CastDynamic::T> parser;
    constructor •(com::Parser<com::_CastDynamic::T> parser) → void
      : com::_CastDynamic::parser = parser, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<dynamic> {
      com::ParseResult<com::_CastDynamic::T> result = this.{com::_CastDynamic::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      return new com::ParseResult::•<dynamic>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, result.{com::ParseResult::successful}, result.{com::ParseResult::errors}, span: result.{com::ParseResult::span}, value: result.{com::ParseResult::value});
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t393 = buffer in let final dynamic #t394 = #t393.{cod::CodeBuffer::writeln}("cast<dynamic> (") in let final dynamic #t395 = #t393.{cod::CodeBuffer::indent}() in #t393;
      this.{com::_CastDynamic::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t396 = buffer in let final dynamic #t397 = #t396.{cod::CodeBuffer::outdent}() in let final dynamic #t398 = #t396.{cod::CodeBuffer::writeln}(")") in #t396;
    }
  }
  class _Alt<T extends core::Object = dynamic> extends com::Parser<com::_Alt::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/chain.dart
    final field com::Parser<com::_Alt::T> parser;
    final field core::String errorMessage;
    final field err::SyntaxErrorSeverity severity;
    constructor •(com::Parser<com::_Alt::T> parser, core::String errorMessage, err::SyntaxErrorSeverity severity) → void
      : com::_Alt::parser = parser, com::_Alt::errorMessage = errorMessage, com::_Alt::severity = severity, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Alt::T> {
      com::ParseResult<com::_Alt::T> result = this.{com::_Alt::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      return result.{com::ParseResult::successful} ?{com::ParseResult<com::_Alt::T>} result : result.{com::ParseResult::addErrors}(<err::SyntaxError>[new err::SyntaxError::•(let final err::SyntaxErrorSeverity #t399 = this.{com::_Alt::severity} in #t399.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t399, this.{com::_Alt::errorMessage}, let final file3::FileSpan #t400 = result.{com::ParseResult::span} in #t400.==(null) ?{file3::FileSpan} args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan} : #t400)]);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      this.{com::_Alt::parser}.{com::Parser::stringify}(buffer);
    }
  }
  class _Chain<T extends core::Object = dynamic> extends com::ListParser<com::_Chain::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/chain.dart
    final field core::Iterable<com::Parser<com::_Chain::T>> parsers;
    final field core::bool failFast;
    final field err::SyntaxErrorSeverity severity;
    constructor •(core::Iterable<com::Parser<com::_Chain::T>> parsers, core::bool failFast, err::SyntaxErrorSeverity severity) → void
      : com::_Chain::parsers = parsers, com::_Chain::failFast = failFast, com::_Chain::severity = severity, super com::ListParser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<core::List<com::_Chain::T>> {
      core::List<err::SyntaxError> errors = <err::SyntaxError>[];
      core::List<com::_Chain::T> results = <com::_Chain::T>[];
      core::List<file3::FileSpan> spans = <file3::FileSpan>[];
      core::bool successful = true;
      for (com::Parser<com::_Chain::T> parser in this.{com::_Chain::parsers}) {
        com::ParseResult<com::_Chain::T> result = parser.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
        if(!result.{com::ParseResult::successful}) {
          if(parser is com::_Alt<dynamic>)
            errors.{core::List::addAll}(result.{com::ParseResult::errors});
          if(this.{com::_Chain::failFast}) {
            return new com::ParseResult::•<core::List<com::_Chain::T>>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, result.{com::ParseResult::errors});
          }
          successful = false;
        }
        results.{core::List::add}(result.{com::ParseResult::value});
        if(!result.{com::ParseResult::span}.{core::Object::==}(null))
          spans.{core::List::add}(result.{com::ParseResult::span});
      }
      file3::FileSpan span;
      if(spans.{core::Iterable::isNotEmpty}) {
        span = spans.{core::Iterable::reduce}((file3::FileSpan a, file3::FileSpan b) → file3::FileSpan => a.{file3::FileSpan::expand}(b));
      }
      return new com::ParseResult::•<core::List<com::_Chain::T>>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, successful, errors, span: span, value: core::List::unmodifiable<com::_Chain::T>(results));
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t401 = buffer in let final dynamic #t402 = #t401.{cod::CodeBuffer::writeln}("chain(${this.{com::_Chain::parsers}.{core::Iterable::length}}) (") in let final dynamic #t403 = #t401.{cod::CodeBuffer::indent}() in #t401;
      core::int i = 1;
      for (com::Parser<com::_Chain::T> parser in this.{com::_Chain::parsers}) {
        let final cod::CodeBuffer #t404 = buffer in let final dynamic #t405 = #t404.{cod::CodeBuffer::writeln}("#${let final core::int #t406 = i in let final core::int #t407 = i = #t406.{core::num::+}(1) in #t406}:") in let final dynamic #t408 = #t404.{cod::CodeBuffer::indent}() in #t404;
        parser.{com::Parser::stringify}(buffer);
        buffer.{cod::CodeBuffer::outdent}();
      }
      let final cod::CodeBuffer #t409 = buffer in let final dynamic #t410 = #t409.{cod::CodeBuffer::outdent}() in let final dynamic #t411 = #t409.{cod::CodeBuffer::writeln}(")") in #t409;
    }
  }
  class _Check<T extends core::Object = dynamic> extends com::Parser<com::_Check::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/check.dart
    final field com::Parser<com::_Check::T> parser;
    final field int3::Matcher matcher;
    final field core::String errorMessage;
    final field err::SyntaxErrorSeverity severity;
    constructor •(com::Parser<com::_Check::T> parser, int3::Matcher matcher, core::String errorMessage, err::SyntaxErrorSeverity severity) → void
      : com::_Check::parser = parser, com::_Check::matcher = matcher, com::_Check::errorMessage = errorMessage, com::_Check::severity = severity, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Check::T> {
      core::Map<dynamic, dynamic> matchState = <dynamic, dynamic>{};
      com::ParseResult<com::_Check::T> result = this.{com::_Check::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}()).{com::ParseResult::change}(parser: this);
      if(!result.{com::ParseResult::successful})
        return result;
      else
        if(!this.{com::_Check::matcher}.{int3::Matcher::matches}(result.{com::ParseResult::value}, matchState)) {
          return result.{com::ParseResult::change}(successful: false).{com::ParseResult::addErrors}(<err::SyntaxError>[new err::SyntaxError::•(this.{com::_Check::severity}, let final core::String #t412 = this.{com::_Check::errorMessage} in #t412.==(null) ?{core::String} this.{com::_Check::matcher}.{int3::Matcher::describe}(new des::StringDescription::•("Expected ")).{core::Object::toString}().{core::String::+}(".") : #t412, result.{com::ParseResult::span})]);
        }
        else
          return result;
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      int3::Description d = this.{com::_Check::matcher}.{int3::Matcher::describe}(new des::StringDescription::•());
      let final cod::CodeBuffer #t413 = buffer in let final dynamic #t414 = #t413.{cod::CodeBuffer::writeln}("check(${d}) (") in let final dynamic #t415 = #t413.{cod::CodeBuffer::indent}() in #t413;
      this.{com::_Check::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t416 = buffer in let final dynamic #t417 = #t416.{cod::CodeBuffer::outdent}() in let final dynamic #t418 = #t416.{cod::CodeBuffer::writeln}(")") in #t416;
    }
  }
  class _Compare<T extends core::Object = dynamic> extends com::ListParser<com::_Compare::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/compare.dart
    final field com::ListParser<com::_Compare::T> parser;
    final field (com::_Compare::T, com::_Compare::T) → core::int compare;
    constructor •(com::ListParser<com::_Compare::T> parser, (com::_Compare::T, com::_Compare::T) → core::int compare) → void
      : com::_Compare::parser = parser, com::_Compare::compare = compare, super com::ListParser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<core::List<com::_Compare::T>> {
      com::ParseResult<core::List<com::_Compare::T>> result = this.{com::_Compare::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      if(!result.{com::ParseResult::successful})
        return result;
      result = result.{com::ParseResult::change}(value: (let final core::List<com::_Compare::T> #t419 = result.{com::ParseResult::value} in #t419.==(null) ?{core::bool} null : #t419.{core::Iterable::isNotEmpty}).{core::Object::==}(true) ?{core::List<com::_Compare::T>} result.{com::ParseResult::value} : <com::_Compare::T>[]);
      result = result.{com::ParseResult::change}(value: core::List::from<com::_Compare::T>(result.{com::ParseResult::value}));
      return new com::ParseResult::•<core::List<com::_Compare::T>>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, true, <err::SyntaxError>[], span: result.{com::ParseResult::span}, value: let final core::List<com::_Compare::T> #t420 = result.{com::ParseResult::value} in let final dynamic #t421 = #t420.{core::List::sort}(this.{com::_Compare::compare}) in #t420);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t422 = buffer in let final dynamic #t423 = #t422.{cod::CodeBuffer::writeln}("sort(${this.{com::_Compare::compare}}) (") in let final dynamic #t424 = #t422.{cod::CodeBuffer::indent}() in #t422;
      this.{com::_Compare::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t425 = buffer in let final dynamic #t426 = #t425.{cod::CodeBuffer::outdent}() in let final dynamic #t427 = #t425.{cod::CodeBuffer::writeln}(")") in #t425;
    }
  }
  class _FoldErrors<T extends core::Object = dynamic> extends com::Parser<com::_FoldErrors::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/fold_errors.dart
    final field com::Parser<com::_FoldErrors::T> parser;
    final field (err::SyntaxError, err::SyntaxError) → core::bool equal;
    constructor •(com::Parser<com::_FoldErrors::T> parser, (err::SyntaxError, err::SyntaxError) → core::bool equal) → void
      : com::_FoldErrors::parser = parser, com::_FoldErrors::equal = equal, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_FoldErrors::T> {
      com::ParseResult<com::_FoldErrors::T> result = this.{com::_FoldErrors::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}()).{com::ParseResult::change}(parser: this);
      core::List<err::SyntaxError> errors = result.{com::ParseResult::errors}.{core::Iterable::fold}<core::List<err::SyntaxError>>(<err::SyntaxError>[], (core::List<err::SyntaxError> out, err::SyntaxError e) → core::List<err::SyntaxError> {
        if(!out.{core::Iterable::any}((err::SyntaxError b) → core::bool => this.{com::_FoldErrors::equal}(e, b)))
          out.{core::List::add}(e);
        return out;
      });
      return result.{com::ParseResult::change}(errors: errors);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t428 = buffer in let final dynamic #t429 = #t428.{cod::CodeBuffer::writeln}("fold errors (") in let final dynamic #t430 = #t428.{cod::CodeBuffer::indent}() in #t428;
      this.{com::_FoldErrors::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t431 = buffer in let final dynamic #t432 = #t431.{cod::CodeBuffer::outdent}() in let final dynamic #t433 = #t431.{cod::CodeBuffer::writeln}(")") in #t431;
    }
  }
  class _Index<T extends core::Object = dynamic> extends com::Parser<com::_Index::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/index.dart
    final field com::ListParser<com::_Index::T> parser;
    final field core::int index;
    constructor •(com::ListParser<com::_Index::T> parser, core::int index) → void
      : com::_Index::parser = parser, com::_Index::index = index, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Index::T> {
      com::ParseResult<core::List<com::_Index::T>> result = this.{com::_Index::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      core::Object value;
      if(result.{com::ParseResult::successful})
        value = this.{com::_Index::index}.{core::num::==}(1.{core::int::unary-}()) ?{com::_Index::T} result.{com::ParseResult::value}.{core::Iterable::last} : result.{com::ParseResult::value}.{core::Iterable::elementAt}(this.{com::_Index::index});
      return new com::ParseResult::•<com::_Index::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, result.{com::ParseResult::successful}, result.{com::ParseResult::errors}, span: result.{com::ParseResult::span}, value: value as com::_Index::T);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t434 = buffer in let final dynamic #t435 = #t434.{cod::CodeBuffer::writeln}("index(${this.{com::_Index::index}}) (") in let final dynamic #t436 = #t434.{cod::CodeBuffer::indent}() in #t434;
      this.{com::_Index::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t437 = buffer in let final dynamic #t438 = #t437.{cod::CodeBuffer::outdent}() in let final dynamic #t439 = #t437.{cod::CodeBuffer::writeln}(")") in #t437;
    }
  }
  class _Longest<T extends core::Object = dynamic> extends com::Parser<com::_Longest::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/longest.dart
    final field core::Iterable<com::Parser<com::_Longest::T>> parsers;
    final field core::Object errorMessage;
    final field err::SyntaxErrorSeverity severity;
    constructor •(core::Iterable<com::Parser<com::_Longest::T>> parsers, core::Object errorMessage, err::SyntaxErrorSeverity severity) → void
      : com::_Longest::parsers = parsers, com::_Longest::errorMessage = errorMessage, com::_Longest::severity = severity, super com::Parser::•()
      ;
    @core::override
    method _parse(com::ParseArgs args) → com::ParseResult<com::_Longest::T> {
      core::Iterable<com::Parser<com::_Longest::T>> inactive = this.{com::_Longest::parsers}.{core::Iterable::toList}().{core::Iterable::where}((com::Parser<com::_Longest::T> p) → core::bool => !args.{com::ParseArgs::trampoline}.{com::Trampoline::isActive}(p, args.{com::ParseArgs::scanner}.{str::StringScanner::position}));
      if(inactive.{core::Iterable::isEmpty}) {
        return new com::ParseResult::•<com::_Longest::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, <err::SyntaxError>[]);
      }
      core::int replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      core::List<err::SyntaxError> errors = <err::SyntaxError>[];
      core::List<com::ParseResult<com::_Longest::T>> results = <com::ParseResult<com::_Longest::T>>[];
      for (com::Parser<com::_Longest::T> parser in inactive) {
        com::ParseResult<com::_Longest::T> result = parser.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
        if(result.{com::ParseResult::successful} && !result.{com::ParseResult::span}.{core::Object::==}(null))
          results.{core::List::add}(result);
        else
          if(parser is com::_Alt<dynamic>)
            errors.{core::List::addAll}(result.{com::ParseResult::errors});
        args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
      }
      if(results.{core::Iterable::isNotEmpty}) {
        results.{core::List::sort}((com::ParseResult<com::_Longest::T> a, com::ParseResult<com::_Longest::T> b) → core::int => b.{com::ParseResult::span}.{spa2::SourceSpanMixin::length}.{core::num::compareTo}(a.{com::ParseResult::span}.{spa2::SourceSpanMixin::length}));
        args.{com::ParseArgs::scanner}.{str::StringScanner::scan}(results.{core::Iterable::first}.{com::ParseResult::span}.{span::SourceSpanBase::text});
        return results.{core::Iterable::first};
      }
      if(!this.{com::_Longest::errorMessage}.{core::Object::==}(false))
        errors.{core::List::add}(new err::SyntaxError::•(this.{com::_Longest::severity}, let final core::String #t440 = let final core::Object #t441 = this.{com::_Longest::errorMessage} in #t441.==(null) ?{core::String} null : #t441.{core::Object::toString}() in #t440.==(null) ?{core::String} "No match found for ${this.{com::_Longest::parsers}.{core::Iterable::length}} alternative(s)" : #t440, args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan}));
      return new com::ParseResult::•<com::_Longest::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, errors);
    }
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Longest::T> {
      core::int replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      core::List<err::SyntaxError> errors = <err::SyntaxError>[];
      core::List<com::ParseResult<com::_Longest::T>> results = <com::ParseResult<com::_Longest::T>>[];
      for (com::Parser<com::_Longest::T> parser in this.{com::_Longest::parsers}) {
        com::ParseResult<com::_Longest::T> result = parser.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
        if(result.{com::ParseResult::successful})
          results.{core::List::add}(result);
        else
          if(parser is com::_Alt<dynamic>)
            errors.{core::List::addAll}(result.{com::ParseResult::errors});
        args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
      }
      if(results.{core::Iterable::isNotEmpty}) {
        results.{core::List::sort}((com::ParseResult<com::_Longest::T> a, com::ParseResult<com::_Longest::T> b) → core::int => b.{com::ParseResult::span}.{spa2::SourceSpanMixin::length}.{core::num::compareTo}(a.{com::ParseResult::span}.{spa2::SourceSpanMixin::length}));
        args.{com::ParseArgs::scanner}.{str::StringScanner::scan}(results.{core::Iterable::first}.{com::ParseResult::span}.{span::SourceSpanBase::text});
        return results.{core::Iterable::first};
      }
      errors.{core::List::add}(new err::SyntaxError::•(this.{com::_Longest::severity}, let final core::String #t442 = let final core::Object #t443 = this.{com::_Longest::errorMessage} in #t443.==(null) ?{core::String} null : #t443.{core::Object::toString}() in #t442.==(null) ?{core::String} "No match found for ${this.{com::_Longest::parsers}.{core::Iterable::length}} alternative(s)" : #t442, args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan}));
      return new com::ParseResult::•<com::_Longest::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, errors);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t444 = buffer in let final dynamic #t445 = #t444.{cod::CodeBuffer::writeln}("longest(${this.{com::_Longest::parsers}.{core::Iterable::length}}) (") in let final dynamic #t446 = #t444.{cod::CodeBuffer::indent}() in #t444;
      core::int i = 1;
      for (com::Parser<com::_Longest::T> parser in this.{com::_Longest::parsers}) {
        let final cod::CodeBuffer #t447 = buffer in let final dynamic #t448 = #t447.{cod::CodeBuffer::writeln}("#${let final core::int #t449 = i in let final core::int #t450 = i = #t449.{core::num::+}(1) in #t449}:") in let final dynamic #t451 = #t447.{cod::CodeBuffer::indent}() in #t447;
        parser.{com::Parser::stringify}(buffer);
        buffer.{cod::CodeBuffer::outdent}();
      }
      let final cod::CodeBuffer #t452 = buffer in let final dynamic #t453 = #t452.{cod::CodeBuffer::outdent}() in let final dynamic #t454 = #t452.{cod::CodeBuffer::writeln}(")") in #t452;
    }
  }
  class _Map<T extends core::Object = dynamic, U extends core::Object = dynamic> extends com::Parser<com::_Map::U> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/map.dart
    final field com::Parser<com::_Map::T> parser;
    final field (com::ParseResult<com::_Map::T>) → com::_Map::U f;
    constructor •(com::Parser<com::_Map::T> parser, (com::ParseResult<com::_Map::T>) → com::_Map::U f) → void
      : com::_Map::parser = parser, com::_Map::f = f, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Map::U> {
      com::ParseResult<com::_Map::T> result = this.{com::_Map::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      return new com::ParseResult::•<com::_Map::U>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, result.{com::ParseResult::successful}, result.{com::ParseResult::errors}, span: result.{com::ParseResult::span}, value: result.{com::ParseResult::successful} ?{com::_Map::U} this.{com::_Map::f}(result) : null);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t455 = buffer in let final dynamic #t456 = #t455.{cod::CodeBuffer::writeln}("map<${com::_Map::U}> (") in let final dynamic #t457 = #t455.{cod::CodeBuffer::indent}() in #t455;
      this.{com::_Map::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t458 = buffer in let final dynamic #t459 = #t458.{cod::CodeBuffer::outdent}() in let final dynamic #t460 = #t458.{cod::CodeBuffer::writeln}(")") in #t458;
    }
  }
  class _Change<T extends core::Object = dynamic, U extends core::Object = dynamic> extends com::Parser<com::_Change::U> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/map.dart
    final field com::Parser<com::_Change::T> parser;
    final field (com::ParseResult<com::_Change::T>) → com::ParseResult<com::_Change::U> f;
    constructor •(com::Parser<com::_Change::T> parser, (com::ParseResult<com::_Change::T>) → com::ParseResult<com::_Change::U> f) → void
      : com::_Change::parser = parser, com::_Change::f = f, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Change::U> {
      return this.{com::_Change::f}(this.{com::_Change::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}())).{com::ParseResult::change}(parser: this);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t461 = buffer in let final dynamic #t462 = #t461.{cod::CodeBuffer::writeln}("change(${this.{com::_Change::f}}) (") in let final dynamic #t463 = #t461.{cod::CodeBuffer::indent}() in #t461;
      this.{com::_Change::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t464 = buffer in let final dynamic #t465 = #t464.{cod::CodeBuffer::outdent}() in let final dynamic #t466 = #t464.{cod::CodeBuffer::writeln}(")") in #t464;
    }
  }
  class _Match<T extends core::Object = dynamic> extends com::Parser<com::_Match::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/match.dart
    final field core::Pattern pattern;
    final field core::String errorMessage;
    final field err::SyntaxErrorSeverity severity;
    constructor •(core::Pattern pattern, core::String errorMessage, err::SyntaxErrorSeverity severity) → void
      : com::_Match::pattern = pattern, com::_Match::errorMessage = errorMessage, com::_Match::severity = severity, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Match::T> {
      spa::SpanScanner scanner = args.{com::ParseArgs::scanner};
      if(!scanner.{str::StringScanner::scan}(this.{com::_Match::pattern}))
        return new com::ParseResult::•<com::_Match::T>(args.{com::ParseArgs::trampoline}, scanner, this, false, <err::SyntaxError>[new err::SyntaxError::•(this.{com::_Match::severity}, let final core::String #t467 = this.{com::_Match::errorMessage} in #t467.==(null) ?{core::String} "Expected \"${this.{com::_Match::pattern}}\"." : #t467, scanner.{spa::SpanScanner::emptySpan})]);
      return new com::ParseResult::•<com::_Match::T>(args.{com::ParseArgs::trampoline}, scanner, this, true, <err::SyntaxError>[], span: scanner.{spa::SpanScanner::lastSpan});
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      buffer.{cod::CodeBuffer::writeln}("match(${this.{com::_Match::pattern}})");
    }
  }
  class _MaxDepth<T extends core::Object = dynamic> extends com::Parser<com::_MaxDepth::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/max_depth.dart
    final field com::Parser<com::_MaxDepth::T> parser;
    final field core::int cap;
    constructor •(com::Parser<com::_MaxDepth::T> parser, core::int cap) → void
      : com::_MaxDepth::parser = parser, com::_MaxDepth::cap = cap, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_MaxDepth::T> {
      if(args.{com::ParseArgs::depth}.{core::num::>}(this.{com::_MaxDepth::cap})) {
        return new com::ParseResult::•<com::_MaxDepth::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, <err::SyntaxError>[]);
      }
      return this.{com::_MaxDepth::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t468 = buffer in let final dynamic #t469 = #t468.{cod::CodeBuffer::writeln}("max depth(${this.{com::_MaxDepth::cap}}) (") in let final dynamic #t470 = #t468.{cod::CodeBuffer::indent}() in #t468;
      this.{com::_MaxDepth::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t471 = buffer in let final dynamic #t472 = #t471.{cod::CodeBuffer::outdent}() in let final dynamic #t473 = #t471.{cod::CodeBuffer::writeln}(")") in #t471;
    }
  }
  class _Negate<T extends core::Object = dynamic> extends com::Parser<com::_Negate::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/negate.dart
    final field com::Parser<com::_Negate::T> parser;
    final field core::String errorMessage;
    final field err::SyntaxErrorSeverity severity;
    constructor •(com::Parser<com::_Negate::T> parser, core::String errorMessage, err::SyntaxErrorSeverity severity) → void
      : com::_Negate::parser = parser, com::_Negate::errorMessage = errorMessage, com::_Negate::severity = severity, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Negate::T> {
      com::ParseResult<com::_Negate::T> result = this.{com::_Negate::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}()).{com::ParseResult::change}(parser: this);
      if(!result.{com::ParseResult::successful}) {
        return new com::ParseResult::•<com::_Negate::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, true, <err::SyntaxError>[], span: let final file3::FileSpan #t474 = let final file3::FileSpan #t475 = result.{com::ParseResult::span} in #t475.==(null) ?{file3::FileSpan} args.{com::ParseArgs::scanner}.{spa::SpanScanner::lastSpan} : #t475 in #t474.==(null) ?{file3::FileSpan} args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan} : #t474, value: result.{com::ParseResult::value});
      }
      result = result.{com::ParseResult::change}(successful: false);
      if(!this.{com::_Negate::errorMessage}.{core::String::==}(null)) {
        result = result.{com::ParseResult::addErrors}(<err::SyntaxError>[new err::SyntaxError::•(this.{com::_Negate::severity}, this.{com::_Negate::errorMessage}, result.{com::ParseResult::span})]);
      }
      return result;
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t476 = buffer in let final dynamic #t477 = #t476.{cod::CodeBuffer::writeln}("negate (") in let final dynamic #t478 = #t476.{cod::CodeBuffer::indent}() in #t476;
      this.{com::_Negate::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t479 = buffer in let final dynamic #t480 = #t479.{cod::CodeBuffer::outdent}() in let final dynamic #t481 = #t479.{cod::CodeBuffer::writeln}(")") in #t479;
    }
  }
  class _Opt<T extends core::Object = dynamic> extends com::Parser<com::_Opt::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/opt.dart
    final field com::Parser<com::_Opt::T> parser;
    final field core::bool backtrack;
    constructor •(com::Parser<com::_Opt::T> parser, core::bool backtrack) → void
      : com::_Opt::parser = parser, com::_Opt::backtrack = backtrack, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Opt::T> {
      core::int replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      com::ParseResult<com::_Opt::T> result = this.{com::_Opt::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      if(!result.{com::ParseResult::successful})
        args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
      return result.{com::ParseResult::change}(parser: this, successful: true);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t482 = buffer in let final dynamic #t483 = #t482.{cod::CodeBuffer::writeln}("optional (") in let final dynamic #t484 = #t482.{cod::CodeBuffer::indent}() in #t482;
      this.{com::_Opt::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t485 = buffer in let final dynamic #t486 = #t485.{cod::CodeBuffer::outdent}() in let final dynamic #t487 = #t485.{cod::CodeBuffer::writeln}(")") in #t485;
    }
  }
  class _ListOpt<T extends core::Object = dynamic> extends com::ListParser<com::_ListOpt::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/opt.dart
    final field com::ListParser<com::_ListOpt::T> parser;
    final field core::bool backtrack;
    constructor •(com::ListParser<com::_ListOpt::T> parser, core::bool backtrack) → void
      : com::_ListOpt::parser = parser, com::_ListOpt::backtrack = backtrack, super com::ListParser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<core::List<com::_ListOpt::T>> {
      core::int replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      com::ParseResult<core::List<com::_ListOpt::T>> result = this.{com::_ListOpt::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      if(!result.{com::ParseResult::successful})
        args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
      return result.{com::ParseResult::change}(parser: this, successful: true);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t488 = buffer in let final dynamic #t489 = #t488.{cod::CodeBuffer::writeln}("optional (") in let final dynamic #t490 = #t488.{cod::CodeBuffer::indent}() in #t488;
      this.{com::_ListOpt::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t491 = buffer in let final dynamic #t492 = #t491.{cod::CodeBuffer::outdent}() in let final dynamic #t493 = #t491.{cod::CodeBuffer::writeln}(")") in #t491;
    }
  }
  class _Reduce<T extends core::Object = dynamic> extends com::Parser<com::_Reduce::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/reduce.dart
    final field com::ListParser<com::_Reduce::T> parser;
    final field (com::_Reduce::T, com::_Reduce::T) → com::_Reduce::T combine;
    constructor •(com::ListParser<com::_Reduce::T> parser, (com::_Reduce::T, com::_Reduce::T) → com::_Reduce::T combine) → void
      : com::_Reduce::parser = parser, com::_Reduce::combine = combine, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Reduce::T> {
      com::ParseResult<core::List<com::_Reduce::T>> result = this.{com::_Reduce::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      if(!result.{com::ParseResult::successful})
        return new com::ParseResult::•<com::_Reduce::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, result.{com::ParseResult::errors});
      result = result.{com::ParseResult::change}(value: (let final core::List<com::_Reduce::T> #t494 = result.{com::ParseResult::value} in #t494.==(null) ?{core::bool} null : #t494.{core::Iterable::isNotEmpty}).{core::Object::==}(true) ?{core::List<com::_Reduce::T>} result.{com::ParseResult::value} : <com::_Reduce::T>[]);
      return new com::ParseResult::•<com::_Reduce::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, result.{com::ParseResult::successful}, <err::SyntaxError>[], span: result.{com::ParseResult::span}, value: result.{com::ParseResult::value}.{core::Iterable::isEmpty} ?{com::_Reduce::T} null : result.{com::ParseResult::value}.{core::Iterable::reduce}(this.{com::_Reduce::combine}));
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t495 = buffer in let final dynamic #t496 = #t495.{cod::CodeBuffer::writeln}("reduce(${this.{com::_Reduce::combine}}) (") in let final dynamic #t497 = #t495.{cod::CodeBuffer::indent}() in #t495;
      this.{com::_Reduce::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t498 = buffer in let final dynamic #t499 = #t498.{cod::CodeBuffer::outdent}() in let final dynamic #t500 = #t498.{cod::CodeBuffer::writeln}(")") in #t498;
    }
  }
  class Reference<T extends core::Object = dynamic> extends com::Parser<com::Reference::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/reference.dart
    generic-covariant-impl field com::Parser<com::Reference::T> _parser = null;
    field core::bool printed = false;
    constructor _() → void
      : super com::Parser::•()
      ;
    set parser(generic-covariant-impl com::Parser<com::Reference::T> value) → void {
      if(!this.{com::Reference::_parser}.{core::Object::==}(null))
        throw new core::StateError::•("There is already a parser assigned to this reference.");
      this.{com::Reference::_parser} = value;
    }
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::Reference::T> {
      if(this.{com::Reference::_parser}.{core::Object::==}(null))
        throw new core::StateError::•("There is no parser assigned to this reference.");
      return this.{com::Reference::_parser}.{com::Parser::_parse}(args);
    }
    @core::override
    method _parse(com::ParseArgs args) → com::ParseResult<com::Reference::T> {
      return this.{com::Reference::_parser}.{com::Parser::_parse}(args);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      if(this.{com::Reference::_parser}.{core::Object::==}(null))
        buffer.{cod::CodeBuffer::writeln}("(undefined reference <${com::Reference::T}>)");
      else
        if(!this.{com::Reference::printed})
          this.{com::Reference::_parser}.{com::Parser::stringify}(buffer);
      this.{com::Reference::printed} = true;
      buffer.{cod::CodeBuffer::writeln}("(previously printed reference)");
    }
  }
  class _Repeat<T extends core::Object = dynamic> extends com::ListParser<com::_Repeat::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/repeat.dart
    final field com::Parser<com::_Repeat::T> parser;
    final field core::int count;
    final field core::bool exact;
    final field core::bool backtrack;
    final field core::String tooFew;
    final field core::String tooMany;
    final field err::SyntaxErrorSeverity severity;
    constructor •(com::Parser<com::_Repeat::T> parser, core::int count, core::bool exact, core::String tooFew, core::String tooMany, core::bool backtrack, err::SyntaxErrorSeverity severity) → void
      : com::_Repeat::parser = parser, com::_Repeat::count = count, com::_Repeat::exact = exact, com::_Repeat::tooFew = tooFew, com::_Repeat::tooMany = tooMany, com::_Repeat::backtrack = backtrack, com::_Repeat::severity = severity, super com::ListParser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<core::List<com::_Repeat::T>> {
      core::List<err::SyntaxError> errors = <err::SyntaxError>[];
      core::List<com::_Repeat::T> results = <com::_Repeat::T>[];
      core::List<file3::FileSpan> spans = <file3::FileSpan>[];
      core::int success = 0;
      core::int replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      com::ParseResult<com::_Repeat::T> result;
      do {
        result = this.{com::_Repeat::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
        if(result.{com::ParseResult::successful}) {
          success = success.{core::num::+}(1);
          results.{core::List::add}(result.{com::ParseResult::value});
          replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
        }
        else
          if(this.{com::_Repeat::backtrack})
            args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
        if(!result.{com::ParseResult::span}.{core::Object::==}(null))
          spans.{core::List::add}(result.{com::ParseResult::span});
      }
      while (result.{com::ParseResult::successful})
      if(success.{core::num::<}(this.{com::_Repeat::count})) {
        errors.{core::List::addAll}(result.{com::ParseResult::errors});
        errors.{core::List::add}(new err::SyntaxError::•(this.{com::_Repeat::severity}, let final core::String #t501 = this.{com::_Repeat::tooFew} in #t501.==(null) ?{core::String} "Expected at least ${this.{com::_Repeat::count}} occurence(s)." : #t501, let final file3::FileSpan #t502 = result.{com::ParseResult::span} in #t502.==(null) ?{file3::FileSpan} args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan} : #t502));
        if(this.{com::_Repeat::backtrack})
          args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
        return new com::ParseResult::•<core::List<com::_Repeat::T>>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, errors);
      }
      else
        if(success.{core::num::>}(this.{com::_Repeat::count}) && this.{com::_Repeat::exact}) {
          if(this.{com::_Repeat::backtrack})
            args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
          return new com::ParseResult::•<core::List<com::_Repeat::T>>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, <err::SyntaxError>[new err::SyntaxError::•(this.{com::_Repeat::severity}, let final core::String #t503 = this.{com::_Repeat::tooMany} in #t503.==(null) ?{core::String} "Expected no more than ${this.{com::_Repeat::count}} occurence(s)." : #t503, let final file3::FileSpan #t504 = result.{com::ParseResult::span} in #t504.==(null) ?{file3::FileSpan} args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan} : #t504)]);
        }
      file3::FileSpan span = spans.{core::Iterable::reduce}((file3::FileSpan a, file3::FileSpan b) → file3::FileSpan => a.{file3::FileSpan::expand}(b));
      return new com::ParseResult::•<core::List<com::_Repeat::T>>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, true, <err::SyntaxError>[], span: span, value: results);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      core::StringBuffer r = new core::StringBuffer::•("{${this.{com::_Repeat::count}}");
      if(!this.{com::_Repeat::exact})
        r.{core::StringBuffer::write}(",");
      r.{core::StringBuffer::write}("}");
      let final cod::CodeBuffer #t505 = buffer in let final dynamic #t506 = #t505.{cod::CodeBuffer::writeln}("repeat(${r}) (") in let final dynamic #t507 = #t505.{cod::CodeBuffer::indent}() in #t505;
      this.{com::_Repeat::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t508 = buffer in let final dynamic #t509 = #t508.{cod::CodeBuffer::outdent}() in let final dynamic #t510 = #t508.{cod::CodeBuffer::writeln}(")") in #t508;
    }
  }
  class _Safe<T extends core::Object = dynamic> extends com::Parser<com::_Safe::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/safe.dart
    final field com::Parser<com::_Safe::T> parser;
    final field core::bool backtrack;
    final field core::String errorMessage;
    final field err::SyntaxErrorSeverity severity;
    field core::bool _triggered = false;
    constructor •(com::Parser<com::_Safe::T> parser, core::bool backtrack, core::String errorMessage, err::SyntaxErrorSeverity severity) → void
      : com::_Safe::parser = parser, com::_Safe::backtrack = backtrack, com::_Safe::errorMessage = errorMessage, com::_Safe::severity = severity, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Safe::T> {
      core::int replay = args.{com::ParseArgs::scanner}.{str::StringScanner::position};
      try {
        if(this.{com::_Safe::_triggered})
          throw null;
        return this.{com::_Safe::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      }
      on dynamic catch(final dynamic _) {
        this.{com::_Safe::_triggered} = true;
        if(this.{com::_Safe::backtrack})
          args.{com::ParseArgs::scanner}.{str::StringScanner::position} = replay;
        core::List<err::SyntaxError> errors = <err::SyntaxError>[];
        if(!this.{com::_Safe::errorMessage}.{core::String::==}(null)) {
          errors.{core::List::add}(new err::SyntaxError::•(this.{com::_Safe::severity}, this.{com::_Safe::errorMessage}, let final file3::FileSpan #t511 = args.{com::ParseArgs::scanner}.{spa::SpanScanner::lastSpan} in #t511.==(null) ?{file3::FileSpan} args.{com::ParseArgs::scanner}.{spa::SpanScanner::emptySpan} : #t511));
        }
        return new com::ParseResult::•<com::_Safe::T>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, false, errors);
      }
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      core::String t = this.{com::_Safe::_triggered} ?{core::String} "triggered" : "not triggered";
      let final cod::CodeBuffer #t512 = buffer in let final dynamic #t513 = #t512.{cod::CodeBuffer::writeln}("safe(${t}) (") in let final dynamic #t514 = #t512.{cod::CodeBuffer::indent}() in #t512;
      this.{com::_Safe::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t515 = buffer in let final dynamic #t516 = #t515.{cod::CodeBuffer::outdent}() in let final dynamic #t517 = #t515.{cod::CodeBuffer::writeln}(")") in #t515;
    }
  }
  class _ToList<T extends core::Object = dynamic> extends com::ListParser<com::_ToList::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/to_list.dart
    final field com::Parser<com::_ToList::T> parser;
    constructor •(com::Parser<com::_ToList::T> parser) → void
      : com::_ToList::parser = parser, super com::ListParser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<core::List<com::_ToList::T>> {
      com::ParseResult<com::_ToList::T> result = this.{com::_ToList::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}());
      if(result.{com::ParseResult::value} is core::List<dynamic>) {
        return (result as com::ParseResult<core::List<com::_ToList::T>>).{com::ParseResult::change}(parser: this);
      }
      return new com::ParseResult::•<core::List<com::_ToList::T>>(args.{com::ParseArgs::trampoline}, args.{com::ParseArgs::scanner}, this, result.{com::ParseResult::successful}, result.{com::ParseResult::errors}, span: result.{com::ParseResult::span}, value: <com::_ToList::T>[result.{com::ParseResult::value}]);
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t518 = buffer in let final dynamic #t519 = #t518.{cod::CodeBuffer::writeln}("to list (") in let final dynamic #t520 = #t518.{cod::CodeBuffer::indent}() in #t518;
      this.{com::_ToList::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t521 = buffer in let final dynamic #t522 = #t521.{cod::CodeBuffer::outdent}() in let final dynamic #t523 = #t521.{cod::CodeBuffer::writeln}(")") in #t521;
    }
  }
  class _Value<T extends core::Object = dynamic> extends com::Parser<com::_Value::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/value.dart
    final field com::Parser<com::_Value::T> parser;
    final field (com::ParseResult<com::_Value::T>) → com::_Value::T f;
    constructor •(com::Parser<com::_Value::T> parser, (com::ParseResult<com::_Value::T>) → com::_Value::T f) → void
      : com::_Value::parser = parser, com::_Value::f = f, super com::Parser::•()
      ;
    @core::override
    method __parse(com::ParseArgs args) → com::ParseResult<com::_Value::T> {
      com::ParseResult<com::_Value::T> result = this.{com::_Value::parser}.{com::Parser::_parse}(args.{com::ParseArgs::increaseDepth}()).{com::ParseResult::change}(parser: this);
      return result.{com::ParseResult::successful} ?{com::ParseResult<com::_Value::T>} result.{com::ParseResult::change}(value: this.{com::_Value::f}(result)) : result;
    }
    @core::override
    method stringify(cod::CodeBuffer buffer) → void {
      let final cod::CodeBuffer #t524 = buffer in let final dynamic #t525 = #t524.{cod::CodeBuffer::writeln}("set value(${this.{com::_Value::f}}) (") in let final dynamic #t526 = #t524.{cod::CodeBuffer::indent}() in #t524;
      this.{com::_Value::parser}.{com::Parser::stringify}(buffer);
      let final cod::CodeBuffer #t527 = buffer in let final dynamic #t528 = #t527.{cod::CodeBuffer::outdent}() in let final dynamic #t529 = #t527.{cod::CodeBuffer::writeln}(")") in #t527;
    }
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/any.dart */ any<T extends core::Object = dynamic>(core::Iterable<com::Parser<com::any::T>> parsers, {core::bool backtrack = true, dynamic errorMessage = null, err::SyntaxErrorSeverity severity = null}) → com::Parser<com::any::T> {
    return new com::_Any::•<com::any::T>(parsers, !backtrack.{core::Object::==}(false), errorMessage, let final err::SyntaxErrorSeverity #t530 = severity in #t530.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t530);
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/chain.dart */ chain<T extends core::Object = dynamic>(core::Iterable<com::Parser<com::chain::T>> parsers, {core::bool failFast = true, err::SyntaxErrorSeverity severity = null}) → com::ListParser<com::chain::T> {
    return new com::_Chain::•<com::chain::T>(parsers, !failFast.{core::Object::==}(false), let final err::SyntaxErrorSeverity #t531 = severity in #t531.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t531);
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/longest.dart */ longest<T extends core::Object = dynamic>(core::Iterable<com::Parser<com::longest::T>> parsers, {core::Object errorMessage = null, err::SyntaxErrorSeverity severity = null}) → com::Parser<com::longest::T> {
    return new com::_Longest::•<com::longest::T>(parsers, errorMessage, let final err::SyntaxErrorSeverity #t532 = severity in #t532.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t532);
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/match.dart */ match<T extends core::Object = dynamic>(core::Pattern pattern, {core::String errorMessage = null, err::SyntaxErrorSeverity severity = null}) → com::Parser<com::match::T>
    return new com::_Match::•<com::match::T>(pattern, errorMessage, let final err::SyntaxErrorSeverity #t533 = severity in #t533.==(null) ?{err::SyntaxErrorSeverity} err::SyntaxErrorSeverity::error : #t533);
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/combinator-1.0.0+3/lib/src/combinator/reference.dart */ reference<T extends core::Object = dynamic>() → com::Reference<com::reference::T>
    return new com::Reference::_<com::reference::T>();
}
library from "package:combinator/src/error.dart" as err {
  import "package:source_span/source_span.dart";
  class SyntaxError extends core::Object implements core::Exception {
    final field err::SyntaxErrorSeverity severity;
    final field core::String message;
    final field file3::FileSpan span;
    field core::String _toolString = null;
    constructor •(err::SyntaxErrorSeverity severity, core::String message, file3::FileSpan span) → void
      : err::SyntaxError::severity = severity, err::SyntaxError::message = message, err::SyntaxError::span = span, super core::Object::•()
      ;
    get toolString() → core::String {
      if(!this.{err::SyntaxError::_toolString}.{core::String::==}(null))
        return this.{err::SyntaxError::_toolString};
      core::String type = this.{err::SyntaxError::severity}.{core::Object::==}(err::SyntaxErrorSeverity::warning) ?{core::String} "warning" : "error";
      return this.{err::SyntaxError::_toolString} = "${type}: ${this.{err::SyntaxError::span}.{file3::FileSpan::start}.{loc::SourceLocationMixin::toolString}}: ${this.{err::SyntaxError::message}}";
    }
  }
  class SyntaxErrorSeverity extends core::Object {
    final field core::int index;
    final field core::String _name;
    static const field core::List<err::SyntaxErrorSeverity> values = const <err::SyntaxErrorSeverity>[err::SyntaxErrorSeverity::warning, err::SyntaxErrorSeverity::error, err::SyntaxErrorSeverity::info, err::SyntaxErrorSeverity::hint];
    static const field err::SyntaxErrorSeverity warning = const err::SyntaxErrorSeverity::•(0, "SyntaxErrorSeverity.warning");
    static const field err::SyntaxErrorSeverity error = const err::SyntaxErrorSeverity::•(1, "SyntaxErrorSeverity.error");
    static const field err::SyntaxErrorSeverity info = const err::SyntaxErrorSeverity::•(2, "SyntaxErrorSeverity.info");
    static const field err::SyntaxErrorSeverity hint = const err::SyntaxErrorSeverity::•(3, "SyntaxErrorSeverity.hint");
    const constructor •(core::int index, core::String _name) → void
      : err::SyntaxErrorSeverity::index = index, err::SyntaxErrorSeverity::_name = _name, super core::Object::•()
      ;
    method toString() → core::String
      return this.{=err::SyntaxErrorSeverity::_name};
  }
}
library quiver.core from "package:quiver/core.dart" as core3 {
  import "dart:collection";
  class Optional<T extends core::Object = dynamic> extends col::IterableBase<core3::Optional::T> { // from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/quiver-2.0.0+1/lib/src/core/optional.dart
    final field core3::Optional::T _value;
    const constructor absent() → void
      : core3::Optional::_value = null, super col::IterableBase::•()
      ;
    constructor of(core3::Optional::T value) → void
      : core3::Optional::_value = value, super col::IterableBase::•() {
      if(this.{core3::Optional::_value}.{core::Object::==}(null))
        throw new core::ArgumentError::•("Must not be null.");
    }
    const constructor fromNullable(core3::Optional::T value) → void
      : core3::Optional::_value = value, super col::IterableBase::•()
      ;
    get isPresent() → core::bool
      return !this.{core3::Optional::_value}.{core::Object::==}(null);
    get value() → core3::Optional::T {
      if(this.{core3::Optional::_value}.{core::Object::==}(null)) {
        throw new core::StateError::•("value called on absent Optional.");
      }
      return this.{core3::Optional::_value};
    }
    method ifPresent((core3::Optional::T) → void ifPresent) → void {
      if(this.{core3::Optional::isPresent}) {
        ifPresent.call(this.{core3::Optional::_value});
      }
    }
    method ifAbsent(() → void ifAbsent) → void {
      if(!this.{core3::Optional::isPresent}) {
        ifAbsent.call();
      }
    }
    method or(generic-covariant-impl core3::Optional::T defaultValue) → core3::Optional::T {
      if(defaultValue.{core::Object::==}(null)) {
        throw new core::ArgumentError::•("defaultValue must not be null.");
      }
      return this.{core3::Optional::_value}.{core::Object::==}(null) ?{core3::Optional::T} defaultValue : this.{core3::Optional::_value};
    }
    get orNull() → core3::Optional::T
      return this.{core3::Optional::_value};
    method transform<S extends core::Object = dynamic>((core3::Optional::T) → core3::Optional::transform::S transformer) → core3::Optional<core3::Optional::transform::S> {
      return this.{core3::Optional::_value}.{core::Object::==}(null) ?{core3::Optional<core3::Optional::transform::S>} new core3::Optional::absent<core3::Optional::transform::S>() : new core3::Optional::of<core3::Optional::transform::S>(transformer.call(this.{core3::Optional::_value}));
    }
    @core::override
    get iterator() → core::Iterator<core3::Optional::T>
      return this.{core3::Optional::isPresent} ?{core::Iterator<core3::Optional::T>} <core3::Optional::T>[this.{core3::Optional::_value}].{core::Iterable::iterator} : new _in::EmptyIterable::•<core3::Optional::T>().{core::Iterable::iterator};
    get hashCode() → core::int
      return this.{core3::Optional::_value}.{core::Object::hashCode};
    operator ==(dynamic o) → core::bool
      return o is core3::Optional<core3::Optional::T> && o{core3::Optional<core3::Optional::T>}.{core3::Optional::_value}.{core::Object::==}(this.{core3::Optional::_value});
    method toString() → core::String {
      return this.{core3::Optional::_value}.{core::Object::==}(null) ?{core::String} "Optional { absent }" : "Optional { value: ${this.{core3::Optional::_value}} }";
    }
  }
  static method firstNonNull(dynamic o1, dynamic o2, [dynamic o3 = null, dynamic o4 = null]) → dynamic {
    if(!o1.{core::Object::==}(null))
      return o1;
    if(!o2.{core::Object::==}(null))
      return o2;
    if(!o3.{core::Object::==}(null))
      return o3;
    if(!o4.{core::Object::==}(null))
      return o4;
    throw new core::ArgumentError::•("All arguments were null");
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/quiver-2.0.0+1/lib/src/core/hash.dart */ hashObjects(core::Iterable<dynamic> objects) → core::int
    return core3::_finish(objects.{core::Iterable::fold}<core::int>(0, (core::int h, dynamic i) → core::int => core3::_combine(h, i.{core::Object::hashCode})));
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/quiver-2.0.0+1/lib/src/core/hash.dart */ hash2(dynamic a, dynamic b) → core::int
    return core3::_finish(core3::_combine(core3::_combine(0, a.{core::Object::hashCode}), b.{core::Object::hashCode}));
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/quiver-2.0.0+1/lib/src/core/hash.dart */ hash3(dynamic a, dynamic b, dynamic c) → core::int
    return core3::_finish(core3::_combine(core3::_combine(core3::_combine(0, a.{core::Object::hashCode}), b.{core::Object::hashCode}), c.{core::Object::hashCode}));
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/quiver-2.0.0+1/lib/src/core/hash.dart */ hash4(dynamic a, dynamic b, dynamic c, dynamic d) → core::int
    return core3::_finish(core3::_combine(core3::_combine(core3::_combine(core3::_combine(0, a.{core::Object::hashCode}), b.{core::Object::hashCode}), c.{core::Object::hashCode}), d.{core::Object::hashCode}));
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/quiver-2.0.0+1/lib/src/core/hash.dart */ _combine(core::int hash, core::int value) → core::int {
    hash = 536870911.{core::int::&}(hash.{core::num::+}(value));
    hash = 536870911.{core::int::&}(hash.{core::num::+}(524287.{core::int::&}(hash).{core::int::<<}(10)));
    return hash.{core::int::^}(hash.{core::int::>>}(6));
  }
  static method /* from file:///Users/thosakwe/.pub-cache/hosted/pub.dartlang.org/quiver-2.0.0+1/lib/src/core/hash.dart */ _finish(core::int hash) → core::int {
    hash = 536870911.{core::int::&}(hash.{core::num::+}(67108863.{core::int::&}(hash).{core::int::<<}(3)));
    hash = hash.{core::int::^}(hash.{core::int::>>}(11));
    return 536870911.{core::int::&}(hash.{core::num::+}(16383.{core::int::&}(hash).{core::int::<<}(15)));
  }
}
library from "package:string_scanner/string_scanner.dart" as str3 {
  export "package:string_scanner/src/exception.dart";
  export "package:string_scanner/src/line_scanner.dart";
  export "package:string_scanner/src/span_scanner.dart";
  export "package:string_scanner/src/string_scanner.dart";
}
library angel_route.string_util from "package:angel_route/string_util.dart" as str2 {
  static method stripStray(core::String haystack, core::String needle) → core::String {
    core::int firstSlash;
    if(haystack.{core::String::startsWith}(needle)) {
      firstSlash = haystack.{core::String::indexOf}(needle);
      if(firstSlash.{core::num::==}(1.{core::int::unary-}()))
        return haystack;
    }
    else {
      firstSlash = 1.{core::int::unary-}();
    }
    if(firstSlash.{core::num::==}(haystack.{core::String::length}.{core::num::-}(1)))
      return haystack.{core::String::length}.{core::num::==}(1) ?{core::String} "" : haystack.{core::String::substring}(0, firstSlash);
    for (core::int i = firstSlash.{core::num::+}(1); i.{core::num::<}(haystack.{core::String::length}); i = i.{core::num::+}(1)) {
      if(!haystack.{core::String::[]}(i).{core::String::==}(needle)) {
        core::String sub = haystack.{core::String::substring}(i);
        if(!sub.{core::String::endsWith}(needle))
          return sub;
        core::int lastSlash = sub.{core::String::lastIndexOf}(needle);
        for (core::int j = lastSlash.{core::num::-}(1); j.{core::num::>=}(0); j = j.{core::num::-}(1)) {
          if(!sub.{core::String::[]}(j).{core::String::==}(needle)) {
            return sub.{core::String::substring}(0, j.{core::num::+}(1));
          }
        }
        return lastSlash.{core::num::==}(1.{core::int::unary-}()) ?{core::String} sub : sub.{core::String::substring}(0, lastSlash);
      }
    }
    return haystack.{core::String::substring}(0, firstSlash);
  }
  static method stripStraySlashes(core::String str) → core::String
    return str2::stripStray(str, "/");
  static method stripRegexStraySlashes(core::String str) → core::String
    return str2::stripStray(str, "\\/");
}
library http_server from "package:http_server/http_server.dart" as htt6 {
  export "package:http_server/src/http_body.dart";
  export "package:http_server/src/http_multipart_form_data.dart";
  export "package:http_server/src/virtual_directory.dart";
  export "package:http_server/src/virtual_host.dart";
}
library from "package:body_parser/src/map_from_uri.dart" as map2 {
  import "package:body_parser/src/get_value.dart";
  static method buildMapFromUri(core::Map<dynamic, dynamic> map, core::String body) → dynamic {
    core::RegExp parseArrayRgx = core::RegExp::•("^(.+)\\[\\]\$");
    for (core::String keyValuePair in body.{core::String::split}("&")) {
      if(keyValuePair.{core::String::contains}("=")) {
        core::int equals = keyValuePair.{core::String::indexOf}("=");
        core::String key = core::Uri::decodeQueryComponent(keyValuePair.{core::String::substring}(0, equals));
        core::String value = core::Uri::decodeQueryComponent(keyValuePair.{core::String::substring}(equals.{core::num::+}(1)));
        if(parseArrayRgx.{core::RegExp::hasMatch}(key)) {
          core::Match queryMatch = parseArrayRgx.{core::RegExp::firstMatch}(key);
          key = queryMatch.{core::Match::group}(1);
          if(!(map.{core::Map::[]}(key) is core::List<dynamic>)) {
            map.{core::Map::[]=}(key, <dynamic>[]);
          }
          map.{core::Map::[]}(key).add(get::getValue(value));
        }
        else
          if(key.{core::String::contains}(".")) {
            core::List<core::String> keys = key.{core::String::split}(".");
            core::Map<dynamic, dynamic> targetMap = (let final dynamic #t534 = map.{core::Map::[]}(keys.{core::List::[]}(0)) in #t534.==(null) ?{dynamic} <dynamic, dynamic>{} : #t534) as{TypeError} core::Map<dynamic, dynamic>;
            map.{core::Map::[]=}(keys.{core::List::[]}(0), targetMap);
            for (core::int i = 1; i.{core::num::<}(keys.{core::List::length}); i = i.{core::num::+}(1)) {
              if(i.{core::num::<}(keys.{core::List::length}.{core::num::-}(1))) {
                targetMap.{core::Map::[]=}(keys.{core::List::[]}(i), let final dynamic #t535 = targetMap.{core::Map::[]}(keys.{core::List::[]}(i)) in #t535.==(null) ?{dynamic} <dynamic, dynamic>{} : #t535);
                targetMap = targetMap.{core::Map::[]}(keys.{core::List::[]}(i)) as core::Map<dynamic, dynamic>;
              }
              else {
                targetMap.{core::Map::[]=}(keys.{core::List::[]}(i), get::getValue(value));
              }
            }
          }
          else
            map.{core::Map::[]=}(key, get::getValue(value));
      }
      else
        map.{core::Map::[]=}(core::Uri::decodeQueryComponent(keyValuePair), true);
    }
  }
}
library from "package:stack_trace/src/chain.dart" as cha3 {
  import "dart:async";
  import "dart:math" as math;
  import "package:stack_trace/src/frame.dart";
  import "package:stack_trace/src/lazy_chain.dart";
  import "package:stack_trace/src/stack_zone_specification.dart";
  import "package:stack_trace/src/trace.dart";
  import "package:stack_trace/src/utils.dart";
  @core::Deprecated::•("Will be removed in stack_trace 2.0.0.")
  typedef ChainHandler = (dynamic, cha3::Chain) → void;
  class Chain extends core::Object implements core::StackTrace {
    final field core::List<tra::Trace> traces;
    constructor •(core::Iterable<tra::Trace> traces) → void
      : cha3::Chain::traces = core::List::unmodifiable<tra::Trace>(traces), super core::Object::•()
      ;
    static get _currentSpec() → sta2::StackZoneSpecification
      return asy::Zone::current.{asy::Zone::[]}(cha3::_specKey) as{TypeError} sta2::StackZoneSpecification;
    static method capture<T extends core::Object = dynamic>(() → cha3::Chain::capture::T callback, {(dynamic, cha3::Chain) → void onError = null, core::bool when = true, core::bool errorZone = true}) → cha3::Chain::capture::T {
      if(!errorZone && !onError.{core::Object::==}(null)) {
        throw new core::ArgumentError::value(onError, "onError", "must be null if errorZone is false");
      }
      if(!when) {
        dynamic newOnError;
        if(!onError.{core::Object::==}(null)) {
          newOnError = (dynamic error, dynamic stackTrace) → core::Null {
            onError.call(error, stackTrace.{core::Object::==}(null) ?{cha3::Chain} cha3::Chain::current() : cha3::Chain::forTrace(stackTrace as{TypeError} core::StackTrace));
          };
        }
        return asy::runZoned<cha3::Chain::capture::T>(callback, onError: newOnError as{TypeError} core::Function);
      }
      sta2::StackZoneSpecification spec = new sta2::StackZoneSpecification::•(onError, errorZone: errorZone);
      return asy::runZoned<cha3::Chain::capture::T>(() → cha3::Chain::capture::T {
        try {
          return callback.call();
        }
        on dynamic catch(final dynamic error, final core::StackTrace stackTrace) {
          asy::Zone::current.{asy::Zone::handleUncaughtError}(error, stackTrace);
          return null;
        }
      }, zoneSpecification: spec.{sta2::StackZoneSpecification::toSpec}(), zoneValues: <dynamic, dynamic>{cha3::_specKey: spec, sta2::StackZoneSpecification::disableKey: false});
    }
    static method disable<T extends core::Object = dynamic>(() → cha3::Chain::disable::T callback, {core::bool when = true}) → cha3::Chain::disable::T {
      core::Map<core::Object, core::bool> zoneValues = when ?{core::Map<core::Object, core::bool>} <core::Object, core::bool>{cha3::_specKey: null, sta2::StackZoneSpecification::disableKey: true} : null;
      return asy::runZoned<cha3::Chain::disable::T>(callback, zoneValues: zoneValues);
    }
    @core::Deprecated::•("Chain.track is not necessary in Dart 1.7+.")
    static method track(dynamic futureOrStream) → dynamic
      return futureOrStream;
    static factory current([core::int level = 0]) → cha3::Chain {
      if(!cha3::Chain::_currentSpec.{core::Object::==}(null))
        return cha3::Chain::_currentSpec.{sta2::StackZoneSpecification::currentChain}(level.{core::num::+}(1));
      cha3::Chain chain = cha3::Chain::forTrace(core::StackTrace::current);
      return new laz::LazyChain::•(() → cha3::Chain {
        tra::Trace first = new tra::Trace::•(chain.{cha3::Chain::traces}.{core::Iterable::first}.{tra::Trace::frames}.{core::Iterable::skip}(level.{core::num::+}(uti2::inJS ?{core::int} 2 : 1)), original: chain.{cha3::Chain::traces}.{core::Iterable::first}.{tra::Trace::original}.{core::StackTrace::toString}());
        return new cha3::Chain::•(let final core::List<tra::Trace> #t536 = <tra::Trace>[first] in let final dynamic #t537 = #t536.{core::List::addAll}(chain.{cha3::Chain::traces}.{core::Iterable::skip}(1)) in #t536);
      });
    }
    static factory forTrace(core::StackTrace trace) → cha3::Chain {
      if(trace is cha3::Chain)
        return trace{cha3::Chain};
      if(!cha3::Chain::_currentSpec.{core::Object::==}(null))
        return cha3::Chain::_currentSpec.{sta2::StackZoneSpecification::chainFor}(trace);
      if(trace is tra::Trace)
        return new cha3::Chain::•(<tra::Trace>[trace{tra::Trace}]);
      return new laz::LazyChain::•(() → cha3::Chain => cha3::Chain::parse(trace.{core::StackTrace::toString}()));
    }
    static factory parse(core::String chain) → cha3::Chain {
      if(chain.{core::String::isEmpty})
        return new cha3::Chain::•(<tra::Trace>[]);
      if(chain.{core::String::contains}(uti2::vmChainGap)) {
        return new cha3::Chain::•(chain.{core::String::split}(uti2::vmChainGap).{core::Iterable::map}<tra::Trace>((core::String trace) → tra::Trace => new tra::Trace::parseVM(trace)));
      }
      if(!chain.{core::String::contains}(uti2::chainGap))
        return new cha3::Chain::•(<tra::Trace>[tra::Trace::parse(chain)]);
      return new cha3::Chain::•(chain.{core::String::split}(uti2::chainGap).{core::Iterable::map}<tra::Trace>((core::String trace) → tra::Trace => new tra::Trace::parseFriendly(trace)));
    }
    get terse() → cha3::Chain
      return this.{cha3::Chain::foldFrames}((fra::Frame _) → core::bool => false, terse: true);
    method foldFrames((fra::Frame) → core::bool predicate, {core::bool terse = false}) → cha3::Chain {
      core::Iterable<tra::Trace> foldedTraces = this.{cha3::Chain::traces}.{core::Iterable::map}<tra::Trace>((tra::Trace trace) → tra::Trace => trace.{tra::Trace::foldFrames}(predicate, terse: terse));
      core::Iterable<tra::Trace> nonEmptyTraces = foldedTraces.{core::Iterable::where}((tra::Trace trace) → core::bool {
        if(trace.{tra::Trace::frames}.{core::List::length}.{core::num::>}(1))
          return true;
        if(trace.{tra::Trace::frames}.{core::Iterable::isEmpty})
          return false;
        if(!terse)
          return false;
        return !trace.{tra::Trace::frames}.{core::Iterable::single}.{fra::Frame::line}.{core::num::==}(null);
      });
      if(nonEmptyTraces.{core::Iterable::isEmpty} && foldedTraces.{core::Iterable::isNotEmpty}) {
        return new cha3::Chain::•(<tra::Trace>[foldedTraces.{core::Iterable::last}]);
      }
      return new cha3::Chain::•(nonEmptyTraces);
    }
    method toTrace() → tra::Trace
      return new tra::Trace::•(this.{cha3::Chain::traces}.{core::Iterable::expand}<fra::Frame>((tra::Trace trace) → core::List<fra::Frame> => trace.{tra::Trace::frames}));
    method toString() → core::String {
      core::int longest = this.{cha3::Chain::traces}.{core::Iterable::map}<core::int>((tra::Trace trace) → core::int {
        return trace.{tra::Trace::frames}.{core::Iterable::map}<core::int>((fra::Frame frame) → core::int => frame.{fra::Frame::location}.{core::String::length}).{core::Iterable::fold}<core::int>(0, math::max<core::int>);
      }).{core::Iterable::fold}<core::int>(0, math::max<core::int>);
      return this.{cha3::Chain::traces}.{core::Iterable::map}<core::String>((tra::Trace trace) → core::String {
        return trace.{tra::Trace::frames}.{core::Iterable::map}<core::String>((fra::Frame frame) → core::String {
          return "${frame.{fra::Frame::location}.{core::String::padRight}(longest)}  ${frame.{fra::Frame::member}}\n";
        }).{core::Iterable::join}();
      }).{core::Iterable::join}(uti2::chainGap);
    }
  }
  static final field core::Object _specKey = new core::Object::•();
}
library from "package:stack_trace/src/frame.dart" as fra {
  import "package:path/path.dart" as path;
  import "package:stack_trace/src/trace.dart";
  import "package:stack_trace/src/unparsed_frame.dart";
  class Frame extends core::Object {
    final field core::Uri uri;
    final field core::int line;
    final field core::int column;
    final field core::String member;
    static final field core::RegExp _uriRegExp = core::RegExp::•("^[a-zA-Z][-+.a-zA-Z\\d]*://");
    static final field core::RegExp _windowsRegExp = core::RegExp::•("^([a-zA-Z]:[\\\\/]|\\\\\\\\)");
    constructor •(core::Uri uri, core::int line, core::int column, core::String member) → void
      : fra::Frame::uri = uri, fra::Frame::line = line, fra::Frame::column = column, fra::Frame::member = member, super core::Object::•()
      ;
    get isCore() → core::bool
      return this.{fra::Frame::uri}.{core::Uri::scheme}.{core::String::==}("dart");
    get library() → core::String {
      if(this.{fra::Frame::uri}.{core::Uri::scheme}.{core::String::==}("data"))
        return "data:...";
      return path::prettyUri(this.{fra::Frame::uri});
    }
    get package() → core::String {
      if(!this.{fra::Frame::uri}.{core::Uri::scheme}.{core::String::==}("package"))
        return null;
      return this.{fra::Frame::uri}.{core::Uri::path}.{core::String::split}("/").{core::Iterable::first};
    }
    get location() → core::String {
      if(this.{fra::Frame::line}.{core::num::==}(null))
        return this.{fra::Frame::library};
      if(this.{fra::Frame::column}.{core::num::==}(null))
        return "${this.{fra::Frame::library}} ${this.{fra::Frame::line}}";
      return "${this.{fra::Frame::library}} ${this.{fra::Frame::line}}:${this.{fra::Frame::column}}";
    }
    static factory caller([core::int level = 1]) → fra::Frame {
      if(level.{core::num::<}(0)) {
        throw new core::ArgumentError::•("Argument [level] must be greater than or equal to 0.");
      }
      return tra::Trace::current(level.{core::num::+}(1)).{tra::Trace::frames}.{core::Iterable::first};
    }
    static factory parseVM(core::String frame) → fra::Frame
      return fra::Frame::_catchFormatException(frame, () → fra::Frame {
        if(frame.{core::String::==}("...")) {
          return new fra::Frame::•(core::_Uri::•(), null, null, "...");
        }
        core::Match match = fra::_vmFrame.{core::RegExp::firstMatch}(frame);
        if(match.{core::Object::==}(null))
          return new unp::UnparsedFrame::•(frame);
        core::String member = match.{core::Match::[]}(1).{core::String::replaceAll}(fra::_asyncBody, "<async>").{core::String::replaceAll}("<anonymous closure>", "<fn>");
        core::Uri uri = core::Uri::parse(match.{core::Match::[]}(2));
        core::List<core::String> lineAndColumn = match.{core::Match::[]}(3).{core::String::split}(":");
        core::int line = lineAndColumn.{core::List::length}.{core::num::>}(1) ?{core::int} core::int::parse(lineAndColumn.{core::List::[]}(1)) : null;
        core::int column = lineAndColumn.{core::List::length}.{core::num::>}(2) ?{core::int} core::int::parse(lineAndColumn.{core::List::[]}(2)) : null;
        return new fra::Frame::•(uri, line, column, member);
      });
    static factory parseV8(core::String frame) → fra::Frame
      return fra::Frame::_catchFormatException(frame, () → fra::Frame {
        core::Match match = fra::_v8Frame.{core::RegExp::firstMatch}(frame);
        if(match.{core::Object::==}(null))
          return new unp::UnparsedFrame::•(frame);
        function parseLocation(dynamic location, dynamic member) → fra::Frame {
          core::Match evalMatch = fra::_v8EvalLocation.{core::RegExp::firstMatch}(location as{TypeError} core::String);
          while (!evalMatch.{core::Object::==}(null)) {
            location = evalMatch.{core::Match::[]}(1);
            evalMatch = fra::_v8EvalLocation.{core::RegExp::firstMatch}(location as{TypeError} core::String);
          }
          if(location.{core::Object::==}("native")) {
            return new fra::Frame::•(core::Uri::parse("native"), null, null, member as{TypeError} core::String);
          }
          core::Match urlMatch = fra::_v8UrlLocation.{core::RegExp::firstMatch}(location as{TypeError} core::String);
          if(urlMatch.{core::Object::==}(null))
            return new unp::UnparsedFrame::•(frame);
          return new fra::Frame::•(fra::Frame::_uriOrPathToUri(urlMatch.{core::Match::[]}(1)), core::int::parse(urlMatch.{core::Match::[]}(2)), core::int::parse(urlMatch.{core::Match::[]}(3)), member as{TypeError} core::String);
        }
        if(!match.{core::Match::[]}(2).{core::String::==}(null)) {
          return parseLocation.call(match.{core::Match::[]}(2), match.{core::Match::[]}(1).{core::String::replaceAll}("<anonymous>", "<fn>").{core::String::replaceAll}("Anonymous function", "<fn>").{core::String::replaceAll}("(anonymous function)", "<fn>"));
        }
        else {
          return parseLocation.call(match.{core::Match::[]}(3), "<fn>");
        }
      });
    static factory parseJSCore(core::String frame) → fra::Frame
      return fra::Frame::parseV8(frame);
    static factory parseIE(core::String frame) → fra::Frame
      return fra::Frame::parseV8(frame);
    static factory parseFirefox(core::String frame) → fra::Frame
      return fra::Frame::_catchFormatException(frame, () → fra::Frame {
        core::Match match = fra::_firefoxSafariFrame.{core::RegExp::firstMatch}(frame);
        if(match.{core::Object::==}(null))
          return new unp::UnparsedFrame::•(frame);
        core::Uri uri = fra::Frame::_uriOrPathToUri(match.{core::Match::[]}(3));
        dynamic member;
        if(!match.{core::Match::[]}(1).{core::String::==}(null)) {
          member = match.{core::Match::[]}(1);
          member = member.+(core::List::filled<core::String>("/".{core::Pattern::allMatches}(match.{core::Match::[]}(2)).{core::Iterable::length}, ".<fn>").{core::Iterable::join}());
          if(member.{core::Object::==}(""))
            member = "<fn>";
          member = member.replaceFirst(fra::_initialDot, "");
        }
        else {
          member = "<fn>";
        }
        core::int line = match.{core::Match::[]}(4).{core::String::==}("") ?{core::int} null : core::int::parse(match.{core::Match::[]}(4));
        core::int column = match.{core::Match::[]}(5).{core::String::==}(null) || match.{core::Match::[]}(5).{core::String::==}("") ?{core::int} null : core::int::parse(match.{core::Match::[]}(5));
        return new fra::Frame::•(uri, line, column, member as{TypeError} core::String);
      });
    @core::Deprecated::•("Use Frame.parseSafari instead.")
    static factory parseSafari6_0(core::String frame) → fra::Frame
      return fra::Frame::parseFirefox(frame);
    @core::Deprecated::•("Use Frame.parseSafari instead.")
    static factory parseSafari6_1(core::String frame) → fra::Frame
      return fra::Frame::parseFirefox(frame);
    static factory parseSafari(core::String frame) → fra::Frame
      return fra::Frame::parseFirefox(frame);
    static factory parseFriendly(core::String frame) → fra::Frame
      return fra::Frame::_catchFormatException(frame, () → fra::Frame {
        core::Match match = fra::_friendlyFrame.{core::RegExp::firstMatch}(frame);
        if(match.{core::Object::==}(null)) {
          throw new core::FormatException::•("Couldn't parse package:stack_trace stack trace line '${frame}'.");
        }
        core::Uri uri = match.{core::Match::[]}(1).{core::String::==}("data:...") ?{core::Uri} core::Uri::dataFromString("") : core::Uri::parse(match.{core::Match::[]}(1));
        if(uri.{core::Uri::scheme}.{core::String::==}("")) {
          uri = path::toUri(path::absolute(path::fromUri(uri)));
        }
        core::int line = match.{core::Match::[]}(2).{core::String::==}(null) ?{core::int} null : core::int::parse(match.{core::Match::[]}(2));
        core::int column = match.{core::Match::[]}(3).{core::String::==}(null) ?{core::int} null : core::int::parse(match.{core::Match::[]}(3));
        return new fra::Frame::•(uri, line, column, match.{core::Match::[]}(4));
      });
    static method _uriOrPathToUri(core::String uriOrPath) → core::Uri {
      if(uriOrPath.{core::String::contains}(fra::Frame::_uriRegExp)) {
        return core::Uri::parse(uriOrPath);
      }
      else
        if(uriOrPath.{core::String::contains}(fra::Frame::_windowsRegExp)) {
          return core::_Uri::file(uriOrPath, windows: true);
        }
        else
          if(uriOrPath.{core::String::startsWith}("/")) {
            return core::_Uri::file(uriOrPath, windows: false);
          }
      if(uriOrPath.{core::String::contains}("\\"))
        return path::windows.{con5::Context::toUri}(uriOrPath);
      return core::Uri::parse(uriOrPath);
    }
    static method _catchFormatException(core::String text, () → fra::Frame body) → fra::Frame {
      try {
        return body.call();
      }
      on core::FormatException catch(final core::FormatException _) {
        return new unp::UnparsedFrame::•(text);
      }
    }
    method toString() → core::String
      return "${this.{fra::Frame::location}} in ${this.{fra::Frame::member}}";
  }
  static final field core::RegExp _vmFrame = core::RegExp::•("^#\\d+\\s+(\\S.*) \\((.+?)((?::\\d+){0,2})\\)\$");
  static final field core::RegExp _v8Frame = core::RegExp::•("^\\s*at (?:(\\S.*?)(?: \\[as [^\\]]+\\])? \\((.*)\\)|(.*))\$");
  static final field core::RegExp _v8UrlLocation = core::RegExp::•("^(.*):(\\d+):(\\d+)|native\$");
  static final field core::RegExp _v8EvalLocation = core::RegExp::•("^eval at (?:\\S.*?) \\((.*)\\)(?:, .*?:\\d+:\\d+)?\$");
  static final field core::RegExp _firefoxSafariFrame = core::RegExp::•("^(?:([^@(/]*)(?:\\(.*\\))?((?:/[^/]*)*)(?:\\(.*\\))?@)?(.*?):(\\d*)(?::(\\d*))?\$");
  static final field core::RegExp _friendlyFrame = core::RegExp::•("^(\\S+)(?: (\\d+)(?::(\\d+))?)?\\s+([^\\d].*)\$");
  static final field core::RegExp _asyncBody = core::RegExp::•("<(<anonymous closure>|[^>]+)_async_body>");
  static final field core::RegExp _initialDot = core::RegExp::•("^\\.");
}
library from "package:stack_trace/src/trace.dart" as tra {
  import "dart:math" as math;
  import "package:stack_trace/src/chain.dart";
  import "package:stack_trace/src/frame.dart";
  import "package:stack_trace/src/lazy_trace.dart";
  import "package:stack_trace/src/unparsed_frame.dart";
  import "package:stack_trace/src/utils.dart";
  import "package:stack_trace/src/vm_trace.dart";
  class Trace extends core::Object implements core::StackTrace {
    final field core::List<fra::Frame> frames;
    final field core::StackTrace original;
    constructor parseVM(core::String trace) → void
      : this tra::Trace::•(tra::Trace::_parseVM(trace), original: trace)
      ;
    constructor parseV8(core::String trace) → void
      : this tra::Trace::•(trace.{core::String::split}("\n").{core::Iterable::skip}(1).{core::Iterable::skipWhile}((core::String line) → core::bool => !line.{core::String::startsWith}(tra::_v8TraceLine)).{core::Iterable::map}<fra::Frame>((core::String line) → fra::Frame => fra::Frame::parseV8(line)), original: trace)
      ;
    constructor parseJSCore(core::String trace) → void
      : this tra::Trace::•(trace.{core::String::split}("\n").{core::Iterable::where}((core::String line) → core::bool => !line.{core::String::==}("\tat ")).{core::Iterable::map}<fra::Frame>((core::String line) → fra::Frame => fra::Frame::parseV8(line)), original: trace)
      ;
    constructor parseIE(core::String trace) → void
      : this tra::Trace::parseV8(trace)
      ;
    constructor parseFirefox(core::String trace) → void
      : this tra::Trace::•(trace.{core::String::trim}().{core::String::split}("\n").{core::Iterable::where}((core::String line) → core::bool => line.{core::String::isNotEmpty} && !line.{core::String::==}("[native code]")).{core::Iterable::map}<fra::Frame>((core::String line) → fra::Frame => fra::Frame::parseFirefox(line)), original: trace)
      ;
    constructor parseSafari(core::String trace) → void
      : this tra::Trace::parseFirefox(trace)
      ;
    @core::Deprecated::•("Use Trace.parseSafari instead.")
    constructor parseSafari6_1(core::String trace) → void
      : this tra::Trace::parseSafari(trace)
      ;
    @core::Deprecated::•("Use Trace.parseSafari instead.")
    constructor parseSafari6_0(core::String trace) → void
      : this tra::Trace::•(trace.{core::String::trim}().{core::String::split}("\n").{core::Iterable::where}((core::String line) → core::bool => !line.{core::String::==}("[native code]")).{core::Iterable::map}<fra::Frame>((core::String line) → fra::Frame => fra::Frame::parseFirefox(line)), original: trace)
      ;
    constructor parseFriendly(core::String trace) → void
      : this tra::Trace::•(trace.{core::String::isEmpty} ?{core::Iterable<fra::Frame>} <fra::Frame>[] : trace.{core::String::trim}().{core::String::split}("\n").{core::Iterable::where}((core::String line) → core::bool => !line.{core::String::startsWith}("=====")).{core::Iterable::map}<fra::Frame>((core::String line) → fra::Frame => fra::Frame::parseFriendly(line)), original: trace)
      ;
    constructor •(core::Iterable<fra::Frame> frames, {core::String original = null}) → void
      : tra::Trace::frames = core::List::unmodifiable<fra::Frame>(frames), tra::Trace::original = new core::_StringStackTrace::•(original), super core::Object::•()
      ;
    static method format(core::StackTrace stackTrace, {core::bool terse = true}) → core::String {
      tra::Trace trace = tra::Trace::from(stackTrace);
      if(terse)
        trace = trace.{tra::Trace::terse};
      return trace.{tra::Trace::toString}();
    }
    static factory current([core::int level = 0]) → tra::Trace {
      if(level.{core::num::<}(0)) {
        throw new core::ArgumentError::•("Argument [level] must be greater than or equal to 0.");
      }
      tra::Trace trace = tra::Trace::from(core::StackTrace::current);
      return new laz2::LazyTrace::•(() → tra::Trace {
        return new tra::Trace::•(trace.{tra::Trace::frames}.{core::Iterable::skip}(level.{core::num::+}(uti2::inJS ?{core::int} 2 : 1)), original: trace.{tra::Trace::original}.{core::StackTrace::toString}());
      });
    }
    static factory from(core::StackTrace trace) → tra::Trace {
      if(trace.{core::Object::==}(null)) {
        throw new core::ArgumentError::•("Cannot create a Trace from null.");
      }
      if(trace is tra::Trace)
        return trace{tra::Trace};
      if(trace is cha3::Chain)
        return trace{cha3::Chain}.{cha3::Chain::toTrace}();
      return new laz2::LazyTrace::•(() → tra::Trace => tra::Trace::parse(trace.{core::StackTrace::toString}()));
    }
    static factory parse(core::String trace) → tra::Trace {
      try {
        if(trace.{core::String::isEmpty})
          return new tra::Trace::•(<fra::Frame>[]);
        if(trace.{core::String::contains}(tra::_v8Trace))
          return new tra::Trace::parseV8(trace);
        if(trace.{core::String::contains}("\tat "))
          return new tra::Trace::parseJSCore(trace);
        if(trace.{core::String::contains}(tra::_firefoxSafariTrace)) {
          return new tra::Trace::parseFirefox(trace);
        }
        if(trace.{core::String::contains}(uti2::chainGap))
          return cha3::Chain::parse(trace).{cha3::Chain::toTrace}();
        if(trace.{core::String::contains}(tra::_friendlyTrace)) {
          return new tra::Trace::parseFriendly(trace);
        }
        return new tra::Trace::parseVM(trace);
      }
      on core::FormatException catch(final core::FormatException error) {
        throw new core::FormatException::•("${error.{core::FormatException::message}}\nStack trace:\n${trace}");
      }
    }
    static method _parseVM(core::String trace) → core::List<fra::Frame> {
      core::List<core::String> lines = trace.{core::String::trim}().{core::String::replaceAll}(uti2::vmChainGap, "").{core::String::split}("\n");
      core::List<fra::Frame> frames = lines.{core::Iterable::take}(lines.{core::List::length}.{core::num::-}(1)).{core::Iterable::map}<fra::Frame>((core::String line) → fra::Frame => fra::Frame::parseVM(line)).{core::Iterable::toList}();
      if(!lines.{core::Iterable::last}.{core::String::endsWith}(".da")) {
        frames.{core::List::add}(fra::Frame::parseVM(lines.{core::Iterable::last}));
      }
      return frames;
    }
    get vmTrace() → core::StackTrace
      return new vm_::VMTrace::•(this.{tra::Trace::frames});
    get terse() → tra::Trace
      return this.{tra::Trace::foldFrames}((fra::Frame _) → core::bool => false, terse: true);
    method foldFrames((fra::Frame) → core::bool predicate, {core::bool terse = false}) → tra::Trace {
      if(terse) {
        (fra::Frame) → core::bool oldPredicate = predicate;
        predicate = (fra::Frame frame) → core::bool {
          if(oldPredicate.call(frame))
            return true;
          if(frame.{fra::Frame::isCore})
            return true;
          if(frame.{fra::Frame::package}.{core::String::==}("stack_trace"))
            return true;
          if(!frame.{fra::Frame::member}.{core::String::contains}("<async>"))
            return false;
          return frame.{fra::Frame::line}.{core::num::==}(null);
        };
      }
      core::List<fra::Frame> newFrames = <fra::Frame>[];
      for (fra::Frame frame in this.{tra::Trace::frames}.{core::List::reversed}) {
        if(frame is unp::UnparsedFrame || !predicate.call(frame)) {
          newFrames.{core::List::add}(frame);
        }
        else
          if(newFrames.{core::Iterable::isEmpty} || !predicate.call(newFrames.{core::Iterable::last})) {
            newFrames.{core::List::add}(new fra::Frame::•(frame.{fra::Frame::uri}, frame.{fra::Frame::line}, frame.{fra::Frame::column}, frame.{fra::Frame::member}));
          }
      }
      if(terse) {
        newFrames = newFrames.{core::Iterable::map}<fra::Frame>((fra::Frame frame) → fra::Frame {
          if(frame is unp::UnparsedFrame || !predicate.call(frame))
            return frame;
          core::String library = frame.{fra::Frame::library}.{core::String::replaceAll}(tra::_terseRegExp, "");
          return new fra::Frame::•(core::Uri::parse(library), null, null, frame.{fra::Frame::member});
        }).{core::Iterable::toList}();
        if(newFrames.{core::List::length}.{core::num::>}(1) && predicate.call(newFrames.{core::Iterable::first})) {
          newFrames.{core::List::removeAt}(0);
        }
      }
      return new tra::Trace::•(newFrames.{core::List::reversed}, original: this.{tra::Trace::original}.{core::StackTrace::toString}());
    }
    method toString() → core::String {
      core::int longest = this.{tra::Trace::frames}.{core::Iterable::map}<core::int>((fra::Frame frame) → core::int => frame.{fra::Frame::location}.{core::String::length}).{core::Iterable::fold}<core::int>(0, math::max<core::int>);
      return this.{tra::Trace::frames}.{core::Iterable::map}<core::String>((fra::Frame frame) → core::String {
        if(frame is unp::UnparsedFrame)
          return "${frame{unp::UnparsedFrame}}\n";
        return "${frame.{fra::Frame::location}.{core::String::padRight}(longest)}  ${frame.{fra::Frame::member}}\n";
      }).{core::Iterable::join}();
    }
  }
  static final field core::RegExp _terseRegExp = core::RegExp::•("(-patch)?([/\\\\].*)?\$");
  static final field core::RegExp _v8Trace = core::RegExp::•("\\n    ?at ");
  static final field core::RegExp _v8TraceLine = core::RegExp::•("    ?at ");
  static final field core::RegExp _firefoxSafariTrace = core::RegExp::•("^(([.0-9A-Za-z_\$/<]|\\(.*\\))*@)?[^\\s]*:\\d*\$", multiLine: true);
  static final field core::RegExp _friendlyTrace = core::RegExp::•("^[^\\s<][^\\s]*( \\d+(:\\d+)?)?[ \\t]+[^\\s]+\$", multiLine: true);
}
library from "package:stack_trace/src/unparsed_frame.dart" as unp {
  import "package:stack_trace/src/frame.dart";
  class UnparsedFrame extends core::Object implements fra::Frame {
    final field core::Uri uri = core::_Uri::•(path: "unparsed");
    final field core::int line = null;
    final field core::int column = null;
    final field core::bool isCore = false;
    final field core::String library = "unparsed";
    final field core::String package = null;
    final field core::String location = "unparsed";
    final field core::String member;
    constructor •(core::String member) → void
      : unp::UnparsedFrame::member = member, super core::Object::•()
      ;
    method toString() → core::String
      return this.{unp::UnparsedFrame::member};
  }
}
library from "package:args/src/allow_anything_parser.dart" as all {
  import "package:args/src/arg_parser.dart";
  import "package:args/src/arg_results.dart";
  import "package:args/src/option.dart";
  import "package:args/src/parser.dart";
  class AllowAnythingParser extends core::Object implements arg::ArgParser {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    get options() → core::Map<core::String, opt2::Option>
      return const <core::String, opt2::Option>{};
    get commands() → core::Map<core::String, arg::ArgParser>
      return const <core::String, arg::ArgParser>{};
    get allowTrailingOptions() → core::bool
      return false;
    get allowsAnything() → core::bool
      return true;
    get usageLineLength() → core::int
      return null;
    method addCommand(core::String name, [arg::ArgParser parser = null]) → arg::ArgParser {
      throw new core::UnsupportedError::•("ArgParser.allowAnything().addCommands() isn't supported.");
    }
    method addFlag(core::String name, {core::String abbr = null, core::String help = null, core::bool defaultsTo = false, core::bool negatable = true, (core::bool) → void callback = null, core::bool hide = false}) → void {
      throw new core::UnsupportedError::•("ArgParser.allowAnything().addFlag() isn't supported.");
    }
    method addOption(core::String name, {core::String abbr = null, core::String help = null, core::String valueHelp = null, core::Iterable<core::String> allowed = null, core::Map<core::String, core::String> allowedHelp = null, core::String defaultsTo = null, core::Function callback = null, core::bool allowMultiple = false, core::bool splitCommas = null, core::bool hide = false}) → void {
      throw new core::UnsupportedError::•("ArgParser.allowAnything().addOption() isn't supported.");
    }
    method addMultiOption(core::String name, {core::String abbr = null, core::String help = null, core::String valueHelp = null, core::Iterable<core::String> allowed = null, core::Map<core::String, core::String> allowedHelp = null, core::Iterable<core::String> defaultsTo = null, (core::List<core::String>) → void callback = null, core::bool splitCommas = true, core::bool hide = false}) → void {
      throw new core::UnsupportedError::•("ArgParser.allowAnything().addMultiOption() isn't supported.");
    }
    method addSeparator(core::String text) → void {
      throw new core::UnsupportedError::•("ArgParser.allowAnything().addSeparator() isn't supported.");
    }
    method parse(core::Iterable<core::String> args) → arg2::ArgResults
      return new par2::Parser::•(null, this, args.{core::Iterable::toList}()).{par2::Parser::parse}();
    method getUsage() → core::String
      return this.{all::AllowAnythingParser::usage};
    get usage() → core::String
      return "";
    method getDefault(core::String option) → dynamic {
      throw new core::ArgumentError::•("No option named ${option}");
    }
    method findByAbbreviation(core::String abbr) → opt2::Option
      return null;
  }
}
library from "package:args/src/parser.dart" as par2 {
  import "package:args/src/arg_parser.dart";
  import "package:args/src/arg_parser_exception.dart";
  import "package:args/src/arg_results.dart";
  import "package:args/src/option.dart";
  class Parser extends core::Object {
    final field core::String commandName;
    final field par2::Parser parent;
    final field arg::ArgParser grammar;
    final field core::List<core::String> args;
    final field core::List<core::String> rest = <core::String>[];
    final field core::Map<core::String, dynamic> results = <core::String, dynamic>{};
    constructor •(core::String commandName, arg::ArgParser grammar, core::List<core::String> args, [par2::Parser parent = null, core::List<core::String> rest = null]) → void
      : par2::Parser::commandName = commandName, par2::Parser::grammar = grammar, par2::Parser::args = args, par2::Parser::parent = parent, super core::Object::•() {
      if(!rest.{core::Object::==}(null))
        this.{par2::Parser::rest}.{core::List::addAll}(rest);
    }
    get current() → core::String
      return this.{par2::Parser::args}.{core::List::[]}(0);
    method parse() → arg2::ArgResults {
      core::List<core::String> arguments = this.{par2::Parser::args}.{core::Iterable::toList}();
      if(this.{par2::Parser::grammar}.{arg::ArgParser::allowsAnything}) {
        return arg2::newArgResults(this.{par2::Parser::grammar}, const <core::String, dynamic>{}, this.{par2::Parser::commandName}, null, arguments, arguments);
      }
      arg2::ArgResults commandResults;
      #L61:
      while (this.{par2::Parser::args}.{core::List::length}.{core::num::>}(0))
        #L62:
        {
          if(this.{par2::Parser::current}.{core::String::==}("--")) {
            this.{par2::Parser::args}.{core::List::removeAt}(0);
            break #L61;
          }
          arg::ArgParser command = this.{par2::Parser::grammar}.{arg::ArgParser::commands}.{core::Map::[]}(this.{par2::Parser::current});
          if(!command.{core::Object::==}(null)) {
            this.{par2::Parser::validate}(this.{par2::Parser::rest}.{core::Iterable::isEmpty}, "Cannot specify arguments before a command.");
            core::String commandName = this.{par2::Parser::args}.{core::List::removeAt}(0);
            par2::Parser commandParser = new par2::Parser::•(commandName, command, this.{par2::Parser::args}, this, this.{par2::Parser::rest});
            try {
              commandResults = commandParser.{par2::Parser::parse}();
            }
            on arg3::ArgParserException catch(final arg3::ArgParserException error) {
              if(commandName.{core::String::==}(null))
                rethrow;
              throw new arg3::ArgParserException::•(error.{core::FormatException::message}, let final core::List<core::String> #t538 = <core::String>[commandName] in let final dynamic #t539 = #t538.{core::List::addAll}(error.{arg3::ArgParserException::commands}) in #t538);
            }
            this.{par2::Parser::rest}.{core::List::clear}();
            break #L61;
          }
          if(this.{par2::Parser::parseSoloOption}())
            break #L62;
          if(this.{par2::Parser::parseAbbreviation}(this))
            break #L62;
          if(this.{par2::Parser::parseLongOption}())
            break #L62;
          if(!this.{par2::Parser::grammar}.{arg::ArgParser::allowTrailingOptions})
            break #L61;
          this.{par2::Parser::rest}.{core::List::add}(this.{par2::Parser::args}.{core::List::removeAt}(0));
        }
      this.{par2::Parser::grammar}.{arg::ArgParser::options}.{core::Map::forEach}((core::String name, opt2::Option option) → core::Null {
        if(option.{opt2::Option::callback}.{core::Function::==}(null))
          return;
        option.{opt2::Option::callback}(option.{opt2::Option::getOrDefault}(this.{par2::Parser::results}.{core::Map::[]}(name)));
      });
      this.{par2::Parser::rest}.{core::List::addAll}(this.{par2::Parser::args});
      this.{par2::Parser::args}.{core::List::clear}();
      return arg2::newArgResults(this.{par2::Parser::grammar}, this.{par2::Parser::results}, this.{par2::Parser::commandName}, commandResults, this.{par2::Parser::rest}, arguments);
    }
    method readNextArgAsValue(opt2::Option option) → void {
      this.{par2::Parser::validate}(this.{par2::Parser::args}.{core::List::length}.{core::num::>}(0), "Missing argument for \"${option.{opt2::Option::name}}\".");
      this.{par2::Parser::setOption}(this.{par2::Parser::results}, option, this.{par2::Parser::current});
      this.{par2::Parser::args}.{core::List::removeAt}(0);
    }
    method parseSoloOption() → core::bool {
      core::Match soloOpt = par2::_soloOpt.{core::RegExp::firstMatch}(this.{par2::Parser::current});
      if(soloOpt.{core::Object::==}(null))
        return false;
      opt2::Option option = this.{par2::Parser::grammar}.{arg::ArgParser::findByAbbreviation}(soloOpt.{core::Match::[]}(1));
      if(option.{core::Object::==}(null)) {
        this.{par2::Parser::validate}(!this.{par2::Parser::parent}.{core::Object::==}(null), "Could not find an option or flag \"-${soloOpt.{core::Match::[]}(1)}\".");
        return this.{par2::Parser::parent}.{par2::Parser::parseSoloOption}();
      }
      this.{par2::Parser::args}.{core::List::removeAt}(0);
      if(option.{opt2::Option::isFlag}) {
        this.{par2::Parser::setFlag}(this.{par2::Parser::results}, option, true);
      }
      else {
        this.{par2::Parser::readNextArgAsValue}(option);
      }
      return true;
    }
    method parseAbbreviation(par2::Parser innermostCommand) → core::bool {
      core::Match abbrOpt = par2::_abbrOpt.{core::RegExp::firstMatch}(this.{par2::Parser::current});
      if(abbrOpt.{core::Object::==}(null))
        return false;
      core::String c = abbrOpt.{core::Match::[]}(1).{core::String::substring}(0, 1);
      opt2::Option first = this.{par2::Parser::grammar}.{arg::ArgParser::findByAbbreviation}(c);
      if(first.{core::Object::==}(null)) {
        this.{par2::Parser::validate}(!this.{par2::Parser::parent}.{core::Object::==}(null), "Could not find an option with short name \"-${c}\".");
        return this.{par2::Parser::parent}.{par2::Parser::parseAbbreviation}(innermostCommand);
      }
      else
        if(!first.{opt2::Option::isFlag}) {
          core::String value = "${abbrOpt.{core::Match::[]}(1).{core::String::substring}(1)}${abbrOpt.{core::Match::[]}(2)}";
          this.{par2::Parser::setOption}(this.{par2::Parser::results}, first, value);
        }
        else {
          this.{par2::Parser::validate}(abbrOpt.{core::Match::[]}(2).{core::String::==}(""), "Option \"-${c}\" is a flag and cannot handle value \"${abbrOpt.{core::Match::[]}(1).{core::String::substring}(1)}${abbrOpt.{core::Match::[]}(2)}\".");
          for (core::int i = 0; i.{core::num::<}(abbrOpt.{core::Match::[]}(1).{core::String::length}); i = i.{core::num::+}(1)) {
            core::String c = abbrOpt.{core::Match::[]}(1).{core::String::substring}(i, i.{core::num::+}(1));
            innermostCommand.{par2::Parser::parseShortFlag}(c);
          }
        }
      this.{par2::Parser::args}.{core::List::removeAt}(0);
      return true;
    }
    method parseShortFlag(core::String c) → void {
      opt2::Option option = this.{par2::Parser::grammar}.{arg::ArgParser::findByAbbreviation}(c);
      if(option.{core::Object::==}(null)) {
        this.{par2::Parser::validate}(!this.{par2::Parser::parent}.{core::Object::==}(null), "Could not find an option with short name \"-${c}\".");
        this.{par2::Parser::parent}.{par2::Parser::parseShortFlag}(c);
        return;
      }
      this.{par2::Parser::validate}(option.{opt2::Option::isFlag}, "Option \"-${c}\" must be a flag to be in a collapsed \"-\".");
      this.{par2::Parser::setFlag}(this.{par2::Parser::results}, option, true);
    }
    method parseLongOption() → core::bool {
      core::Match longOpt = par2::_longOpt.{core::RegExp::firstMatch}(this.{par2::Parser::current});
      if(longOpt.{core::Object::==}(null))
        return false;
      core::String name = longOpt.{core::Match::[]}(1);
      opt2::Option option = this.{par2::Parser::grammar}.{arg::ArgParser::options}.{core::Map::[]}(name);
      if(!option.{core::Object::==}(null)) {
        this.{par2::Parser::args}.{core::List::removeAt}(0);
        if(option.{opt2::Option::isFlag}) {
          this.{par2::Parser::validate}(longOpt.{core::Match::[]}(3).{core::String::==}(null), "Flag option \"${name}\" should not be given a value.");
          this.{par2::Parser::setFlag}(this.{par2::Parser::results}, option, true);
        }
        else
          if(!longOpt.{core::Match::[]}(3).{core::String::==}(null)) {
            this.{par2::Parser::setOption}(this.{par2::Parser::results}, option, longOpt.{core::Match::[]}(3));
          }
          else {
            this.{par2::Parser::readNextArgAsValue}(option);
          }
      }
      else
        if(name.{core::String::startsWith}("no-")) {
          name = name.{core::String::substring}("no-".{core::String::length});
          option = this.{par2::Parser::grammar}.{arg::ArgParser::options}.{core::Map::[]}(name);
          if(option.{core::Object::==}(null)) {
            this.{par2::Parser::validate}(!this.{par2::Parser::parent}.{core::Object::==}(null), "Could not find an option named \"${name}\".");
            return this.{par2::Parser::parent}.{par2::Parser::parseLongOption}();
          }
          this.{par2::Parser::args}.{core::List::removeAt}(0);
          this.{par2::Parser::validate}(option.{opt2::Option::isFlag}, "Cannot negate non-flag option \"${name}\".");
          this.{par2::Parser::validate}(option.{opt2::Option::negatable}, "Cannot negate option \"${name}\".");
          this.{par2::Parser::setFlag}(this.{par2::Parser::results}, option, false);
        }
        else {
          this.{par2::Parser::validate}(!this.{par2::Parser::parent}.{core::Object::==}(null), "Could not find an option named \"${name}\".");
          return this.{par2::Parser::parent}.{par2::Parser::parseLongOption}();
        }
      return true;
    }
    method validate(core::bool condition, core::String message) → void {
      if(!condition)
        throw new arg3::ArgParserException::•(message);
    }
    method setOption(core::Map<dynamic, dynamic> results, opt2::Option option, core::String value) → void {
      assert(!option.{opt2::Option::isFlag});
      if(!option.{opt2::Option::isMultiple}) {
        this.{par2::Parser::_validateAllowed}(option, value);
        results.{core::Map::[]=}(option.{opt2::Option::name}, value);
        return;
      }
      dynamic list = results.{core::Map::putIfAbsent}(option.{opt2::Option::name}, () → core::List<core::String> => <core::String>[]);
      if(option.{opt2::Option::splitCommas}) {
        for (core::String element in value.{core::String::split}(",")) {
          this.{par2::Parser::_validateAllowed}(option, element);
          list.add(element);
        }
      }
      else {
        this.{par2::Parser::_validateAllowed}(option, value);
        list.add(value);
      }
    }
    method setFlag(core::Map<dynamic, dynamic> results, opt2::Option option, core::bool value) → void {
      assert(option.{opt2::Option::isFlag});
      results.{core::Map::[]=}(option.{opt2::Option::name}, value);
    }
    method _validateAllowed(opt2::Option option, core::String value) → void {
      if(option.{opt2::Option::allowed}.{core::Object::==}(null))
        return;
      this.{par2::Parser::validate}(option.{opt2::Option::allowed}.{core::Iterable::contains}(value), "\"${value}\" is not an allowed value for option \"${option.{opt2::Option::name}}\".");
    }
  }
  static final field core::RegExp _soloOpt = core::RegExp::•("^-([a-zA-Z0-9])\$");
  static final field core::RegExp _abbrOpt = core::RegExp::•("^-([a-zA-Z0-9]+)(.*)\$");
  static final field core::RegExp _longOpt = core::RegExp::•("^--([a-zA-Z\\-_0-9]+)(=(.*))?\$");
}
library from "package:args/src/usage.dart" as usa {
  import "dart:math" as math;
  import "package:args/args.dart";
  class Usage extends core::Object {
    static const field core::int _columnCount = 3;
    final field core::List<dynamic> optionsAndSeparators;
    field core::StringBuffer buffer = null;
    field core::int currentColumn = 0;
    field core::List<core::int> columnWidths = null;
    field core::int numHelpLines = 0;
    field core::int newlinesNeeded = 0;
    final field core::int lineLength;
    constructor •(core::List<dynamic> optionsAndSeparators, {core::int lineLength = null}) → void
      : usa::Usage::optionsAndSeparators = optionsAndSeparators, usa::Usage::lineLength = lineLength, super core::Object::•()
      ;
    method generate() → core::String {
      this.{usa::Usage::buffer} = new core::StringBuffer::•();
      this.{usa::Usage::calculateColumnWidths}();
      for (dynamic optionOrSeparator in this.{usa::Usage::optionsAndSeparators})
        #L63:
        {
          if(optionOrSeparator is core::String) {
            if(this.{usa::Usage::buffer}.{core::StringBuffer::isNotEmpty})
              this.{usa::Usage::buffer}.{core::StringBuffer::write}("\n\n");
            this.{usa::Usage::buffer}.{core::StringBuffer::write}(optionOrSeparator{core::String});
            this.{usa::Usage::newlinesNeeded} = 1;
            break #L63;
          }
          opt2::Option option = optionOrSeparator as opt2::Option;
          if(option.{opt2::Option::hide})
            break #L63;
          this.{usa::Usage::write}(0, this.{usa::Usage::getAbbreviation}(option));
          this.{usa::Usage::write}(1, this.{usa::Usage::getLongOption}(option));
          if(!option.{opt2::Option::help}.{core::String::==}(null))
            this.{usa::Usage::write}(2, option.{opt2::Option::help});
          if(!option.{opt2::Option::allowedHelp}.{core::Object::==}(null)) {
            core::List<core::String> allowedNames = option.{opt2::Option::allowedHelp}.{core::Map::keys}.{core::Iterable::toList}(growable: false);
            allowedNames.{core::List::sort}();
            this.{usa::Usage::newline}();
            for (core::String name in allowedNames) {
              this.{usa::Usage::write}(1, this.{usa::Usage::getAllowedTitle}(option, name));
              this.{usa::Usage::write}(2, option.{opt2::Option::allowedHelp}.{core::Map::[]}(name));
            }
            this.{usa::Usage::newline}();
          }
          else
            if(!option.{opt2::Option::allowed}.{core::Object::==}(null)) {
              this.{usa::Usage::write}(2, this.{usa::Usage::buildAllowedList}(option));
            }
            else
              if(option.{opt2::Option::isFlag}) {
                if(option.{opt2::Option::defaultsTo}.{core::Object::==}(true)) {
                  this.{usa::Usage::write}(2, "(defaults to on)");
                }
              }
              else
                if(option.{opt2::Option::isMultiple}) {
                  if(!option.{opt2::Option::defaultsTo}.{core::Object::==}(null) && option.{opt2::Option::defaultsTo}.isNotEmpty as{TypeError} core::bool) {
                    this.{usa::Usage::write}(2, "(defaults to ".{core::String::+}(option.{opt2::Option::defaultsTo}.map((dynamic value) → core::String => "\"${value}\"").join(", ") as{TypeError} core::String).{core::String::+}(")"));
                  }
                }
                else {
                  if(!option.{opt2::Option::defaultsTo}.{core::Object::==}(null)) {
                    this.{usa::Usage::write}(2, "(defaults to \"${option.{opt2::Option::defaultsTo}}\")");
                  }
                }
          if(this.{usa::Usage::numHelpLines}.{core::num::>}(1))
            this.{usa::Usage::newline}();
        }
      return this.{usa::Usage::buffer}.{core::StringBuffer::toString}();
    }
    method getAbbreviation(opt2::Option option) → core::String
      return option.{opt2::Option::abbr}.{core::String::==}(null) ?{core::String} "" : "-${option.{opt2::Option::abbr}}, ";
    method getLongOption(opt2::Option option) → core::String {
      dynamic result;
      if(option.{opt2::Option::negatable}) {
        result = "--[no-]${option.{opt2::Option::name}}";
      }
      else {
        result = "--${option.{opt2::Option::name}}";
      }
      if(!option.{opt2::Option::valueHelp}.{core::String::==}(null))
        result = result.+("=<${option.{opt2::Option::valueHelp}}>");
      return result as{TypeError} core::String;
    }
    method getAllowedTitle(opt2::Option option, core::String allowed) → core::String {
      dynamic isDefault = option.{opt2::Option::defaultsTo} is core::List<dynamic> ?{dynamic} option.{opt2::Option::defaultsTo}.contains(allowed) : option.{opt2::Option::defaultsTo}.{core::Object::==}(allowed);
      return "      [${allowed}]".{core::String::+}(isDefault as{TypeError} core::bool ?{core::String} " (default)" : "");
    }
    method calculateColumnWidths() → void {
      core::int abbr = 0;
      core::int title = 0;
      for (dynamic option in this.{usa::Usage::optionsAndSeparators})
        #L64:
        {
          if(!(option is opt2::Option))
            break #L64;
          if(option.hide as{TypeError} core::bool)
            break #L64;
          abbr = math::max<core::int>(abbr, this.{usa::Usage::getAbbreviation}(option as{TypeError} opt2::Option).{core::String::length});
          title = math::max<core::int>(title, this.{usa::Usage::getLongOption}(option as{TypeError} opt2::Option).{core::String::length});
          if(!option.allowedHelp.{core::Object::==}(null)) {
            for (dynamic allowed in option.allowedHelp.keys as{TypeError} core::Iterable<dynamic>) {
              title = math::max<core::int>(title, this.{usa::Usage::getAllowedTitle}(option as{TypeError} opt2::Option, allowed as{TypeError} core::String).{core::String::length});
            }
          }
        }
      title = title.{core::num::+}(4);
      this.{usa::Usage::columnWidths} = <core::int>[abbr, title];
    }
    method newline() → void {
      this.{usa::Usage::newlinesNeeded} = this.{usa::Usage::newlinesNeeded}.{core::num::+}(1);
      this.{usa::Usage::currentColumn} = 0;
      this.{usa::Usage::numHelpLines} = 0;
    }
    method _wrap(core::String text, core::int start) → core::List<core::String> {
      assert(!this.{usa::Usage::lineLength}.{core::num::==}(null), "Should wrap when given a length.");
      assert(start.{core::num::>=}(0));
      text = text.{core::String::trim}();
      core::int length = math::max<core::int>(this.{usa::Usage::lineLength}.{core::num::-}(start), 10);
      if(text.{core::String::length}.{core::num::<=}(length))
        return <core::String>[text];
      core::List<core::String> result = <core::String>[];
      core::int currentLineStart = 0;
      core::int lastWhitespace;
      for (core::int i = 0; i.{core::num::<}(text.{core::String::length}); i = i.{core::num::+}(1)) {
        if(usa::_isWhitespace(text, i))
          lastWhitespace = i;
        if(i.{core::num::-}(currentLineStart).{core::num::>=}(length)) {
          if(!lastWhitespace.{core::num::==}(null))
            i = lastWhitespace;
          result.{core::List::add}(text.{core::String::substring}(currentLineStart, i));
          while (usa::_isWhitespace(text, i) && i.{core::num::<}(text.{core::String::length}))
            i = i.{core::num::+}(1);
          currentLineStart = i;
          lastWhitespace = null;
        }
      }
      result.{core::List::add}(text.{core::String::substring}(currentLineStart));
      return result;
    }
    method write(core::int column, core::String text) → void {
      core::List<core::String> lines = text.{core::String::split}("\n");
      if(column.{core::num::==}(this.{usa::Usage::columnWidths}.{core::List::length}) && !this.{usa::Usage::lineLength}.{core::num::==}(null)) {
        core::List<core::String> wrappedLines = <core::String>[];
        core::int start = this.{usa::Usage::columnWidths}.{core::List::sublist}(0, column).{core::Iterable::reduce}((core::int start, core::int width) → core::int => start = start.{core::num::+}(width));
        for (core::String line in lines) {
          wrappedLines.{core::List::addAll}(this.{usa::Usage::_wrap}(line, start));
        }
        lines = wrappedLines;
      }
      while (lines.{core::List::length}.{core::num::>}(0) && lines.{core::List::[]}(0).{core::String::trim}().{core::String::==}("")) {
        lines.{core::List::removeRange}(0, 1);
      }
      while (lines.{core::List::length}.{core::num::>}(0) && lines.{core::List::[]}(lines.{core::List::length}.{core::num::-}(1)).{core::String::trim}().{core::String::==}("")) {
        lines.{core::List::removeLast}();
      }
      for (core::String line in lines) {
        this.{usa::Usage::writeLine}(column, line);
      }
    }
    method writeLine(core::int column, core::String text) → void {
      while (this.{usa::Usage::newlinesNeeded}.{core::num::>}(0)) {
        this.{usa::Usage::buffer}.{core::StringBuffer::write}("\n");
        this.{usa::Usage::newlinesNeeded} = this.{usa::Usage::newlinesNeeded}.{core::num::-}(1);
      }
      while (!this.{usa::Usage::currentColumn}.{core::num::==}(column)) {
        if(this.{usa::Usage::currentColumn}.{core::num::<}(usa::Usage::_columnCount.{core::num::-}(1))) {
          this.{usa::Usage::buffer}.{core::StringBuffer::write}(" ".{core::String::*}(this.{usa::Usage::columnWidths}.{core::List::[]}(this.{usa::Usage::currentColumn})));
        }
        else {
          this.{usa::Usage::buffer}.{core::StringBuffer::write}("\n");
        }
        this.{usa::Usage::currentColumn} = this.{usa::Usage::currentColumn}.{core::num::+}(1).{core::num::%}(usa::Usage::_columnCount);
      }
      if(column.{core::num::<}(this.{usa::Usage::columnWidths}.{core::List::length})) {
        this.{usa::Usage::buffer}.{core::StringBuffer::write}(text.{core::String::padRight}(this.{usa::Usage::columnWidths}.{core::List::[]}(column)));
      }
      else {
        this.{usa::Usage::buffer}.{core::StringBuffer::write}(text);
      }
      this.{usa::Usage::currentColumn} = this.{usa::Usage::currentColumn}.{core::num::+}(1).{core::num::%}(usa::Usage::_columnCount);
      if(column.{core::num::==}(usa::Usage::_columnCount.{core::num::-}(1)))
        this.{usa::Usage::newlinesNeeded} = this.{usa::Usage::newlinesNeeded}.{core::num::+}(1);
      if(column.{core::num::==}(usa::Usage::_columnCount.{core::num::-}(1))) {
        this.{usa::Usage::numHelpLines} = this.{usa::Usage::numHelpLines}.{core::num::+}(1);
      }
      else {
        this.{usa::Usage::numHelpLines} = 0;
      }
    }
    method buildAllowedList(opt2::Option option) → core::String {
      dynamic isDefault = option.{opt2::Option::defaultsTo} is core::List<dynamic> ?{dynamic} option.{opt2::Option::defaultsTo}.contains : (dynamic value) → core::bool => value.{core::Object::==}(option.{opt2::Option::defaultsTo});
      core::StringBuffer allowedBuffer = new core::StringBuffer::•();
      allowedBuffer.{core::StringBuffer::write}("[");
      core::bool first = true;
      for (core::String allowed in option.{opt2::Option::allowed}) {
        if(!first)
          allowedBuffer.{core::StringBuffer::write}(", ");
        allowedBuffer.{core::StringBuffer::write}(allowed);
        if(isDefault.call(allowed) as{TypeError} core::bool) {
          allowedBuffer.{core::StringBuffer::write}(" (default)");
        }
        first = false;
      }
      allowedBuffer.{core::StringBuffer::write}("]");
      return allowedBuffer.{core::StringBuffer::toString}();
    }
  }
  static method _isWhitespace(core::String text, core::int index) → core::bool {
    core::int rune = text.{core::String::codeUnitAt}(index);
    return rune.{core::num::>=}(9) && rune.{core::num::<=}(13) || rune.{core::num::==}(32) || rune.{core::num::==}(133) || rune.{core::num::==}(5760) || rune.{core::num::==}(6158) || rune.{core::num::>=}(8192) && rune.{core::num::<=}(8202) || rune.{core::num::==}(8232) || rune.{core::num::==}(8233) || rune.{core::num::==}(8239) || rune.{core::num::==}(8287) || rune.{core::num::==}(12288) || rune.{core::num::==}(65279);
  }
}
library from "package:collection/collection.dart" as col2 {
  export "package:collection/src/algorithms.dart";
  export "package:collection/src/canonicalized_map.dart";
  export "package:collection/src/combined_wrappers/combined_iterable.dart";
  export "package:collection/src/combined_wrappers/combined_list.dart";
  export "package:collection/src/combined_wrappers/combined_map.dart";
  export "package:collection/src/comparators.dart";
  export "package:collection/src/equality.dart";
  export "package:collection/src/equality_map.dart";
  export "package:collection/src/equality_set.dart";
  export "package:collection/src/functions.dart";
  export "package:collection/src/iterable_zip.dart";
  export "package:collection/src/priority_queue.dart";
  export "package:collection/src/queue_list.dart";
  export "package:collection/src/union_set.dart";
  export "package:collection/src/union_set_controller.dart";
  export "package:collection/src/unmodifiable_wrappers.dart";
  export "package:collection/src/wrappers.dart";
}
library charcode from "package:charcode/charcode.dart" as cha4 {
  export "package:charcode/ascii.dart";
  export "package:charcode/html_entity.dart";
}
library Uuid from "package:uuid/uuid.dart" as Uuid {
  import "package:uuid/uuid_util.dart";
  import "package:crypto/crypto.dart";
  import "package:convert/convert.dart" as convert;
  class Uuid extends core::Object {
    static const field core::String NAMESPACE_DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    static const field core::String NAMESPACE_URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    static const field core::String NAMESPACE_OID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
    static const field core::String NAMESPACE_X500 = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";
    static const field core::String NAMESPACE_NIL = "00000000-0000-0000-0000-000000000000";
    field dynamic _seedBytes = null;
    field dynamic _nodeId = null;
    field dynamic _clockSeq = null;
    field core::int _lastMSecs = 0;
    field core::int _lastNSecs = 0;
    field core::List<core::String> _byteToHex = null;
    field core::Map<core::String, core::int> _hexToByte = null;
    constructor •() → void
      : super core::Object::•() {
      this.{Uuid::Uuid::_byteToHex} = core::List::•<core::String>(256);
      this.{Uuid::Uuid::_hexToByte} = new _js::LinkedMap::•<core::String, core::int>();
      for (core::int i = 0; i.{core::num::<}(256); i = i.{core::num::+}(1)) {
        core::List<core::int> hex = core::List::•<core::int>();
        hex.{core::List::add}(i);
        this.{Uuid::Uuid::_byteToHex}.{core::List::[]=}(i, hex::hex.{con2::Codec::encode}(hex));
        this.{Uuid::Uuid::_hexToByte}.{core::Map::[]=}(this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(i), i);
      }
      this.{Uuid::Uuid::_seedBytes} = Uui::UuidUtil::mathRNG();
      this.{Uuid::Uuid::_nodeId} = <dynamic>[this.{Uuid::Uuid::_seedBytes}.[](0).|(1), this.{Uuid::Uuid::_seedBytes}.[](1), this.{Uuid::Uuid::_seedBytes}.[](2), this.{Uuid::Uuid::_seedBytes}.[](3), this.{Uuid::Uuid::_seedBytes}.[](4), this.{Uuid::Uuid::_seedBytes}.[](5)];
      this.{Uuid::Uuid::_clockSeq} = this.{Uuid::Uuid::_seedBytes}.[](6).<<(8).|(this.{Uuid::Uuid::_seedBytes}.[](7)).&(262143);
    }
    method parse(core::String uuid, {core::List<core::int> buffer = null, core::int offset = 0}) → core::List<core::int> {
      core::int i = offset;
      core::int ii = 0;
      buffer = !buffer.{core::Object::==}(null) ?{core::List<core::int>} buffer : core::List::•<core::int>(16);
      final core::RegExp regex = core::RegExp::•("[0-9a-f]{2}");
      for (core::Match match in regex.{core::RegExp::allMatches}(uuid.{core::String::toLowerCase}())) {
        if(ii.{core::num::<}(16)) {
          core::String hex = uuid.{core::String::toLowerCase}().{core::String::substring}(match.{core::Match::start}, match.{core::Match::end});
          buffer.{core::List::[]=}(i.{core::num::+}(let final core::int #t540 = ii in let final core::int #t541 = ii = #t540.{core::num::+}(1) in #t540), this.{Uuid::Uuid::_hexToByte}.{core::Map::[]}(hex));
        }
      }
      while (ii.{core::num::<}(16)) {
        buffer.{core::List::[]=}(i.{core::num::+}(let final core::int #t542 = ii in let final core::int #t543 = ii = #t542.{core::num::+}(1) in #t542), 0);
      }
      return buffer;
    }
    method unparse(core::List<dynamic> buffer, {core::int offset = 0}) → core::String {
      core::int i = offset;
      return "${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t544 = i in let final core::int #t545 = i = #t544.{core::num::+}(1) in #t544) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t546 = i in let final core::int #t547 = i = #t546.{core::num::+}(1) in #t546) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t548 = i in let final core::int #t549 = i = #t548.{core::num::+}(1) in #t548) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t550 = i in let final core::int #t551 = i = #t550.{core::num::+}(1) in #t550) as{TypeError} core::int)}-${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t552 = i in let final core::int #t553 = i = #t552.{core::num::+}(1) in #t552) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t554 = i in let final core::int #t555 = i = #t554.{core::num::+}(1) in #t554) as{TypeError} core::int)}-${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t556 = i in let final core::int #t557 = i = #t556.{core::num::+}(1) in #t556) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t558 = i in let final core::int #t559 = i = #t558.{core::num::+}(1) in #t558) as{TypeError} core::int)}-${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t560 = i in let final core::int #t561 = i = #t560.{core::num::+}(1) in #t560) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t562 = i in let final core::int #t563 = i = #t562.{core::num::+}(1) in #t562) as{TypeError} core::int)}-${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t564 = i in let final core::int #t565 = i = #t564.{core::num::+}(1) in #t564) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t566 = i in let final core::int #t567 = i = #t566.{core::num::+}(1) in #t566) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t568 = i in let final core::int #t569 = i = #t568.{core::num::+}(1) in #t568) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t570 = i in let final core::int #t571 = i = #t570.{core::num::+}(1) in #t570) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t572 = i in let final core::int #t573 = i = #t572.{core::num::+}(1) in #t572) as{TypeError} core::int)}${this.{Uuid::Uuid::_byteToHex}.{core::List::[]}(buffer.{core::List::[]}(let final core::int #t574 = i in let final core::int #t575 = i = #t574.{core::num::+}(1) in #t574) as{TypeError} core::int)}";
    }
    method v1({core::Map<dynamic, dynamic> options = null, core::List<dynamic> buffer = null, core::int offset = 0}) → dynamic {
      core::int i = offset;
      core::List<dynamic> buf = !buffer.{core::Object::==}(null) ?{core::List<dynamic>} buffer : core::List::•<dynamic>(16);
      options = !options.{core::Object::==}(null) ?{core::Map<dynamic, dynamic>} options : new _js::LinkedMap::•<dynamic, dynamic>();
      dynamic clockSeq = !options.{core::Map::[]}("clockSeq").{core::Object::==}(null) ?{dynamic} options.{core::Map::[]}("clockSeq") : this.{Uuid::Uuid::_clockSeq};
      dynamic mSecs = !options.{core::Map::[]}("mSecs").{core::Object::==}(null) ?{dynamic} options.{core::Map::[]}("mSecs") : new core::DateTime::now().{core::DateTime::millisecondsSinceEpoch};
      dynamic nSecs = !options.{core::Map::[]}("nSecs").{core::Object::==}(null) ?{dynamic} options.{core::Map::[]}("nSecs") : this.{Uuid::Uuid::_lastNSecs}.{core::num::+}(1);
      dynamic dt = mSecs.-(this.{Uuid::Uuid::_lastMSecs}).+(nSecs.-(this.{Uuid::Uuid::_lastNSecs})./(10000));
      if(dt.<(0) as{TypeError} core::bool && options.{core::Map::[]}("clockSeq").{core::Object::==}(null)) {
        clockSeq = clockSeq.+(1).&(16383);
      }
      if((dt.<(0) as{TypeError} core::bool || mSecs.>(this.{Uuid::Uuid::_lastMSecs}) as{TypeError} core::bool) && options.{core::Map::[]}("nSecs").{core::Object::==}(null)) {
        nSecs = 0;
      }
      if(nSecs.>=(10000) as{TypeError} core::bool) {
        throw core::Exception::•("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      this.{Uuid::Uuid::_lastMSecs} = mSecs as{TypeError} core::int;
      this.{Uuid::Uuid::_lastNSecs} = nSecs as{TypeError} core::int;
      this.{Uuid::Uuid::_clockSeq} = clockSeq;
      mSecs = mSecs.+(12219292800000);
      dynamic tl = mSecs.&(268435455).*(10000).+(nSecs).%(4294967296);
      buf.{core::List::[]=}(let final core::int #t576 = i in let final core::int #t577 = i = #t576.{core::num::+}(1) in #t576, tl.>>(24).&(255));
      buf.{core::List::[]=}(let final core::int #t578 = i in let final core::int #t579 = i = #t578.{core::num::+}(1) in #t578, tl.>>(16).&(255));
      buf.{core::List::[]=}(let final core::int #t580 = i in let final core::int #t581 = i = #t580.{core::num::+}(1) in #t580, tl.>>(8).&(255));
      buf.{core::List::[]=}(let final core::int #t582 = i in let final core::int #t583 = i = #t582.{core::num::+}(1) in #t582, tl.&(255));
      dynamic tmh = mSecs.~/(4294967296).*(10000).&(268435455);
      buf.{core::List::[]=}(let final core::int #t584 = i in let final core::int #t585 = i = #t584.{core::num::+}(1) in #t584, tmh.>>(8).&(255));
      buf.{core::List::[]=}(let final core::int #t586 = i in let final core::int #t587 = i = #t586.{core::num::+}(1) in #t586, tmh.&(255));
      buf.{core::List::[]=}(let final core::int #t588 = i in let final core::int #t589 = i = #t588.{core::num::+}(1) in #t588, tmh.>>(24).&(15).|(16));
      buf.{core::List::[]=}(let final core::int #t590 = i in let final core::int #t591 = i = #t590.{core::num::+}(1) in #t590, tmh.>>(16).&(255));
      buf.{core::List::[]=}(let final core::int #t592 = i in let final core::int #t593 = i = #t592.{core::num::+}(1) in #t592, clockSeq.>>(8).|(128));
      buf.{core::List::[]=}(let final core::int #t594 = i in let final core::int #t595 = i = #t594.{core::num::+}(1) in #t594, clockSeq.&(255));
      dynamic node = !options.{core::Map::[]}("node").{core::Object::==}(null) ?{dynamic} options.{core::Map::[]}("node") : this.{Uuid::Uuid::_nodeId};
      for (core::int n = 0; n.{core::num::<}(6); n = n.{core::num::+}(1)) {
        buf.{core::List::[]=}(i.{core::num::+}(n), node.[](n));
      }
      return !buffer.{core::Object::==}(null) ?{core::Object} buffer : this.{Uuid::Uuid::unparse}(buf);
    }
    method v4({core::Map<core::String, dynamic> options = null, core::List<dynamic> buffer = null, core::int offset = 0}) → dynamic {
      core::int i = offset;
      options = !options.{core::Object::==}(null) ?{core::Map<core::String, dynamic>} options : new _js::LinkedMap::•<core::String, dynamic>();
      dynamic positionalArgs = !options.{core::Map::[]}("positionalArgs").{core::Object::==}(null) ?{dynamic} options.{core::Map::[]}("positionalArgs") : <dynamic>[];
      core::Map<core::Symbol, dynamic> namedArgs = !options.{core::Map::[]}("namedArgs").{core::Object::==}(null) ?{core::Map<core::Symbol, dynamic>} options.{core::Map::[]}("namedArgs") as core::Map<core::Symbol, dynamic> : const <core::Symbol, dynamic>{};
      dynamic rng = !options.{core::Map::[]}("rng").{core::Object::==}(null) ?{dynamic} core::Function::apply(options.{core::Map::[]}("rng") as{TypeError} core::Function, positionalArgs as{TypeError} core::List<dynamic>, namedArgs) : Uui::UuidUtil::mathRNG();
      dynamic rnds = !options.{core::Map::[]}("random").{core::Object::==}(null) ?{dynamic} options.{core::Map::[]}("random") : rng;
      rnds.[]=(6, rnds.[](6).&(15).|(64));
      rnds.[]=(8, rnds.[](8).&(63).|(128));
      if(!buffer.{core::Object::==}(null)) {
        for (core::int j = 0; j.{core::num::<}(16); j = j.{core::num::+}(1)) {
          buffer.{core::List::[]=}(i.{core::num::+}(j), rnds.[](j));
        }
      }
      return !buffer.{core::Object::==}(null) ?{core::Object} buffer : this.{Uuid::Uuid::unparse}(rnds as{TypeError} core::List<dynamic>);
    }
    method v5(core::String namespace, core::String name, {core::Map<dynamic, dynamic> options = null, core::List<dynamic> buffer = null, core::int offset = 0}) → dynamic {
      core::int i = offset;
      options = !options.{core::Object::==}(null) ?{core::Map<dynamic, dynamic>} options : new _js::LinkedMap::•<dynamic, dynamic>();
      dynamic useRandom = !options.{core::Map::[]}("randomNamespace").{core::Object::==}(null) ?{dynamic} options.{core::Map::[]}("randomNamespace") : true;
      dynamic blankNS = useRandom as{TypeError} core::bool ?{dynamic} this.{Uuid::Uuid::v4}() : Uuid::Uuid::NAMESPACE_NIL;
      namespace = (!namespace.{core::String::==}(null) ?{dynamic} namespace : blankNS) as{TypeError} core::String;
      name = !name.{core::String::==}(null) ?{core::String} name : "";
      core::List<core::int> bytes = this.{Uuid::Uuid::parse}(namespace);
      core::List<core::int> nameBytes = core::List::•<core::int>();
      for (core::int singleChar in name.{core::String::codeUnits}) {
        nameBytes.{core::List::add}(singleChar);
      }
      core::List<dynamic> hashBytes = sha1::sha1.{hash::Hash::convert}(let final core::List<core::int> #t596 = core::List::from<core::int>(bytes) in let final dynamic #t597 = #t596.{core::List::addAll}(nameBytes) in #t596).{dig::Digest::bytes};
      hashBytes.{core::List::[]=}(6, hashBytes.{core::List::[]}(6).&(15).|(80));
      hashBytes.{core::List::[]=}(8, hashBytes.{core::List::[]}(8).&(63).|(128));
      if(!buffer.{core::Object::==}(null)) {
        for (core::int j = 0; j.{core::num::<}(16); j = j.{core::num::+}(1)) {
          buffer.{core::List::[]=}(i.{core::num::+}(j), hashBytes.{core::List::[]}(j));
        }
      }
      return !buffer.{core::Object::==}(null) ?{core::Object} buffer : this.{Uuid::Uuid::unparse}(hashBytes);
    }
  }
}
library from "package:http_parser/src/scan.dart" as scan {
  import "package:string_scanner/string_scanner.dart";
  static final field core::RegExp token = core::RegExp::•("[^()<>@,;:\"\\\\/[\\]?={} \\t\\x00-\\x1F\\x7F]+");
  static final field core::RegExp _lws = core::RegExp::•("(?:\\r\\n)?[ \\t]+");
  static final field core::RegExp _quotedString = core::RegExp::•("\"(?:[^\"\\x00-\\x1F\\x7F]|\\\\.)*\"");
  static final field core::RegExp _quotedPair = core::RegExp::•("\\\\(.)");
  static final field core::RegExp nonToken = core::RegExp::•("[()<>@,;:\"\\\\/\\[\\]?={} \\t\\x00-\\x1F\\x7F]");
  static final field core::RegExp whitespace = core::RegExp::•("(?:${scan::_lws.{core::RegExp::pattern}})*");
  static method parseList<T extends core::Object = dynamic>(str::StringScanner scanner, () → scan::parseList::T parseElement) → core::List<scan::parseList::T> {
    core::List<scan::parseList::T> result = <scan::parseList::T>[];
    while (scanner.{str::StringScanner::scan}(",")) {
      scanner.{str::StringScanner::scan}(scan::whitespace);
    }
    result.{core::List::add}(parseElement.call());
    scanner.{str::StringScanner::scan}(scan::whitespace);
    while (scanner.{str::StringScanner::scan}(","))
      #L65:
      {
        scanner.{str::StringScanner::scan}(scan::whitespace);
        if(scanner.{str::StringScanner::matches}(",") || scanner.{str::StringScanner::isDone})
          break #L65;
        result.{core::List::add}(parseElement.call());
        scanner.{str::StringScanner::scan}(scan::whitespace);
      }
    return result;
  }
  static method expectQuotedString(str::StringScanner scanner, {core::String name = null}) → core::String {
    if(name.{core::String::==}(null))
      name = "quoted string";
    scanner.{str::StringScanner::expect}(scan::_quotedString, name: name);
    core::String string = scanner.{str::StringScanner::lastMatch}.{core::Match::[]}(0);
    return string.{core::String::substring}(1, string.{core::String::length}.{core::num::-}(1)).{core::String::replaceAllMapped}(scan::_quotedPair, (core::Match match) → core::String => match.{core::Match::[]}(1));
  }
}
library from "package:http_parser/src/utils.dart" as uti {
  import "package:source_span/source_span.dart";
  static method wrapFormatException<T extends core::Object = dynamic>(core::String name, core::String value, () → uti::wrapFormatException::T body) → uti::wrapFormatException::T {
    try {
      return body.call();
    }
    on spa3::SourceSpanFormatException catch(final spa3::SourceSpanFormatException error) {
      throw new spa3::SourceSpanFormatException::•("Invalid ${name}: ${error.{spa3::SourceSpanException::message}}", error.{spa3::SourceSpanException::span}, error.{spa3::SourceSpanFormatException::source});
    }
    on core::FormatException catch(final core::FormatException error) {
      throw new core::FormatException::•("Invalid ${name} \"${value}\": ${error.{core::FormatException::message}}", error.{core::FormatException::source}, error.{core::FormatException::offset});
    }
  }
}
library from "package:http_parser/src/chunked_coding/encoder.dart" as enc {
  import "dart:convert";
  import "dart:typed_data";
  import "package:charcode/ascii.dart";
  class ChunkedCodingEncoder extends con2::Converter<core::List<core::int>, core::List<core::int>> {
    const constructor _() → void
      : super con2::Converter::•()
      ;
    method convert(generic-covariant-impl core::List<core::int> bytes) → core::List<core::int>
      return enc::_convert(bytes, 0, bytes.{core::List::length}, isLast: true);
    method startChunkedConversion(generic-covariant-impl core::Sink<core::List<core::int>> sink) → con2::ByteConversionSink
      return new enc::_Sink::•(sink);
  }
  class _Sink extends con2::ByteConversionSinkBase {
    final field core::Sink<core::List<core::int>> _sink;
    constructor •(core::Sink<core::List<core::int>> _sink) → void
      : enc::_Sink::_sink = _sink, super con2::ByteConversionSinkBase::•()
      ;
    method add(generic-covariant-impl core::List<core::int> chunk) → void {
      this.{enc::_Sink::_sink}.{core::Sink::add}(enc::_convert(chunk, 0, chunk.{core::List::length}));
    }
    method addSlice(core::List<core::int> chunk, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, chunk.{core::List::length});
      this.{enc::_Sink::_sink}.{core::Sink::add}(enc::_convert(chunk, start, end, isLast: isLast));
      if(isLast)
        this.{enc::_Sink::_sink}.{core::Sink::close}();
    }
    method close() → void {
      this.{enc::_Sink::_sink}.{core::Sink::add}(enc::_doneChunk);
      this.{enc::_Sink::_sink}.{core::Sink::close}();
    }
  }
  static const field enc::ChunkedCodingEncoder chunkedCodingEncoder = const enc::ChunkedCodingEncoder::_();
  static final field typ2::Uint8List _doneChunk = imp::NativeUint8List::fromList(<core::int>[dol::$0, dol::$cr, dol::$lf, dol::$cr, dol::$lf]);
  static method _convert(core::List<core::int> bytes, core::int start, core::int end, {core::bool isLast = false}) → core::List<core::int> {
    if(end.{core::num::==}(start))
      return isLast ?{core::List<core::int>} enc::_doneChunk : const <core::int>[];
    core::int size = end.{core::num::-}(start);
    core::String sizeInHex = size.{core::int::toRadixString}(16);
    core::int footerSize = isLast ?{core::int} enc::_doneChunk.{core::List::length} : 0;
    typ2::Uint8List list = imp::NativeUint8List::•(sizeInHex.{core::String::length}.{core::num::+}(4).{core::num::+}(size).{core::num::+}(footerSize));
    list.{core::List::setRange}(0, sizeInHex.{core::String::length}, sizeInHex.{core::String::codeUnits});
    core::int cursor = sizeInHex.{core::String::length};
    list.{core::List::[]=}(let final core::int #t598 = cursor in let final core::int #t599 = cursor = #t598.{core::num::+}(1) in #t598, dol::$cr);
    list.{core::List::[]=}(let final core::int #t600 = cursor in let final core::int #t601 = cursor = #t600.{core::num::+}(1) in #t600, dol::$lf);
    list.{core::List::setRange}(cursor, cursor.{core::num::+}(end).{core::num::-}(start), bytes, start);
    cursor = cursor.{core::num::+}(end.{core::num::-}(start));
    list.{core::List::[]=}(let final core::int #t602 = cursor in let final core::int #t603 = cursor = #t602.{core::num::+}(1) in #t602, dol::$cr);
    list.{core::List::[]=}(let final core::int #t604 = cursor in let final core::int #t605 = cursor = #t604.{core::num::+}(1) in #t604, dol::$lf);
    if(isLast) {
      list.{core::List::setRange}(list.{core::List::length}.{core::num::-}(footerSize), list.{core::List::length}, enc::_doneChunk);
    }
    return list;
  }
}
library from "package:http_parser/src/chunked_coding/decoder.dart" as dec {
  import "dart:convert";
  import "dart:math" as math;
  import "dart:typed_data";
  import "package:charcode/ascii.dart";
  import "package:typed_data/typed_data.dart";
  class ChunkedCodingDecoder extends con2::Converter<core::List<core::int>, core::List<core::int>> {
    const constructor _() → void
      : super con2::Converter::•()
      ;
    method convert(generic-covariant-impl core::List<core::int> bytes) → core::List<core::int> {
      dec::_Sink sink = new dec::_Sink::•(null);
      typ2::Uint8List output = sink.{dec::_Sink::_decode}(bytes, 0, bytes.{core::List::length});
      if(sink.{dec::_Sink::_state}.{core::Object::==}(dec::_State::end))
        return output;
      throw new core::FormatException::•("Input ended unexpectedly.", bytes, bytes.{core::List::length});
    }
    method startChunkedConversion(generic-covariant-impl core::Sink<core::List<core::int>> sink) → con2::ByteConversionSink
      return new dec::_Sink::•(sink);
  }
  class _Sink extends con2::ByteConversionSinkBase {
    final field core::Sink<core::List<core::int>> _sink;
    field dec::_State _state = dec::_State::boundary;
    field core::int _size = null;
    constructor •(core::Sink<core::List<core::int>> _sink) → void
      : dec::_Sink::_sink = _sink, super con2::ByteConversionSinkBase::•()
      ;
    method add(generic-covariant-impl core::List<core::int> chunk) → void
      return this.{dec::_Sink::addSlice}(chunk, 0, chunk.{core::List::length}, false);
    method addSlice(core::List<core::int> chunk, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, chunk.{core::List::length});
      typ2::Uint8List output = this.{dec::_Sink::_decode}(chunk, start, end);
      if(output.{core::Iterable::isNotEmpty})
        this.{dec::_Sink::_sink}.{core::Sink::add}(output);
      if(isLast)
        this.{dec::_Sink::_close}(chunk, end);
    }
    method close() → void
      return this.{dec::_Sink::_close}();
    method _close([core::List<core::int> chunk = null, core::int index = null]) → void {
      if(!this.{dec::_Sink::_state}.{core::Object::==}(dec::_State::end)) {
        throw new core::FormatException::•("Input ended unexpectedly.", chunk, index);
      }
      this.{dec::_Sink::_sink}.{core::Sink::close}();
    }
    method _decode(core::List<core::int> bytes, core::int start, core::int end) → typ2::Uint8List {
      function assertCurrentChar(core::int char, core::String name) → core::Null {
        if(!bytes.{core::List::[]}(start).{core::num::==}(char)) {
          throw new core::FormatException::•("Expected ${name}.", bytes, start);
        }
      }
      typ3::Uint8Buffer buffer = new typ3::Uint8Buffer::•();
      while (!start.{core::num::==}(end)) {
        #L66:
        switch(this.{dec::_Sink::_state}) {
          #L67:
          case dec::_State::boundary:
            {
              this.{dec::_Sink::_size} = this.{dec::_Sink::_digitForByte}(bytes, start);
              this.{dec::_Sink::_state} = dec::_State::size;
              start = start.{core::num::+}(1);
              break #L66;
            }
          #L68:
          case dec::_State::size:
            {
              if(bytes.{core::List::[]}(start).{core::num::==}(dol::$cr)) {
                this.{dec::_Sink::_state} = dec::_State::sizeBeforeLF;
              }
              else {
                this.{dec::_Sink::_size} = this.{dec::_Sink::_size}.{core::int::<<}(4).{core::num::+}(this.{dec::_Sink::_digitForByte}(bytes, start));
              }
              start = start.{core::num::+}(1);
              break #L66;
            }
          #L69:
          case dec::_State::sizeBeforeLF:
            {
              assertCurrentChar.call(dol::$lf, "LF");
              this.{dec::_Sink::_state} = this.{dec::_Sink::_size}.{core::num::==}(0) ?{dec::_State} dec::_State::endBeforeCR : dec::_State::body;
              start = start.{core::num::+}(1);
              break #L66;
            }
          #L70:
          case dec::_State::body:
            {
              core::int chunkEnd = math::min<core::int>(end, start.{core::num::+}(this.{dec::_Sink::_size}));
              buffer.{typ3::_TypedDataBuffer::addAll}(bytes, start, chunkEnd);
              this.{dec::_Sink::_size} = this.{dec::_Sink::_size}.{core::num::-}(chunkEnd.{core::num::-}(start));
              start = chunkEnd;
              if(this.{dec::_Sink::_size}.{core::num::==}(0))
                this.{dec::_Sink::_state} = dec::_State::bodyBeforeCR;
              break #L66;
            }
          #L71:
          case dec::_State::bodyBeforeCR:
            {
              assertCurrentChar.call(dol::$cr, "CR");
              this.{dec::_Sink::_state} = dec::_State::bodyBeforeLF;
              start = start.{core::num::+}(1);
              break #L66;
            }
          #L72:
          case dec::_State::bodyBeforeLF:
            {
              assertCurrentChar.call(dol::$lf, "LF");
              this.{dec::_Sink::_state} = dec::_State::boundary;
              start = start.{core::num::+}(1);
              break #L66;
            }
          #L73:
          case dec::_State::endBeforeCR:
            {
              assertCurrentChar.call(dol::$cr, "CR");
              this.{dec::_Sink::_state} = dec::_State::endBeforeLF;
              start = start.{core::num::+}(1);
              break #L66;
            }
          #L74:
          case dec::_State::endBeforeLF:
            {
              assertCurrentChar.call(dol::$lf, "LF");
              this.{dec::_Sink::_state} = dec::_State::end;
              start = start.{core::num::+}(1);
              break #L66;
            }
          #L75:
          case dec::_State::end:
            {
              throw new core::FormatException::•("Expected no more data.", bytes, start);
            }
        }
      }
      return buffer.{typ3::_TypedDataBuffer::buffer}.{typ2::ByteBuffer::asUint8List}(0, buffer.{typ3::_TypedDataBuffer::length});
    }
    method _digitForByte(core::List<core::int> bytes, core::int index) → core::int {
      core::int byte = bytes.{core::List::[]}(index);
      core::int digit = dol::$0.{core::int::^}(byte);
      if(digit.{core::num::<=}(9)) {
        if(digit.{core::num::>=}(0))
          return digit;
      }
      else {
        core::int letter = 32.{core::int::|}(byte);
        if(dol::$a.{core::num::<=}(letter) && letter.{core::num::<=}(dol::$f))
          return letter.{core::num::-}(dol::$a).{core::num::+}(10);
      }
      throw new core::FormatException::•("Invalid hexadecimal byte 0x${byte.{core::int::toRadixString}(16).{core::String::toUpperCase}()}.", bytes, index);
    }
  }
  class _State extends core::Object {
    static const field dec::_State boundary = const dec::_State::_("boundary");
    static const field dec::_State size = const dec::_State::_("size");
    static const field dec::_State sizeBeforeLF = const dec::_State::_("size before LF");
    static const field dec::_State body = const dec::_State::_("body");
    static const field dec::_State bodyBeforeCR = const dec::_State::_("body before CR");
    static const field dec::_State bodyBeforeLF = const dec::_State::_("body before LF");
    static const field dec::_State endBeforeCR = const dec::_State::_("end before CR");
    static const field dec::_State endBeforeLF = const dec::_State::_("end before LF");
    static const field dec::_State end = const dec::_State::_("end");
    final field core::String _name;
    const constructor _(core::String _name) → void
      : dec::_State::_name = _name, super core::Object::•()
      ;
    method toString() → core::String
      return this.{dec::_State::_name};
  }
  static const field dec::ChunkedCodingDecoder chunkedCodingDecoder = const dec::ChunkedCodingDecoder::_();
}
library from "package:path/src/characters.dart" as cha {
  static const field core::int PLUS = 43;
  static const field core::int MINUS = 45;
  static const field core::int PERIOD = 46;
  static const field core::int SLASH = 47;
  static const field core::int ZERO = 48;
  static const field core::int NINE = 57;
  static const field core::int COLON = 58;
  static const field core::int UPPER_A = 65;
  static const field core::int UPPER_Z = 90;
  static const field core::int LOWER_A = 97;
  static const field core::int LOWER_Z = 122;
  static const field core::int BACKSLASH = 92;
}
library from "package:path/src/internal_style.dart" as int {
  import "package:path/src/context.dart";
  import "package:path/src/style.dart";
  abstract class InternalStyle extends sty::Style {
    synthetic constructor •() → void
      : super sty::Style::•()
      ;
    abstract get separator() → core::String;
    abstract method containsSeparator(core::String path) → core::bool;
    abstract method isSeparator(core::int codeUnit) → core::bool;
    abstract method needsSeparator(core::String path) → core::bool;
    abstract method rootLength(core::String path, {core::bool withDrive = false}) → core::int;
    method getRoot(core::String path) → core::String {
      core::int length = this.{int::InternalStyle::rootLength}(path);
      if(length.{core::num::>}(0))
        return path.{core::String::substring}(0, length);
      return this.{int::InternalStyle::isRootRelative}(path) ?{core::String} path.{core::String::[]}(0) : null;
    }
    abstract method isRootRelative(core::String path) → core::bool;
    abstract method pathFromUri(core::Uri uri) → core::String;
    method relativePathToUri(core::String path) → core::Uri {
      core::List<core::String> segments = this.{sty::Style::context}.{con5::Context::split}(path);
      if(this.{int::InternalStyle::isSeparator}(path.{core::String::codeUnitAt}(path.{core::String::length}.{core::num::-}(1))))
        segments.{core::List::add}("");
      return core::_Uri::•(pathSegments: segments);
    }
    abstract method absolutePathToUri(core::String path) → core::Uri;
    method codeUnitsEqual(core::int codeUnit1, core::int codeUnit2) → core::bool
      return codeUnit1.{core::num::==}(codeUnit2);
    method pathsEqual(core::String path1, core::String path2) → core::bool
      return path1.{core::String::==}(path2);
    method canonicalizeCodeUnit(core::int codeUnit) → core::int
      return codeUnit;
    method canonicalizePart(core::String part) → core::String
      return part;
  }
}
library from "package:path/src/parsed_path.dart" as par3 {
  import "package:path/src/internal_style.dart";
  import "package:path/src/style.dart";
  class ParsedPath extends core::Object {
    field int::InternalStyle style;
    field core::String root;
    field core::bool isRootRelative;
    field core::List<core::String> parts;
    field core::List<core::String> separators;
    constructor _(int::InternalStyle style, core::String root, core::bool isRootRelative, core::List<core::String> parts, core::List<core::String> separators) → void
      : par3::ParsedPath::style = style, par3::ParsedPath::root = root, par3::ParsedPath::isRootRelative = isRootRelative, par3::ParsedPath::parts = parts, par3::ParsedPath::separators = separators, super core::Object::•()
      ;
    get extension() → core::String
      return this.{par3::ParsedPath::_splitExtension}().{core::List::[]}(1);
    get isAbsolute() → core::bool
      return !this.{par3::ParsedPath::root}.{core::String::==}(null);
    static factory parse(core::String path, int::InternalStyle style) → par3::ParsedPath {
      core::String root = style.{int::InternalStyle::getRoot}(path);
      core::bool isRootRelative = style.{int::InternalStyle::isRootRelative}(path);
      if(!root.{core::String::==}(null))
        path = path.{core::String::substring}(root.{core::String::length});
      core::List<core::String> parts = <core::String>[];
      core::List<core::String> separators = <core::String>[];
      core::int start = 0;
      if(path.{core::String::isNotEmpty} && style.{int::InternalStyle::isSeparator}(path.{core::String::codeUnitAt}(0))) {
        separators.{core::List::add}(path.{core::String::[]}(0));
        start = 1;
      }
      else {
        separators.{core::List::add}("");
      }
      for (core::int i = start; i.{core::num::<}(path.{core::String::length}); i = i.{core::num::+}(1)) {
        if(style.{int::InternalStyle::isSeparator}(path.{core::String::codeUnitAt}(i))) {
          parts.{core::List::add}(path.{core::String::substring}(start, i));
          separators.{core::List::add}(path.{core::String::[]}(i));
          start = i.{core::num::+}(1);
        }
      }
      if(start.{core::num::<}(path.{core::String::length})) {
        parts.{core::List::add}(path.{core::String::substring}(start));
        separators.{core::List::add}("");
      }
      return new par3::ParsedPath::_(style, root, isRootRelative, parts, separators);
    }
    get basename() → core::String {
      par3::ParsedPath copy = this.{par3::ParsedPath::clone}();
      copy.{par3::ParsedPath::removeTrailingSeparators}();
      if(copy.{par3::ParsedPath::parts}.{core::Iterable::isEmpty})
        return this.{par3::ParsedPath::root}.{core::String::==}(null) ?{core::String} "" : this.{par3::ParsedPath::root};
      return copy.{par3::ParsedPath::parts}.{core::Iterable::last};
    }
    get basenameWithoutExtension() → core::String
      return this.{par3::ParsedPath::_splitExtension}().{core::List::[]}(0);
    get hasTrailingSeparator() → core::bool
      return !this.{par3::ParsedPath::parts}.{core::Iterable::isEmpty} && (this.{par3::ParsedPath::parts}.{core::Iterable::last}.{core::String::==}("") || !this.{par3::ParsedPath::separators}.{core::Iterable::last}.{core::String::==}(""));
    method removeTrailingSeparators() → void {
      while (!this.{par3::ParsedPath::parts}.{core::Iterable::isEmpty} && this.{par3::ParsedPath::parts}.{core::Iterable::last}.{core::String::==}("")) {
        this.{par3::ParsedPath::parts}.{core::List::removeLast}();
        this.{par3::ParsedPath::separators}.{core::List::removeLast}();
      }
      if(this.{par3::ParsedPath::separators}.{core::List::length}.{core::num::>}(0))
        this.{par3::ParsedPath::separators}.{core::List::[]=}(this.{par3::ParsedPath::separators}.{core::List::length}.{core::num::-}(1), "");
    }
    method normalize({core::bool canonicalize = false}) → void {
      core::int leadingDoubles = 0;
      core::List<core::String> newParts = <core::String>[];
      for (core::String part in this.{par3::ParsedPath::parts}) {
        if(part.{core::String::==}(".") || part.{core::String::==}("")) {
        }
        else
          if(part.{core::String::==}("..")) {
            if(newParts.{core::List::length}.{core::num::>}(0)) {
              newParts.{core::List::removeLast}();
            }
            else {
              leadingDoubles = leadingDoubles.{core::num::+}(1);
            }
          }
          else {
            newParts.{core::List::add}(canonicalize ?{core::String} this.{par3::ParsedPath::style}.{int::InternalStyle::canonicalizePart}(part) : part);
          }
      }
      if(!this.{par3::ParsedPath::isAbsolute}) {
        newParts.{core::List::insertAll}(0, core::List::filled<core::String>(leadingDoubles, ".."));
      }
      if(newParts.{core::List::length}.{core::num::==}(0) && !this.{par3::ParsedPath::isAbsolute}) {
        newParts.{core::List::add}(".");
      }
      core::List<core::String> newSeparators = core::List::generate<core::String>(newParts.{core::List::length}, (core::int _) → core::String => this.{par3::ParsedPath::style}.{int::InternalStyle::separator}, growable: true);
      newSeparators.{core::List::insert}(0, this.{par3::ParsedPath::isAbsolute} && newParts.{core::List::length}.{core::num::>}(0) && this.{par3::ParsedPath::style}.{int::InternalStyle::needsSeparator}(this.{par3::ParsedPath::root}) ?{core::String} this.{par3::ParsedPath::style}.{int::InternalStyle::separator} : "");
      this.{par3::ParsedPath::parts} = newParts;
      this.{par3::ParsedPath::separators} = newSeparators;
      if(!this.{par3::ParsedPath::root}.{core::String::==}(null) && this.{par3::ParsedPath::style}.{core::Object::==}(sty::Style::windows)) {
        if(canonicalize)
          this.{par3::ParsedPath::root} = this.{par3::ParsedPath::root}.{core::String::toLowerCase}();
        this.{par3::ParsedPath::root} = this.{par3::ParsedPath::root}.{core::String::replaceAll}("/", "\\");
      }
      this.{par3::ParsedPath::removeTrailingSeparators}();
    }
    method toString() → core::String {
      core::StringBuffer builder = new core::StringBuffer::•();
      if(!this.{par3::ParsedPath::root}.{core::String::==}(null))
        builder.{core::StringBuffer::write}(this.{par3::ParsedPath::root});
      for (core::int i = 0; i.{core::num::<}(this.{par3::ParsedPath::parts}.{core::List::length}); i = i.{core::num::+}(1)) {
        builder.{core::StringBuffer::write}(this.{par3::ParsedPath::separators}.{core::List::[]}(i));
        builder.{core::StringBuffer::write}(this.{par3::ParsedPath::parts}.{core::List::[]}(i));
      }
      builder.{core::StringBuffer::write}(this.{par3::ParsedPath::separators}.{core::Iterable::last});
      return builder.{core::StringBuffer::toString}();
    }
    method _splitExtension() → core::List<core::String> {
      core::String file = this.{par3::ParsedPath::parts}.{core::Iterable::lastWhere}((core::String p) → core::bool => !p.{core::String::==}(""), orElse: () → core::Null => null);
      if(file.{core::String::==}(null))
        return <core::String>["", ""];
      if(file.{core::String::==}(".."))
        return <core::String>["..", ""];
      core::int lastDot = file.{core::String::lastIndexOf}(".");
      if(lastDot.{core::num::<=}(0))
        return <core::String>[file, ""];
      return <core::String>[file.{core::String::substring}(0, lastDot), file.{core::String::substring}(lastDot)];
    }
    method clone() → par3::ParsedPath
      return new par3::ParsedPath::_(this.{par3::ParsedPath::style}, this.{par3::ParsedPath::root}, this.{par3::ParsedPath::isRootRelative}, core::List::from<core::String>(this.{par3::ParsedPath::parts}), core::List::from<core::String>(this.{par3::ParsedPath::separators}));
  }
}
library from "package:path/src/style/posix.dart" as pos {
  import "package:path/src/characters.dart" as chars;
  import "package:path/src/parsed_path.dart";
  import "package:path/src/internal_style.dart";
  class PosixStyle extends int::InternalStyle {
    final field core::String name = "posix";
    final field core::String separator = "/";
    final field core::List<core::String> separators = const <core::String>["/"];
    final field core::Pattern separatorPattern = core::RegExp::•("/");
    final field core::Pattern needsSeparatorPattern = core::RegExp::•("[^/]\$");
    final field core::Pattern rootPattern = core::RegExp::•("^/");
    final field core::Pattern relativeRootPattern = null;
    constructor •() → void
      : super int::InternalStyle::•()
      ;
    method containsSeparator(core::String path) → core::bool
      return path.{core::String::contains}("/");
    method isSeparator(core::int codeUnit) → core::bool
      return codeUnit.{core::num::==}(cha::SLASH);
    method needsSeparator(core::String path) → core::bool
      return path.{core::String::isNotEmpty} && !this.{pos::PosixStyle::isSeparator}(path.{core::String::codeUnitAt}(path.{core::String::length}.{core::num::-}(1)));
    method rootLength(core::String path, {core::bool withDrive = false}) → core::int {
      if(path.{core::String::isNotEmpty} && this.{pos::PosixStyle::isSeparator}(path.{core::String::codeUnitAt}(0)))
        return 1;
      return 0;
    }
    method isRootRelative(core::String path) → core::bool
      return false;
    method getRelativeRoot(core::String path) → core::String
      return null;
    method pathFromUri(core::Uri uri) → core::String {
      if(uri.{core::Uri::scheme}.{core::String::==}("") || uri.{core::Uri::scheme}.{core::String::==}("file")) {
        return core::Uri::decodeComponent(uri.{core::Uri::path});
      }
      throw new core::ArgumentError::•("Uri ${uri} must have scheme 'file:'.");
    }
    method absolutePathToUri(core::String path) → core::Uri {
      par3::ParsedPath parsed = par3::ParsedPath::parse(path, this);
      if(parsed.{par3::ParsedPath::parts}.{core::Iterable::isEmpty}) {
        parsed.{par3::ParsedPath::parts}.{core::List::addAll}(<core::String>["", ""]);
      }
      else
        if(parsed.{par3::ParsedPath::hasTrailingSeparator}) {
          parsed.{par3::ParsedPath::parts}.{core::List::add}("");
        }
      return core::_Uri::•(scheme: "file", pathSegments: parsed.{par3::ParsedPath::parts});
    }
  }
}
library from "package:path/src/style/url.dart" as url {
  import "package:path/src/characters.dart" as chars;
  import "package:path/src/internal_style.dart";
  import "package:path/src/utils.dart";
  class UrlStyle extends int::InternalStyle {
    final field core::String name = "url";
    final field core::String separator = "/";
    final field core::List<core::String> separators = const <core::String>["/"];
    final field core::Pattern separatorPattern = core::RegExp::•("/");
    final field core::Pattern needsSeparatorPattern = core::RegExp::•("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])\$");
    final field core::Pattern rootPattern = core::RegExp::•("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*");
    final field core::Pattern relativeRootPattern = core::RegExp::•("^/");
    constructor •() → void
      : super int::InternalStyle::•()
      ;
    method containsSeparator(core::String path) → core::bool
      return path.{core::String::contains}("/");
    method isSeparator(core::int codeUnit) → core::bool
      return codeUnit.{core::num::==}(cha::SLASH);
    method needsSeparator(core::String path) → core::bool {
      if(path.{core::String::isEmpty})
        return false;
      if(!this.{url::UrlStyle::isSeparator}(path.{core::String::codeUnitAt}(path.{core::String::length}.{core::num::-}(1))))
        return true;
      return path.{core::String::endsWith}("://") && this.{url::UrlStyle::rootLength}(path).{core::num::==}(path.{core::String::length});
    }
    method rootLength(core::String path, {core::bool withDrive = false}) → core::int {
      if(path.{core::String::isEmpty})
        return 0;
      if(this.{url::UrlStyle::isSeparator}(path.{core::String::codeUnitAt}(0)))
        return 1;
      for (core::int i = 0; i.{core::num::<}(path.{core::String::length}); i = i.{core::num::+}(1)) {
        core::int codeUnit = path.{core::String::codeUnitAt}(i);
        if(this.{url::UrlStyle::isSeparator}(codeUnit))
          return 0;
        if(codeUnit.{core::num::==}(cha::COLON)) {
          if(i.{core::num::==}(0))
            return 0;
          if(path.{core::String::startsWith}("//", i.{core::num::+}(1)))
            i = i.{core::num::+}(3);
          core::int index = path.{core::String::indexOf}("/", i);
          if(index.{core::num::<=}(0))
            return path.{core::String::length};
          if(!withDrive || path.{core::String::length}.{core::num::<}(index.{core::num::+}(3)))
            return index;
          if(!path.{core::String::startsWith}("file://"))
            return index;
          if(!uti3::isDriveLetter(path, index.{core::num::+}(1)))
            return index;
          return path.{core::String::length}.{core::num::==}(index.{core::num::+}(3)) ?{core::int} index.{core::num::+}(3) : index.{core::num::+}(4);
        }
      }
      return 0;
    }
    method isRootRelative(core::String path) → core::bool
      return path.{core::String::isNotEmpty} && this.{url::UrlStyle::isSeparator}(path.{core::String::codeUnitAt}(0));
    method getRelativeRoot(core::String path) → core::String
      return this.{url::UrlStyle::isRootRelative}(path) ?{core::String} "/" : null;
    method pathFromUri(core::Uri uri) → core::String
      return uri.{core::Uri::toString}();
    method relativePathToUri(core::String path) → core::Uri
      return core::Uri::parse(path);
    method absolutePathToUri(core::String path) → core::Uri
      return core::Uri::parse(path);
  }
}
library from "package:path/src/style/windows.dart" as win {
  import "package:path/src/characters.dart" as chars;
  import "package:path/src/internal_style.dart";
  import "package:path/src/parsed_path.dart";
  import "package:path/src/utils.dart";
  class WindowsStyle extends int::InternalStyle {
    final field core::String name = "windows";
    final field core::String separator = "\\";
    final field core::List<core::String> separators = const <core::String>["/", "\\"];
    final field core::Pattern separatorPattern = core::RegExp::•("[/\\\\]");
    final field core::Pattern needsSeparatorPattern = core::RegExp::•("[^/\\\\]\$");
    final field core::Pattern rootPattern = core::RegExp::•("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])");
    final field core::Pattern relativeRootPattern = core::RegExp::•("^[/\\\\](?![/\\\\])");
    constructor •() → void
      : super int::InternalStyle::•()
      ;
    method containsSeparator(core::String path) → core::bool
      return path.{core::String::contains}("/");
    method isSeparator(core::int codeUnit) → core::bool
      return codeUnit.{core::num::==}(cha::SLASH) || codeUnit.{core::num::==}(cha::BACKSLASH);
    method needsSeparator(core::String path) → core::bool {
      if(path.{core::String::isEmpty})
        return false;
      return !this.{win::WindowsStyle::isSeparator}(path.{core::String::codeUnitAt}(path.{core::String::length}.{core::num::-}(1)));
    }
    method rootLength(core::String path, {core::bool withDrive = false}) → core::int {
      if(path.{core::String::isEmpty})
        return 0;
      if(path.{core::String::codeUnitAt}(0).{core::num::==}(cha::SLASH))
        return 1;
      if(path.{core::String::codeUnitAt}(0).{core::num::==}(cha::BACKSLASH)) {
        if(path.{core::String::length}.{core::num::<}(2) || !path.{core::String::codeUnitAt}(1).{core::num::==}(cha::BACKSLASH))
          return 1;
        core::int index = path.{core::String::indexOf}("\\", 2);
        if(index.{core::num::>}(0)) {
          index = path.{core::String::indexOf}("\\", index.{core::num::+}(1));
          if(index.{core::num::>}(0))
            return index;
        }
        return path.{core::String::length};
      }
      if(path.{core::String::length}.{core::num::<}(3))
        return 0;
      if(!uti3::isAlphabetic(path.{core::String::codeUnitAt}(0)))
        return 0;
      if(!path.{core::String::codeUnitAt}(1).{core::num::==}(cha::COLON))
        return 0;
      if(!this.{win::WindowsStyle::isSeparator}(path.{core::String::codeUnitAt}(2)))
        return 0;
      return 3;
    }
    method isRootRelative(core::String path) → core::bool
      return this.{win::WindowsStyle::rootLength}(path).{core::num::==}(1);
    method getRelativeRoot(core::String path) → core::String {
      core::int length = this.{win::WindowsStyle::rootLength}(path);
      if(length.{core::num::==}(1))
        return path.{core::String::[]}(0);
      return null;
    }
    method pathFromUri(core::Uri uri) → core::String {
      if(!uri.{core::Uri::scheme}.{core::String::==}("") && !uri.{core::Uri::scheme}.{core::String::==}("file")) {
        throw new core::ArgumentError::•("Uri ${uri} must have scheme 'file:'.");
      }
      core::String path = uri.{core::Uri::path};
      if(uri.{core::Uri::host}.{core::String::==}("")) {
        if(path.{core::String::length}.{core::num::>=}(3) && path.{core::String::startsWith}("/") && uti3::isDriveLetter(path, 1)) {
          path = path.{core::String::replaceFirst}("/", "");
        }
      }
      else {
        path = "\\\\${uri.{core::Uri::host}}${path}";
      }
      return core::Uri::decodeComponent(path.{core::String::replaceAll}("/", "\\"));
    }
    method absolutePathToUri(core::String path) → core::Uri {
      par3::ParsedPath parsed = par3::ParsedPath::parse(path, this);
      if(parsed.{par3::ParsedPath::root}.{core::String::startsWith}("\\\\")) {
        core::Iterable<core::String> rootParts = parsed.{par3::ParsedPath::root}.{core::String::split}("\\").{core::Iterable::where}((core::String part) → core::bool => !part.{core::String::==}(""));
        parsed.{par3::ParsedPath::parts}.{core::List::insert}(0, rootParts.{core::Iterable::last});
        if(parsed.{par3::ParsedPath::hasTrailingSeparator}) {
          parsed.{par3::ParsedPath::parts}.{core::List::add}("");
        }
        return core::_Uri::•(scheme: "file", host: rootParts.{core::Iterable::first}, pathSegments: parsed.{par3::ParsedPath::parts});
      }
      else {
        if(parsed.{par3::ParsedPath::parts}.{core::List::length}.{core::num::==}(0) || parsed.{par3::ParsedPath::hasTrailingSeparator}) {
          parsed.{par3::ParsedPath::parts}.{core::List::add}("");
        }
        parsed.{par3::ParsedPath::parts}.{core::List::insert}(0, parsed.{par3::ParsedPath::root}.{core::String::replaceAll}("/", "").{core::String::replaceAll}("\\", ""));
        return core::_Uri::•(scheme: "file", pathSegments: parsed.{par3::ParsedPath::parts});
      }
    }
    method codeUnitsEqual(core::int codeUnit1, core::int codeUnit2) → core::bool {
      if(codeUnit1.{core::num::==}(codeUnit2))
        return true;
      if(codeUnit1.{core::num::==}(cha::SLASH))
        return codeUnit2.{core::num::==}(cha::BACKSLASH);
      if(codeUnit1.{core::num::==}(cha::BACKSLASH))
        return codeUnit2.{core::num::==}(cha::SLASH);
      if(!codeUnit1.{core::int::^}(codeUnit2).{core::num::==}(win::_asciiCaseBit))
        return false;
      core::int upperCase1 = codeUnit1.{core::int::|}(win::_asciiCaseBit);
      return upperCase1.{core::num::>=}(cha::LOWER_A) && upperCase1.{core::num::<=}(cha::LOWER_Z);
    }
    method pathsEqual(core::String path1, core::String path2) → core::bool {
      if(core::identical(path1, path2))
        return true;
      if(!path1.{core::String::length}.{core::num::==}(path2.{core::String::length}))
        return false;
      for (core::int i = 0; i.{core::num::<}(path1.{core::String::length}); i = i.{core::num::+}(1)) {
        if(!this.{win::WindowsStyle::codeUnitsEqual}(path1.{core::String::codeUnitAt}(i), path2.{core::String::codeUnitAt}(i))) {
          return false;
        }
      }
      return true;
    }
    method canonicalizeCodeUnit(core::int codeUnit) → core::int {
      if(codeUnit.{core::num::==}(cha::SLASH))
        return cha::BACKSLASH;
      if(codeUnit.{core::num::<}(cha::UPPER_A))
        return codeUnit;
      if(codeUnit.{core::num::>}(cha::UPPER_Z))
        return codeUnit;
      return codeUnit.{core::int::|}(win::_asciiCaseBit);
    }
    method canonicalizePart(core::String part) → core::String
      return part.{core::String::toLowerCase}();
  }
  static const field core::int _asciiCaseBit = 32;
}
library from "package:file/src/forwarding/forwarding_directory.dart" as for2 {
  import "dart:async";
  import "package:file/src/io.dart" as io;
  import "package:file/file.dart";
  abstract class ForwardingDirectory<T extends dir::Directory = dir::Directory> extends for3::ForwardingFileSystemEntity<for2::ForwardingDirectory::T, io::Directory> implements dir::Directory {
    synthetic constructor •() → void
      : super for3::ForwardingFileSystemEntity::•()
      ;
    @core::override
    method wrap(generic-covariant-impl io::Directory delegate) → for2::ForwardingDirectory::T
      return this.{for3::ForwardingFileSystemEntity::wrapDirectory}(delegate) as{TypeError} for2::ForwardingDirectory::T;
    @core::override
    method create({core::bool recursive = false}) → asy::Future<dir::Directory> async 
      return this.{for2::ForwardingDirectory::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::Directory::create}(recursive: recursive));
    @core::override
    method createSync({core::bool recursive = false}) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::Directory::createSync}(recursive: recursive);
    @core::override
    method createTemp([core::String prefix = null]) → asy::Future<dir::Directory> async 
      return this.{for2::ForwardingDirectory::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::Directory::createTemp}(prefix));
    @core::override
    method createTempSync([core::String prefix = null]) → dir::Directory
      return this.{for2::ForwardingDirectory::wrap}(this.{for3::ForwardingFileSystemEntity::delegate}.{io::Directory::createTempSync}(prefix));
    @core::override
    method list({core::bool recursive = false, core::bool followLinks = true}) → asy::Stream<fil2::FileSystemEntity>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::Directory::list}(recursive: recursive, followLinks: followLinks).{asy::Stream::map}<fil2::FileSystemEntity>(this.{for2::ForwardingDirectory::_wrap});
    @core::override
    method listSync({core::bool recursive = false, core::bool followLinks = true}) → core::List<fil2::FileSystemEntity>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::Directory::listSync}(recursive: recursive, followLinks: followLinks).{core::Iterable::map}<fil2::FileSystemEntity>(this.{for2::ForwardingDirectory::_wrap}).{core::Iterable::toList}();
    method _wrap(io::FileSystemEntity entity) → fil2::FileSystemEntity {
      if(entity is io::File) {
        return this.{for3::ForwardingFileSystemEntity::wrapFile}(entity{io::File});
      }
      else
        if(entity is io::Directory) {
          return this.{for3::ForwardingFileSystemEntity::wrapDirectory}(entity{io::Directory});
        }
        else
          if(entity is io::Link) {
            return this.{for3::ForwardingFileSystemEntity::wrapLink}(entity{io::Link});
          }
      throw new io::FileSystemException::•("Unsupported type: ${entity}", entity.{io::FileSystemEntity::path});
    }
  }
}
library from "package:file/src/forwarding/forwarding_file.dart" as for4 {
  import "dart:async";
  import "dart:convert";
  import "package:file/src/io.dart" as io;
  import "package:file/file.dart";
  abstract class ForwardingFile extends for3::ForwardingFileSystemEntity<file::File, io::File> implements file::File {
    synthetic constructor •() → void
      : super for3::ForwardingFileSystemEntity::•()
      ;
    @core::override
    method wrap(generic-covariant-impl io::File delegate) → for4::ForwardingFile
      return this.{for3::ForwardingFileSystemEntity::wrapFile}(delegate) as{TypeError} for4::ForwardingFile;
    @core::override
    method create({core::bool recursive = false}) → asy::Future<file::File> async 
      return this.{for4::ForwardingFile::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::create}(recursive: recursive));
    @core::override
    method createSync({core::bool recursive = false}) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::createSync}(recursive: recursive);
    @core::override
    method copy(core::String newPath) → asy::Future<file::File> async 
      return this.{for4::ForwardingFile::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::copy}(newPath));
    @core::override
    method copySync(core::String newPath) → file::File
      return this.{for4::ForwardingFile::wrap}(this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::copySync}(newPath));
    @core::override
    method length() → asy::Future<core::int>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::length}();
    @core::override
    method lengthSync() → core::int
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::lengthSync}();
    @core::override
    method lastAccessed() → asy::Future<core::DateTime>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::lastAccessed}();
    @core::override
    method lastAccessedSync() → core::DateTime
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::lastAccessedSync}();
    @core::override
    method setLastAccessed(core::DateTime time) → asy::Future<dynamic>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::setLastAccessed}(time);
    @core::override
    method setLastAccessedSync(core::DateTime time) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::setLastAccessedSync}(time);
    @core::override
    method lastModified() → asy::Future<core::DateTime>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::lastModified}();
    @core::override
    method lastModifiedSync() → core::DateTime
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::lastModifiedSync}();
    @core::override
    method setLastModified(core::DateTime time) → asy::Future<dynamic>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::setLastModified}(time);
    @core::override
    method setLastModifiedSync(core::DateTime time) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::setLastModifiedSync}(time);
    @core::override
    method open({io::FileMode mode = io::FileMode::read}) → asy::Future<io::RandomAccessFile> async 
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::open}(mode: mode);
    @core::override
    method openSync({io::FileMode mode = io::FileMode::read}) → io::RandomAccessFile
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::openSync}(mode: mode);
    @core::override
    method openRead([core::int start = null, core::int end = null]) → asy::Stream<core::List<core::int>>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::openRead}(start, end);
    @core::override
    method openWrite({io::FileMode mode = io::FileMode::write, con2::Encoding encoding = con2::utf8}) → io::IOSink
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::openWrite}(mode: mode, encoding: encoding);
    @core::override
    method readAsBytes() → asy::Future<core::List<core::int>>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::readAsBytes}();
    @core::override
    method readAsBytesSync() → core::List<core::int>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::readAsBytesSync}();
    @core::override
    method readAsString({con2::Encoding encoding = con2::utf8}) → asy::Future<core::String>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::readAsString}(encoding: encoding);
    @core::override
    method readAsStringSync({con2::Encoding encoding = con2::utf8}) → core::String
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::readAsStringSync}(encoding: encoding);
    @core::override
    method readAsLines({con2::Encoding encoding = con2::utf8}) → asy::Future<core::List<core::String>>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::readAsLines}(encoding: encoding);
    @core::override
    method readAsLinesSync({con2::Encoding encoding = con2::utf8}) → core::List<core::String>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::readAsLinesSync}(encoding: encoding);
    @core::override
    method writeAsBytes(core::List<core::int> bytes, {io::FileMode mode = io::FileMode::write, core::bool flush = false}) → asy::Future<file::File> async 
      return this.{for4::ForwardingFile::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::writeAsBytes}(bytes, mode: mode, flush: flush));
    @core::override
    method writeAsBytesSync(core::List<core::int> bytes, {io::FileMode mode = io::FileMode::write, core::bool flush = false}) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::writeAsBytesSync}(bytes, mode: mode, flush: flush);
    @core::override
    method writeAsString(core::String contents, {io::FileMode mode = io::FileMode::write, con2::Encoding encoding = con2::utf8, core::bool flush = false}) → asy::Future<file::File> async 
      return this.{for4::ForwardingFile::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::writeAsString}(contents, mode: mode, encoding: encoding, flush: flush));
    @core::override
    method writeAsStringSync(core::String contents, {io::FileMode mode = io::FileMode::write, con2::Encoding encoding = con2::utf8, core::bool flush = false}) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::File::writeAsStringSync}(contents, mode: mode, encoding: encoding, flush: flush);
  }
}
library from "package:file/src/forwarding/forwarding_file_system.dart" as for5 {
  import "dart:async";
  import "package:file/src/io.dart" as io;
  import "package:file/file.dart";
  import "package:meta/meta.dart";
  import "package:path/path.dart" as p;
  abstract class ForwardingFileSystem extends fil3::FileSystem {
    @meta::protected
    final field fil3::FileSystem delegate;
    constructor •(fil3::FileSystem delegate) → void
      : for5::ForwardingFileSystem::delegate = delegate, super fil3::FileSystem::•()
      ;
    @core::override
    method directory(dynamic path) → dir::Directory
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::directory}(path);
    @core::override
    method file(dynamic path) → file::File
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::file}(path);
    @core::override
    method link(dynamic path) → link::Link
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::link}(path);
    @core::override
    get path() → con5::Context
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::path};
    @core::override
    get systemTempDirectory() → dir::Directory
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::systemTempDirectory};
    @core::override
    get currentDirectory() → dir::Directory
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::currentDirectory};
    @core::override
    set currentDirectory(dynamic path) → void
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::currentDirectory} = path;
    @core::override
    method stat(core::String path) → asy::Future<io::FileStat>
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::stat}(path);
    @core::override
    method statSync(core::String path) → io::FileStat
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::statSync}(path);
    @core::override
    method identical(core::String path1, core::String path2) → asy::Future<core::bool>
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::identical}(path1, path2);
    @core::override
    method identicalSync(core::String path1, core::String path2) → core::bool
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::identicalSync}(path1, path2);
    @core::override
    get isWatchSupported() → core::bool
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::isWatchSupported};
    @core::override
    method type(core::String path, {core::bool followLinks = true}) → asy::Future<io::FileSystemEntityType>
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::type}(path, followLinks: followLinks);
    @core::override
    method typeSync(core::String path, {core::bool followLinks = true}) → io::FileSystemEntityType
      return this.{for5::ForwardingFileSystem::delegate}.{fil3::FileSystem::typeSync}(path, followLinks: followLinks);
  }
}
library from "package:file/src/forwarding/forwarding_file_system_entity.dart" as for3 {
  import "dart:async";
  import "package:file/src/io.dart" as io;
  import "package:file/file.dart";
  import "package:meta/meta.dart";
  abstract class ForwardingFileSystemEntity<T extends fil2::FileSystemEntity = fil2::FileSystemEntity, D extends io::FileSystemEntity = io::FileSystemEntity> extends core::Object implements fil2::FileSystemEntity {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    @meta::protected
    abstract get delegate() → for3::ForwardingFileSystemEntity::D;
    @meta::protected
    abstract method wrap(generic-covariant-impl for3::ForwardingFileSystemEntity::D delegate) → for3::ForwardingFileSystemEntity::T;
    @meta::protected
    abstract method wrapDirectory(io::Directory delegate) → dir::Directory;
    @meta::protected
    abstract method wrapFile(io::File delegate) → file::File;
    @meta::protected
    abstract method wrapLink(io::Link delegate) → link::Link;
    @core::override
    get uri() → core::Uri
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::uri};
    @core::override
    method exists() → asy::Future<core::bool>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::exists}();
    @core::override
    method existsSync() → core::bool
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::existsSync}();
    @core::override
    method rename(core::String newPath) → asy::Future<for3::ForwardingFileSystemEntity::T> async 
      return this.{for3::ForwardingFileSystemEntity::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::rename}(newPath) as for3::ForwardingFileSystemEntity::D);
    @core::override
    method renameSync(core::String newPath) → for3::ForwardingFileSystemEntity::T
      return this.{for3::ForwardingFileSystemEntity::wrap}(this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::renameSync}(newPath) as for3::ForwardingFileSystemEntity::D);
    @core::override
    method resolveSymbolicLinks() → asy::Future<core::String>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::resolveSymbolicLinks}();
    @core::override
    method resolveSymbolicLinksSync() → core::String
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::resolveSymbolicLinksSync}();
    @core::override
    method stat() → asy::Future<io::FileStat>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::stat}();
    @core::override
    method statSync() → io::FileStat
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::statSync}();
    @core::override
    method delete({core::bool recursive = false}) → asy::Future<for3::ForwardingFileSystemEntity::T> async 
      return this.{for3::ForwardingFileSystemEntity::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::delete}(recursive: recursive) as for3::ForwardingFileSystemEntity::D);
    @core::override
    method deleteSync({core::bool recursive = false}) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::deleteSync}(recursive: recursive);
    @core::override
    method watch({core::int events = io::FileSystemEvent::all, core::bool recursive = false}) → asy::Stream<io::FileSystemEvent>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::watch}(events: events, recursive: recursive);
    @core::override
    get isAbsolute() → core::bool
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::isAbsolute};
    @core::override
    get absolute() → for3::ForwardingFileSystemEntity::T
      return this.{for3::ForwardingFileSystemEntity::wrap}(this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::absolute} as for3::ForwardingFileSystemEntity::D);
    @core::override
    get parent() → dir::Directory
      return this.{for3::ForwardingFileSystemEntity::wrapDirectory}(this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::parent});
    @core::override
    get path() → core::String
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::FileSystemEntity::path};
    @core::override
    get basename() → core::String
      return this.{fil2::FileSystemEntity::fileSystem}.{fil3::FileSystem::path}.{con5::Context::basename}(this.{for3::ForwardingFileSystemEntity::path});
    @core::override
    get dirname() → core::String
      return this.{fil2::FileSystemEntity::fileSystem}.{fil3::FileSystem::path}.{con5::Context::dirname}(this.{for3::ForwardingFileSystemEntity::path});
  }
}
library from "package:file/src/forwarding/forwarding_link.dart" as for6 {
  import "dart:async";
  import "package:file/src/io.dart" as io;
  import "package:file/file.dart";
  abstract class ForwardingLink extends for3::ForwardingFileSystemEntity<link::Link, io::Link> implements link::Link {
    synthetic constructor •() → void
      : super for3::ForwardingFileSystemEntity::•()
      ;
    @core::override
    method wrap(generic-covariant-impl io::Link delegate) → for6::ForwardingLink
      return this.{for3::ForwardingFileSystemEntity::wrapLink}(delegate) as{TypeError} for6::ForwardingLink;
    @core::override
    method create(core::String target, {core::bool recursive = false}) → asy::Future<link::Link> async 
      return this.{for6::ForwardingLink::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::Link::create}(target, recursive: recursive));
    @core::override
    method createSync(core::String target, {core::bool recursive = false}) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::Link::createSync}(target, recursive: recursive);
    @core::override
    method update(core::String target) → asy::Future<link::Link> async 
      return this.{for6::ForwardingLink::wrap}(await this.{for3::ForwardingFileSystemEntity::delegate}.{io::Link::update}(target));
    @core::override
    method updateSync(core::String target) → void
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::Link::updateSync}(target);
    @core::override
    method target() → asy::Future<core::String>
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::Link::target}();
    @core::override
    method targetSync() → core::String
      return this.{for3::ForwardingFileSystemEntity::delegate}.{io::Link::targetSync}();
  }
}
library from "package:file/src/interface/directory.dart" as dir {
  import "dart:async";
  import "package:file/src/interface/file.dart";
  import "package:file/src/interface/file_system_entity.dart";
  import "package:file/src/interface/link.dart";
  import "package:file/src/io.dart" as io;
  abstract class Directory extends core::Object implements fil2::FileSystemEntity, io::Directory {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    @core::override
    abstract method create({core::bool recursive = false}) → asy::Future<dir::Directory>;
    @core::override
    abstract method createTemp([core::String prefix = null]) → asy::Future<dir::Directory>;
    @core::override
    abstract method createTempSync([core::String prefix = null]) → dir::Directory;
    @core::override
    abstract method rename(core::String newPath) → asy::Future<dir::Directory>;
    @core::override
    abstract method renameSync(core::String newPath) → dir::Directory;
    @core::override
    abstract get absolute() → dir::Directory;
    @core::override
    abstract method list({core::bool recursive = false, core::bool followLinks = true}) → asy::Stream<fil2::FileSystemEntity>;
    @core::override
    abstract method listSync({core::bool recursive = false, core::bool followLinks = true}) → core::List<fil2::FileSystemEntity>;
    abstract method childDirectory(core::String basename) → dir::Directory;
    abstract method childFile(core::String basename) → file::File;
    abstract method childLink(core::String basename) → link::Link;
  }
}
library from "package:file/src/interface/error_codes.dart" as err2 {
  import "package:file/src/interface/error_codes_dart_io.dart";
  class ErrorCodes extends core::Object {
    constructor _() → void
      : super core::Object::•()
      ;
    static get E2BIG() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::e2big});
    static get EACCES() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eacces});
    static get EAGAIN() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eagain});
    static get EBADF() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::ebadf});
    static get EBUSY() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::ebusy});
    static get ECHILD() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::echild});
    static get EDEADLK() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::edeadlk});
    static get EDOM() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::edom});
    static get EEXIST() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eexist});
    static get EFAULT() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::efault});
    static get EFBIG() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::efbig});
    static get EILSEQ() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eilseq});
    static get EINTR() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eintr});
    static get EINVAL() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::einval});
    static get EIO() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eio});
    static get EISDIR() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eisdir});
    static get ELOOP() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eloop});
    static get EMFILE() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::emfile});
    static get EMLINK() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::emlink});
    static get ENAMETOOLONG() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enametoolong});
    static get ENFILE() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enfile});
    static get ENODEV() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enodev});
    static get ENOENT() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enoent});
    static get ENOEXEC() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enoexec});
    static get ENOLCK() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enolck});
    static get ENOMEM() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enomem});
    static get ENOSPC() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enospc});
    static get ENOSYS() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enosys});
    static get ENOTDIR() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enotdir});
    static get ENOTEMPTY() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enotempty});
    static get ENOTTY() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enotty});
    static get ENXIO() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::enxio});
    static get EPERM() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::eperm});
    static get EPIPE() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::epipe});
    static get ERANGE() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::erange});
    static get EROFS() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::erofs});
    static get ESPIPE() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::espipe});
    static get ESRCH() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::esrch});
    static get EXDEV() → core::int
      return err2::ErrorCodes::_platform((err2::_Codes codes) → core::int => codes.{err2::_Codes::exdev});
    static method _platform((err2::_Codes) → core::int getCode) → core::int {
      err2::_Codes codes = let final err2::_Codes #t606 = err2::_platforms.{core::Map::[]}(err3::operatingSystem) in #t606.==(null) ?{err2::_Codes} err2::_platforms.{core::Map::[]}("linux") : #t606;
      return getCode.call(codes);
    }
  }
  abstract class _Codes extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get e2big() → core::int;
    abstract get eacces() → core::int;
    abstract get eagain() → core::int;
    abstract get ebadf() → core::int;
    abstract get ebusy() → core::int;
    abstract get echild() → core::int;
    abstract get edeadlk() → core::int;
    abstract get edom() → core::int;
    abstract get eexist() → core::int;
    abstract get efault() → core::int;
    abstract get efbig() → core::int;
    abstract get eilseq() → core::int;
    abstract get eintr() → core::int;
    abstract get einval() → core::int;
    abstract get eio() → core::int;
    abstract get eisdir() → core::int;
    abstract get eloop() → core::int;
    abstract get emfile() → core::int;
    abstract get emlink() → core::int;
    abstract get enametoolong() → core::int;
    abstract get enfile() → core::int;
    abstract get enodev() → core::int;
    abstract get enoent() → core::int;
    abstract get enoexec() → core::int;
    abstract get enolck() → core::int;
    abstract get enomem() → core::int;
    abstract get enospc() → core::int;
    abstract get enosys() → core::int;
    abstract get enotdir() → core::int;
    abstract get enotempty() → core::int;
    abstract get enotty() → core::int;
    abstract get enxio() → core::int;
    abstract get eperm() → core::int;
    abstract get epipe() → core::int;
    abstract get erange() → core::int;
    abstract get erofs() → core::int;
    abstract get espipe() → core::int;
    abstract get esrch() → core::int;
    abstract get exdev() → core::int;
  }
  class _LinuxCodes extends core::Object implements err2::_Codes {
    @core::override
    final field core::int e2big = 7;
    @core::override
    final field core::int eacces = 13;
    @core::override
    final field core::int eagain = 11;
    @core::override
    final field core::int ebadf = 9;
    @core::override
    final field core::int ebusy = 16;
    @core::override
    final field core::int echild = 10;
    @core::override
    final field core::int edeadlk = 35;
    @core::override
    final field core::int edom = 33;
    @core::override
    final field core::int eexist = 17;
    @core::override
    final field core::int efault = 14;
    @core::override
    final field core::int efbig = 27;
    @core::override
    final field core::int eilseq = 84;
    @core::override
    final field core::int eintr = 4;
    @core::override
    final field core::int einval = 22;
    @core::override
    final field core::int eio = 5;
    @core::override
    final field core::int eisdir = 21;
    @core::override
    final field core::int eloop = 40;
    @core::override
    final field core::int emfile = 24;
    @core::override
    final field core::int emlink = 31;
    @core::override
    final field core::int enametoolong = 36;
    @core::override
    final field core::int enfile = 23;
    @core::override
    final field core::int enodev = 19;
    @core::override
    final field core::int enoent = 2;
    @core::override
    final field core::int enoexec = 8;
    @core::override
    final field core::int enolck = 37;
    @core::override
    final field core::int enomem = 12;
    @core::override
    final field core::int enospc = 28;
    @core::override
    final field core::int enosys = 38;
    @core::override
    final field core::int enotdir = 20;
    @core::override
    final field core::int enotempty = 39;
    @core::override
    final field core::int enotty = 25;
    @core::override
    final field core::int enxio = 6;
    @core::override
    final field core::int eperm = 1;
    @core::override
    final field core::int epipe = 32;
    @core::override
    final field core::int erange = 34;
    @core::override
    final field core::int erofs = 30;
    @core::override
    final field core::int espipe = 29;
    @core::override
    final field core::int esrch = 3;
    @core::override
    final field core::int exdev = 18;
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _MacOSCodes extends core::Object implements err2::_Codes {
    @core::override
    final field core::int e2big = 7;
    @core::override
    final field core::int eacces = 13;
    @core::override
    final field core::int eagain = 35;
    @core::override
    final field core::int ebadf = 9;
    @core::override
    final field core::int ebusy = 16;
    @core::override
    final field core::int echild = 10;
    @core::override
    final field core::int edeadlk = 11;
    @core::override
    final field core::int edom = 33;
    @core::override
    final field core::int eexist = 17;
    @core::override
    final field core::int efault = 14;
    @core::override
    final field core::int efbig = 27;
    @core::override
    final field core::int eilseq = 92;
    @core::override
    final field core::int eintr = 4;
    @core::override
    final field core::int einval = 22;
    @core::override
    final field core::int eio = 5;
    @core::override
    final field core::int eisdir = 21;
    @core::override
    final field core::int eloop = 62;
    @core::override
    final field core::int emfile = 24;
    @core::override
    final field core::int emlink = 31;
    @core::override
    final field core::int enametoolong = 63;
    @core::override
    final field core::int enfile = 23;
    @core::override
    final field core::int enodev = 19;
    @core::override
    final field core::int enoent = 2;
    @core::override
    final field core::int enoexec = 8;
    @core::override
    final field core::int enolck = 77;
    @core::override
    final field core::int enomem = 12;
    @core::override
    final field core::int enospc = 28;
    @core::override
    final field core::int enosys = 78;
    @core::override
    final field core::int enotdir = 20;
    @core::override
    final field core::int enotempty = 66;
    @core::override
    final field core::int enotty = 25;
    @core::override
    final field core::int enxio = 6;
    @core::override
    final field core::int eperm = 1;
    @core::override
    final field core::int epipe = 32;
    @core::override
    final field core::int erange = 34;
    @core::override
    final field core::int erofs = 30;
    @core::override
    final field core::int espipe = 29;
    @core::override
    final field core::int esrch = 3;
    @core::override
    final field core::int exdev = 18;
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class _WindowsCodes extends core::Object implements err2::_Codes {
    @core::override
    final field core::int e2big = 7;
    @core::override
    final field core::int eacces = 13;
    @core::override
    final field core::int eagain = 11;
    @core::override
    final field core::int ebadf = 9;
    @core::override
    final field core::int ebusy = 16;
    @core::override
    final field core::int echild = 10;
    @core::override
    final field core::int edeadlk = 36;
    @core::override
    final field core::int edom = 33;
    @core::override
    final field core::int eexist = 17;
    @core::override
    final field core::int efault = 14;
    @core::override
    final field core::int efbig = 27;
    @core::override
    final field core::int eilseq = 42;
    @core::override
    final field core::int eintr = 4;
    @core::override
    final field core::int einval = 22;
    @core::override
    final field core::int eio = 5;
    @core::override
    final field core::int eisdir = 21;
    @core::override
    final field core::int eloop = 1.{core::int::unary-}();
    @core::override
    final field core::int emfile = 24;
    @core::override
    final field core::int emlink = 31;
    @core::override
    final field core::int enametoolong = 38;
    @core::override
    final field core::int enfile = 23;
    @core::override
    final field core::int enodev = 19;
    @core::override
    final field core::int enoent = 2;
    @core::override
    final field core::int enoexec = 8;
    @core::override
    final field core::int enolck = 39;
    @core::override
    final field core::int enomem = 12;
    @core::override
    final field core::int enospc = 28;
    @core::override
    final field core::int enosys = 40;
    @core::override
    final field core::int enotdir = 20;
    @core::override
    final field core::int enotempty = 41;
    @core::override
    final field core::int enotty = 25;
    @core::override
    final field core::int enxio = 6;
    @core::override
    final field core::int eperm = 1;
    @core::override
    final field core::int epipe = 32;
    @core::override
    final field core::int erange = 34;
    @core::override
    final field core::int erofs = 30;
    @core::override
    final field core::int espipe = 29;
    @core::override
    final field core::int esrch = 3;
    @core::override
    final field core::int exdev = 18;
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  static const field core::Map<core::String, err2::_Codes> _platforms = const <core::String, err2::_Codes>{"linux": const err2::_LinuxCodes::•(), "macos": const err2::_MacOSCodes::•(), "windows": const err2::_WindowsCodes::•()};
}
library from "package:file/src/interface/file.dart" as file {
  import "dart:async";
  import "dart:convert";
  import "package:file/src/interface/file_system_entity.dart";
  import "package:file/src/io.dart" as io;
  abstract class File extends core::Object implements fil2::FileSystemEntity, io::File {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    @core::override
    abstract method create({core::bool recursive = false}) → asy::Future<file::File>;
    @core::override
    abstract method rename(core::String newPath) → asy::Future<file::File>;
    @core::override
    abstract method renameSync(core::String newPath) → file::File;
    @core::override
    abstract method copy(core::String newPath) → asy::Future<file::File>;
    @core::override
    abstract method copySync(core::String newPath) → file::File;
    @core::override
    abstract get absolute() → file::File;
    @core::override
    abstract method writeAsBytes(core::List<core::int> bytes, {io::FileMode mode = io::FileMode::write, core::bool flush = false}) → asy::Future<file::File>;
    @core::override
    abstract method writeAsString(core::String contents, {io::FileMode mode = io::FileMode::write, con2::Encoding encoding = con2::utf8, core::bool flush = false}) → asy::Future<file::File>;
  }
}
library from "package:file/src/interface/file_system.dart" as fil3 {
  import "dart:async";
  import "package:meta/meta.dart";
  import "package:path/path.dart" as p;
  import "package:file/src/interface/directory.dart";
  import "package:file/src/interface/file.dart";
  import "package:file/src/interface/file_system_entity.dart";
  import "package:file/src/interface/link.dart";
  import "package:file/src/io.dart" as io;
  abstract class FileSystem extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
    abstract method directory(dynamic path) → dir::Directory;
    abstract method file(dynamic path) → file::File;
    abstract method link(dynamic path) → link::Link;
    abstract get path() → con5::Context;
    abstract get systemTempDirectory() → dir::Directory;
    abstract get currentDirectory() → dir::Directory;
    abstract set currentDirectory(dynamic path) → void;
    abstract method stat(core::String path) → asy::Future<io::FileStat>;
    abstract method statSync(core::String path) → io::FileStat;
    abstract method identical(core::String path1, core::String path2) → asy::Future<core::bool>;
    abstract method identicalSync(core::String path1, core::String path2) → core::bool;
    abstract get isWatchSupported() → core::bool;
    abstract method type(core::String path, {core::bool followLinks = true}) → asy::Future<io::FileSystemEntityType>;
    abstract method typeSync(core::String path, {core::bool followLinks = true}) → io::FileSystemEntityType;
    method isFile(core::String path) → asy::Future<core::bool> async 
      return (await this.{fil3::FileSystem::type}(path)).{core::Object::==}(io::FileSystemEntityType::file);
    method isFileSync(core::String path) → core::bool
      return this.{fil3::FileSystem::typeSync}(path).{core::Object::==}(io::FileSystemEntityType::file);
    method isDirectory(core::String path) → asy::Future<core::bool> async 
      return (await this.{fil3::FileSystem::type}(path)).{core::Object::==}(io::FileSystemEntityType::directory);
    method isDirectorySync(core::String path) → core::bool
      return this.{fil3::FileSystem::typeSync}(path).{core::Object::==}(io::FileSystemEntityType::directory);
    method isLink(core::String path) → asy::Future<core::bool> async 
      return (await this.{fil3::FileSystem::type}(path)).{core::Object::==}(io::FileSystemEntityType::link);
    method isLinkSync(core::String path) → core::bool
      return this.{fil3::FileSystem::typeSync}(path).{core::Object::==}(io::FileSystemEntityType::link);
    @meta::protected
    method getPath(dynamic path) → core::String {
      if(path is io::FileSystemEntity) {
        return path{io::FileSystemEntity}.{io::FileSystemEntity::path};
      }
      else
        if(path is core::String) {
          return path{core::String};
        }
        else
          if(path is core::Uri) {
            return this.{fil3::FileSystem::path}.{con5::Context::fromUri}(path{core::Uri});
          }
          else {
            throw new core::ArgumentError::•("Invalid type for \"path\": ${let final dynamic #t607 = path in #t607.==(null) ?{core::Type} null : #t607.{core::Object::runtimeType}}");
          }
    }
  }
}
library from "package:file/src/interface/file_system_entity.dart" as fil2 {
  import "dart:async";
  import "package:file/src/interface/directory.dart";
  import "package:file/src/interface/file_system.dart";
  import "package:file/src/io.dart" as io;
  abstract class FileSystemEntity extends core::Object implements io::FileSystemEntity {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get fileSystem() → fil3::FileSystem;
    abstract get basename() → core::String;
    abstract get dirname() → core::String;
    @core::override
    abstract method delete({core::bool recursive = false}) → asy::Future<fil2::FileSystemEntity>;
    @core::override
    abstract get parent() → dir::Directory;
  }
}
library from "package:file/src/interface/link.dart" as link {
  import "dart:async";
  import "package:file/src/interface/file_system_entity.dart";
  import "package:file/src/io.dart" as io;
  abstract class Link extends core::Object implements fil2::FileSystemEntity, io::Link {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    @core::override
    abstract method create(core::String target, {core::bool recursive = false}) → asy::Future<link::Link>;
    @core::override
    abstract method update(core::String target) → asy::Future<link::Link>;
    @core::override
    abstract method rename(core::String newPath) → asy::Future<link::Link>;
    @core::override
    abstract method renameSync(core::String newPath) → link::Link;
    @core::override
    abstract get absolute() → link::Link;
  }
}
library from "package:file/src/io.dart" as io3 {
  export "dart:io";
}
library mime.bound_multipart_stream from "package:mime/src/bound_multipart_stream.dart" as bou {
  import "dart:async";
  import "dart:convert";
  import "package:mime/src/char_code.dart";
  import "package:mime/src/mime_shared.dart";
  class _MimeMultipart extends sha::MimeMultipart {
    final field core::Map<core::String, core::String> headers;
    final field asy::Stream<core::List<core::int>> _stream;
    constructor •(core::Map<core::String, core::String> headers, asy::Stream<core::List<core::int>> _stream) → void
      : bou::_MimeMultipart::headers = headers, bou::_MimeMultipart::_stream = _stream, super sha::MimeMultipart::•()
      ;
    method listen((core::List<core::int>) → void onData, {() → void onDone = null, core::Function onError = null, core::bool cancelOnError = null}) → asy::StreamSubscription<core::List<core::int>> {
      return this.{bou::_MimeMultipart::_stream}.{asy::Stream::listen}(onData, onDone: onDone, onError: onError, cancelOnError: cancelOnError);
    }
  }
  class BoundMultipartStream extends core::Object {
    static const field core::int _START = 0;
    static const field core::int _BOUNDARY_ENDING = 1;
    static const field core::int _BOUNDARY_END = 2;
    static const field core::int _HEADER_START = 3;
    static const field core::int _HEADER_FIELD = 4;
    static const field core::int _HEADER_VALUE_START = 5;
    static const field core::int _HEADER_VALUE = 6;
    static const field core::int _HEADER_VALUE_FOLDING_OR_ENDING = 7;
    static const field core::int _HEADER_VALUE_FOLD_OR_END = 8;
    static const field core::int _HEADER_ENDING = 9;
    static const field core::int _CONTENT = 10;
    static const field core::int _LAST_BOUNDARY_DASH2 = 11;
    static const field core::int _LAST_BOUNDARY_ENDING = 12;
    static const field core::int _LAST_BOUNDARY_END = 13;
    static const field core::int _DONE = 14;
    static const field core::int _FAIL = 15;
    final field core::List<core::int> _boundary;
    final field core::List<core::int> _headerField = <core::int>[];
    final field core::List<core::int> _headerValue = <core::int>[];
    static const field core::int _CONTROLLER_STATE_IDLE = 0;
    static const field core::int _CONTROLLER_STATE_ACTIVE = 1;
    static const field core::int _CONTROLLER_STATE_PAUSED = 2;
    static const field core::int _CONTROLLER_STATE_CANCELED = 3;
    field core::int _controllerState = bou::BoundMultipartStream::_CONTROLLER_STATE_IDLE;
    field asy::StreamController<sha::MimeMultipart> _controller = null;
    field asy::StreamSubscription<dynamic> _subscription = null;
    field asy::StreamController<core::List<core::int>> _multipartController = null;
    field core::Map<core::String, core::String> _headers = null;
    field core::int _state = bou::BoundMultipartStream::_START;
    field core::int _boundaryIndex = 2;
    field core::int _index = null;
    field core::List<core::int> _buffer = null;
    constructor •(core::List<core::int> _boundary, asy::Stream<core::List<core::int>> stream) → void
      : bou::BoundMultipartStream::_boundary = _boundary, super core::Object::•() {
      this.{bou::BoundMultipartStream::_controller} = asy::StreamController::•<sha::MimeMultipart>(sync: true, onPause: this.{bou::BoundMultipartStream::_pauseStream}, onResume: this.{bou::BoundMultipartStream::_resumeStream}, onCancel: () → core::Null {
        this.{bou::BoundMultipartStream::_controllerState} = bou::BoundMultipartStream::_CONTROLLER_STATE_CANCELED;
        this.{bou::BoundMultipartStream::_tryPropagateControllerState}();
      }, onListen: () → core::Null {
        this.{bou::BoundMultipartStream::_controllerState} = bou::BoundMultipartStream::_CONTROLLER_STATE_ACTIVE;
        this.{bou::BoundMultipartStream::_subscription} = stream.{asy::Stream::listen}((core::List<core::int> data) → core::Null {
          assert(this.{bou::BoundMultipartStream::_buffer}.{core::Object::==}(null));
          this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::pause}();
          this.{bou::BoundMultipartStream::_buffer} = data;
          this.{bou::BoundMultipartStream::_index} = 0;
          this.{bou::BoundMultipartStream::_parse}();
        }, onDone: () → core::Null {
          if(!this.{bou::BoundMultipartStream::_state}.{core::num::==}(bou::BoundMultipartStream::_DONE)) {
            this.{bou::BoundMultipartStream::_controller}.{asy::StreamController::addError}(new sha::MimeMultipartException::•("Bad multipart ending"));
          }
          this.{bou::BoundMultipartStream::_controller}.{asy::StreamController::close}();
        }, onError: this.{bou::BoundMultipartStream::_controller}.{asy::StreamController::addError});
      });
    }
    get stream() → asy::Stream<sha::MimeMultipart>
      return this.{bou::BoundMultipartStream::_controller}.{asy::StreamController::stream};
    method _resumeStream() → void {
      assert(this.{bou::BoundMultipartStream::_controllerState}.{core::num::==}(bou::BoundMultipartStream::_CONTROLLER_STATE_PAUSED));
      this.{bou::BoundMultipartStream::_controllerState} = bou::BoundMultipartStream::_CONTROLLER_STATE_ACTIVE;
      this.{bou::BoundMultipartStream::_tryPropagateControllerState}();
    }
    method _pauseStream() → void {
      this.{bou::BoundMultipartStream::_controllerState} = bou::BoundMultipartStream::_CONTROLLER_STATE_PAUSED;
      this.{bou::BoundMultipartStream::_tryPropagateControllerState}();
    }
    method _tryPropagateControllerState() → void {
      if(this.{bou::BoundMultipartStream::_multipartController}.{core::Object::==}(null)) {
        #L76:
        switch(this.{bou::BoundMultipartStream::_controllerState}) {
          #L77:
          case bou::BoundMultipartStream::_CONTROLLER_STATE_ACTIVE:
            {
              if(this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::isPaused})
                this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::resume}();
              break #L76;
            }
          #L78:
          case bou::BoundMultipartStream::_CONTROLLER_STATE_PAUSED:
            {
              if(!this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::isPaused})
                this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::pause}();
              break #L76;
            }
          #L79:
          case bou::BoundMultipartStream::_CONTROLLER_STATE_CANCELED:
            {
              this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::cancel}();
              break #L76;
            }
          #L80:
          default:
            {
              throw new core::StateError::•("This code should never be reached.");
            }
        }
      }
    }
    method _parse() → void {
      core::int boundaryPrefix = 0;
      core::int contentStartIndex;
      function reportData() → void {
        if(contentStartIndex.{core::num::<}(0)) {
          core::int contentLength = boundaryPrefix.{core::num::+}(this.{bou::BoundMultipartStream::_index}).{core::num::-}(this.{bou::BoundMultipartStream::_boundaryIndex});
          if(contentLength.{core::num::<=}(boundaryPrefix)) {
            this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::add}(this.{bou::BoundMultipartStream::_boundary}.{core::List::sublist}(0, contentLength));
          }
          else {
            this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::add}(this.{bou::BoundMultipartStream::_boundary}.{core::List::sublist}(0, boundaryPrefix));
            this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::add}(this.{bou::BoundMultipartStream::_buffer}.{core::List::sublist}(0, contentLength.{core::num::-}(boundaryPrefix)));
          }
        }
        else {
          core::int contentEndIndex = this.{bou::BoundMultipartStream::_index}.{core::num::-}(this.{bou::BoundMultipartStream::_boundaryIndex});
          this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::add}(this.{bou::BoundMultipartStream::_buffer}.{core::List::sublist}(contentStartIndex, contentEndIndex));
        }
      }
      if(this.{bou::BoundMultipartStream::_state}.{core::num::==}(bou::BoundMultipartStream::_CONTENT) && this.{bou::BoundMultipartStream::_boundaryIndex}.{core::num::==}(0)) {
        contentStartIndex = 0;
      }
      else {
        contentStartIndex = null;
      }
      boundaryPrefix = this.{bou::BoundMultipartStream::_boundaryIndex};
      while (this.{bou::BoundMultipartStream::_index}.{core::num::<}(this.{bou::BoundMultipartStream::_buffer}.{core::List::length}) && !this.{bou::BoundMultipartStream::_state}.{core::num::==}(bou::BoundMultipartStream::_FAIL) && !this.{bou::BoundMultipartStream::_state}.{core::num::==}(bou::BoundMultipartStream::_DONE)) {
        core::int byte;
        if(this.{bou::BoundMultipartStream::_index}.{core::num::<}(0)) {
          byte = this.{bou::BoundMultipartStream::_boundary}.{core::List::[]}(boundaryPrefix.{core::num::+}(this.{bou::BoundMultipartStream::_index}));
        }
        else {
          byte = this.{bou::BoundMultipartStream::_buffer}.{core::List::[]}(this.{bou::BoundMultipartStream::_index});
        }
        #L81:
        switch(this.{bou::BoundMultipartStream::_state}) {
          #L82:
          case bou::BoundMultipartStream::_START:
            {
              if(byte.{core::num::==}(this.{bou::BoundMultipartStream::_boundary}.{core::List::[]}(this.{bou::BoundMultipartStream::_boundaryIndex}))) {
                this.{bou::BoundMultipartStream::_boundaryIndex} = this.{bou::BoundMultipartStream::_boundaryIndex}.{core::num::+}(1);
                if(this.{bou::BoundMultipartStream::_boundaryIndex}.{core::num::==}(this.{bou::BoundMultipartStream::_boundary}.{core::List::length})) {
                  this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_BOUNDARY_ENDING;
                  this.{bou::BoundMultipartStream::_boundaryIndex} = 0;
                }
              }
              else {
                this.{bou::BoundMultipartStream::_index} = this.{bou::BoundMultipartStream::_index}.{core::num::-}(this.{bou::BoundMultipartStream::_boundaryIndex});
                this.{bou::BoundMultipartStream::_boundaryIndex} = 0;
              }
              break #L81;
            }
          #L83:
          case bou::BoundMultipartStream::_BOUNDARY_ENDING:
            {
              if(byte.{core::num::==}(cha2::CharCode::CR)) {
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_BOUNDARY_END;
              }
              else
                if(byte.{core::num::==}(cha2::CharCode::DASH)) {
                  this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_LAST_BOUNDARY_DASH2;
                }
                else {
                  bou::_expectWhitespace(byte);
                }
              break #L81;
            }
          #L84:
          case bou::BoundMultipartStream::_BOUNDARY_END:
            {
              bou::_expectByteValue(byte, cha2::CharCode::LF);
              if(!this.{bou::BoundMultipartStream::_multipartController}.{core::Object::==}(null)) {
                this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::close}();
                this.{bou::BoundMultipartStream::_multipartController} = null;
                this.{bou::BoundMultipartStream::_tryPropagateControllerState}();
              }
              this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_START;
              break #L81;
            }
          #L85:
          case bou::BoundMultipartStream::_HEADER_START:
            {
              this.{bou::BoundMultipartStream::_headers} = new _js::LinkedMap::•<core::String, core::String>();
              if(byte.{core::num::==}(cha2::CharCode::CR)) {
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_ENDING;
              }
              else {
                this.{bou::BoundMultipartStream::_headerField}.{core::List::add}(bou::_toLowerCase(byte));
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_FIELD;
              }
              break #L81;
            }
          #L86:
          case bou::BoundMultipartStream::_HEADER_FIELD:
            {
              if(byte.{core::num::==}(cha2::CharCode::COLON)) {
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_VALUE_START;
              }
              else {
                if(!bou::_isTokenChar(byte)) {
                  throw new sha::MimeMultipartException::•("Invalid header field name");
                }
                this.{bou::BoundMultipartStream::_headerField}.{core::List::add}(bou::_toLowerCase(byte));
              }
              break #L81;
            }
          #L87:
          case bou::BoundMultipartStream::_HEADER_VALUE_START:
            {
              if(byte.{core::num::==}(cha2::CharCode::CR)) {
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_VALUE_FOLDING_OR_ENDING;
              }
              else
                if(!byte.{core::num::==}(cha2::CharCode::SP) && !byte.{core::num::==}(cha2::CharCode::HT)) {
                  this.{bou::BoundMultipartStream::_headerValue}.{core::List::add}(byte);
                  this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_VALUE;
                }
              break #L81;
            }
          #L88:
          case bou::BoundMultipartStream::_HEADER_VALUE:
            {
              if(byte.{core::num::==}(cha2::CharCode::CR)) {
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_VALUE_FOLDING_OR_ENDING;
              }
              else {
                this.{bou::BoundMultipartStream::_headerValue}.{core::List::add}(byte);
              }
              break #L81;
            }
          #L89:
          case bou::BoundMultipartStream::_HEADER_VALUE_FOLDING_OR_ENDING:
            {
              bou::_expectByteValue(byte, cha2::CharCode::LF);
              this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_VALUE_FOLD_OR_END;
              break #L81;
            }
          #L90:
          case bou::BoundMultipartStream::_HEADER_VALUE_FOLD_OR_END:
            {
              if(byte.{core::num::==}(cha2::CharCode::SP) || byte.{core::num::==}(cha2::CharCode::HT)) {
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_VALUE_START;
              }
              else {
                core::String headerField = con2::utf8.{con2::Utf8Codec::decode}(this.{bou::BoundMultipartStream::_headerField});
                core::String headerValue = con2::utf8.{con2::Utf8Codec::decode}(this.{bou::BoundMultipartStream::_headerValue});
                this.{bou::BoundMultipartStream::_headers}.{core::Map::[]=}(headerField.{core::String::toLowerCase}(), headerValue);
                this.{bou::BoundMultipartStream::_headerField}.{core::List::clear}();
                this.{bou::BoundMultipartStream::_headerValue}.{core::List::clear}();
                if(byte.{core::num::==}(cha2::CharCode::CR)) {
                  this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_ENDING;
                }
                else {
                  this.{bou::BoundMultipartStream::_headerField}.{core::List::add}(bou::_toLowerCase(byte));
                  this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_HEADER_FIELD;
                }
              }
              break #L81;
            }
          #L91:
          case bou::BoundMultipartStream::_HEADER_ENDING:
            {
              bou::_expectByteValue(byte, cha2::CharCode::LF);
              this.{bou::BoundMultipartStream::_multipartController} = asy::StreamController::•<core::List<core::int>>(sync: true, onListen: () → core::Null {
                if(this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::isPaused})
                  this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::resume}();
              }, onPause: this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::pause}, onResume: this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::resume});
              this.{bou::BoundMultipartStream::_controller}.{asy::StreamController::add}(new bou::_MimeMultipart::•(this.{bou::BoundMultipartStream::_headers}, this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::stream}));
              this.{bou::BoundMultipartStream::_headers} = null;
              this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_CONTENT;
              contentStartIndex = this.{bou::BoundMultipartStream::_index}.{core::num::+}(1);
              break #L81;
            }
          #L92:
          case bou::BoundMultipartStream::_CONTENT:
            {
              if(byte.{core::num::==}(this.{bou::BoundMultipartStream::_boundary}.{core::List::[]}(this.{bou::BoundMultipartStream::_boundaryIndex}))) {
                this.{bou::BoundMultipartStream::_boundaryIndex} = this.{bou::BoundMultipartStream::_boundaryIndex}.{core::num::+}(1);
                if(this.{bou::BoundMultipartStream::_boundaryIndex}.{core::num::==}(this.{bou::BoundMultipartStream::_boundary}.{core::List::length})) {
                  if(!contentStartIndex.{core::num::==}(null)) {
                    this.{bou::BoundMultipartStream::_index} = this.{bou::BoundMultipartStream::_index}.{core::num::+}(1);
                    reportData.call();
                    this.{bou::BoundMultipartStream::_index} = this.{bou::BoundMultipartStream::_index}.{core::num::-}(1);
                  }
                  this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::close}();
                  this.{bou::BoundMultipartStream::_multipartController} = null;
                  this.{bou::BoundMultipartStream::_tryPropagateControllerState}();
                  this.{bou::BoundMultipartStream::_boundaryIndex} = 0;
                  this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_BOUNDARY_ENDING;
                }
              }
              else {
                this.{bou::BoundMultipartStream::_index} = this.{bou::BoundMultipartStream::_index}.{core::num::-}(this.{bou::BoundMultipartStream::_boundaryIndex});
                if(contentStartIndex.{core::num::==}(null))
                  contentStartIndex = this.{bou::BoundMultipartStream::_index};
                this.{bou::BoundMultipartStream::_boundaryIndex} = 0;
              }
              break #L81;
            }
          #L93:
          case bou::BoundMultipartStream::_LAST_BOUNDARY_DASH2:
            {
              bou::_expectByteValue(byte, cha2::CharCode::DASH);
              this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_LAST_BOUNDARY_ENDING;
              break #L81;
            }
          #L94:
          case bou::BoundMultipartStream::_LAST_BOUNDARY_ENDING:
            {
              if(byte.{core::num::==}(cha2::CharCode::CR)) {
                this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_LAST_BOUNDARY_END;
              }
              else {
                bou::_expectWhitespace(byte);
              }
              break #L81;
            }
          #L95:
          case bou::BoundMultipartStream::_LAST_BOUNDARY_END:
            {
              bou::_expectByteValue(byte, cha2::CharCode::LF);
              if(!this.{bou::BoundMultipartStream::_multipartController}.{core::Object::==}(null)) {
                this.{bou::BoundMultipartStream::_multipartController}.{asy::StreamController::close}();
                this.{bou::BoundMultipartStream::_multipartController} = null;
                this.{bou::BoundMultipartStream::_tryPropagateControllerState}();
              }
              this.{bou::BoundMultipartStream::_state} = bou::BoundMultipartStream::_DONE;
              break #L81;
            }
          #L96:
          default:
            {
              assert(false);
              break #L81;
            }
        }
        this.{bou::BoundMultipartStream::_index} = this.{bou::BoundMultipartStream::_index}.{core::num::+}(1);
      }
      if(this.{bou::BoundMultipartStream::_state}.{core::num::==}(bou::BoundMultipartStream::_CONTENT) && !contentStartIndex.{core::num::==}(null)) {
        reportData.call();
      }
      if(this.{bou::BoundMultipartStream::_index}.{core::num::==}(this.{bou::BoundMultipartStream::_buffer}.{core::List::length})) {
        this.{bou::BoundMultipartStream::_buffer} = null;
        this.{bou::BoundMultipartStream::_index} = null;
        this.{bou::BoundMultipartStream::_subscription}.{asy::StreamSubscription::resume}();
      }
    }
  }
  static const field core::List<core::int> _SEPARATORS = const <core::int>[40, 41, 60, 62, 64, 44, 59, 58, 92, 34, 47, 91, 93, 63, 61, 123, 125, 32, 9];
  static method _isTokenChar(core::int byte) → core::bool {
    return byte.{core::num::>}(31) && byte.{core::num::<}(128) && bou::_SEPARATORS.{core::List::indexOf}(byte).{core::num::==}(1.{core::int::unary-}());
  }
  static method _toLowerCase(core::int byte) → core::int {
    const core::int delta = cha2::CharCode::LOWER_A.{core::num::-}(cha2::CharCode::UPPER_A);
    return cha2::CharCode::UPPER_A.{core::num::<=}(byte) && byte.{core::num::<=}(cha2::CharCode::UPPER_Z) ?{core::int} byte.{core::num::+}(delta) : byte;
  }
  static method _expectByteValue(core::int val1, core::int val2) → void {
    if(!val1.{core::num::==}(val2)) {
      throw new sha::MimeMultipartException::•("Failed to parse multipart mime 1");
    }
  }
  static method _expectWhitespace(core::int byte) → void {
    if(!byte.{core::num::==}(cha2::CharCode::SP) && !byte.{core::num::==}(cha2::CharCode::HT)) {
      throw new sha::MimeMultipartException::•("Failed to parse multipart mime 2");
    }
  }
}
library mime.char_code from "package:mime/src/char_code.dart" as cha2 {
  class CharCode extends core::Object {
    static const field core::int HT = 9;
    static const field core::int LF = 10;
    static const field core::int CR = 13;
    static const field core::int SP = 32;
    static const field core::int DASH = 45;
    static const field core::int COLON = 58;
    static const field core::int UPPER_A = 65;
    static const field core::int UPPER_Z = 90;
    static const field core::int LOWER_A = 97;
    synthetic constructor •() → void
      : super core::Object::•()
      ;
  }
}
library mime.extension_map from "package:mime/src/default_extension_map.dart" as ext {
  static final field core::Map<core::String, core::String> defaultExtensionMap = <core::String, core::String>{"123": "application/vnd.lotus-1-2-3", "3dml": "text/vnd.in3d.3dml", "3ds": "image/x-3ds", "3g2": "video/3gpp2", "3gp": "video/3gpp", "7z": "application/x-7z-compressed", "aab": "application/x-authorware-bin", "aac": "audio/x-aac", "aam": "application/x-authorware-map", "aas": "application/x-authorware-seg", "abw": "application/x-abiword", "ac": "application/pkix-attr-cert", "acc": "application/vnd.americandynamics.acc", "ace": "application/x-ace-compressed", "acu": "application/vnd.acucobol", "acutc": "application/vnd.acucorp", "adp": "audio/adpcm", "aep": "application/vnd.audiograph", "afm": "application/x-font-type1", "afp": "application/vnd.ibm.modcap", "ahead": "application/vnd.ahead.space", "ai": "application/postscript", "aif": "audio/x-aiff", "aifc": "audio/x-aiff", "aiff": "audio/x-aiff", "air": "application/vnd.adobe.air-application-installer-package+zip", "ait": "application/vnd.dvb.ait", "ami": "application/vnd.amiga.ami", "apk": "application/vnd.android.package-archive", "appcache": "text/cache-manifest", "application": "application/x-ms-application", "apr": "application/vnd.lotus-approach", "arc": "application/x-freearc", "asc": "application/pgp-signature", "asf": "video/x-ms-asf", "asm": "text/x-asm", "aso": "application/vnd.accpac.simply.aso", "asx": "video/x-ms-asf", "atc": "application/vnd.acucorp", "atom": "application/atom+xml", "atomcat": "application/atomcat+xml", "atomsvc": "application/atomsvc+xml", "atx": "application/vnd.antix.game-component", "au": "audio/basic", "avi": "video/x-msvideo", "aw": "application/applixware", "azf": "application/vnd.airzip.filesecure.azf", "azs": "application/vnd.airzip.filesecure.azs", "azw": "application/vnd.amazon.ebook", "bat": "application/x-msdownload", "bcpio": "application/x-bcpio", "bdf": "application/x-font-bdf", "bdm": "application/vnd.syncml.dm+wbxml", "bed": "application/vnd.realvnc.bed", "bh2": "application/vnd.fujitsu.oasysprs", "bin": "application/octet-stream", "blb": "application/x-blorb", "blorb": "application/x-blorb", "bmi": "application/vnd.bmi", "bmp": "image/bmp", "book": "application/vnd.framemaker", "box": "application/vnd.previewsystems.box", "boz": "application/x-bzip2", "bpk": "application/octet-stream", "btif": "image/prs.btif", "bz": "application/x-bzip", "bz2": "application/x-bzip2", "c": "text/x-c", "c11amc": "application/vnd.cluetrust.cartomobile-config", "c11amz": "application/vnd.cluetrust.cartomobile-config-pkg", "c4d": "application/vnd.clonk.c4group", "c4f": "application/vnd.clonk.c4group", "c4g": "application/vnd.clonk.c4group", "c4p": "application/vnd.clonk.c4group", "c4u": "application/vnd.clonk.c4group", "cab": "application/vnd.ms-cab-compressed", "caf": "audio/x-caf", "cap": "application/vnd.tcpdump.pcap", "car": "application/vnd.curl.car", "cat": "application/vnd.ms-pki.seccat", "cb7": "application/x-cbr", "cba": "application/x-cbr", "cbr": "application/x-cbr", "cbt": "application/x-cbr", "cbz": "application/x-cbr", "cc": "text/x-c", "cct": "application/x-director", "ccxml": "application/ccxml+xml", "cdbcmsg": "application/vnd.contact.cmsg", "cdf": "application/x-netcdf", "cdkey": "application/vnd.mediastation.cdkey", "cdmia": "application/cdmi-capability", "cdmic": "application/cdmi-container", "cdmid": "application/cdmi-domain", "cdmio": "application/cdmi-object", "cdmiq": "application/cdmi-queue", "cdx": "chemical/x-cdx", "cdxml": "application/vnd.chemdraw+xml", "cdy": "application/vnd.cinderella", "cer": "application/pkix-cert", "cfs": "application/x-cfs-compressed", "cgm": "image/cgm", "chat": "application/x-chat", "chm": "application/vnd.ms-htmlhelp", "chrt": "application/vnd.kde.kchart", "cif": "chemical/x-cif", "cii": "application/vnd.anser-web-certificate-issue-initiation", "cil": "application/vnd.ms-artgalry", "cla": "application/vnd.claymore", "class": "application/java-vm", "clkk": "application/vnd.crick.clicker.keyboard", "clkp": "application/vnd.crick.clicker.palette", "clkt": "application/vnd.crick.clicker.template", "clkw": "application/vnd.crick.clicker.wordbank", "clkx": "application/vnd.crick.clicker", "clp": "application/x-msclip", "cmc": "application/vnd.cosmocaller", "cmdf": "chemical/x-cmdf", "cml": "chemical/x-cml", "cmp": "application/vnd.yellowriver-custom-menu", "cmx": "image/x-cmx", "cod": "application/vnd.rim.cod", "com": "application/x-msdownload", "conf": "text/plain", "cpio": "application/x-cpio", "cpp": "text/x-c", "cpt": "application/mac-compactpro", "crd": "application/x-mscardfile", "crl": "application/pkix-crl", "crt": "application/x-x509-ca-cert", "cryptonote": "application/vnd.rig.cryptonote", "csh": "application/x-csh", "csml": "chemical/x-csml", "csp": "application/vnd.commonspace", "css": "text/css", "cst": "application/x-director", "csv": "text/csv", "cu": "application/cu-seeme", "curl": "text/vnd.curl", "cww": "application/prs.cww", "cxt": "application/x-director", "cxx": "text/x-c", "dae": "model/vnd.collada+xml", "daf": "application/vnd.mobius.daf", "dart": "application/dart", "dataless": "application/vnd.fdsn.seed", "davmount": "application/davmount+xml", "dbk": "application/docbook+xml", "dcr": "application/x-director", "dcurl": "text/vnd.curl.dcurl", "dd2": "application/vnd.oma.dd2+xml", "ddd": "application/vnd.fujixerox.ddd", "deb": "application/x-debian-package", "def": "text/plain", "deploy": "application/octet-stream", "der": "application/x-x509-ca-cert", "dfac": "application/vnd.dreamfactory", "dgc": "application/x-dgc-compressed", "dic": "text/x-c", "dir": "application/x-director", "dis": "application/vnd.mobius.dis", "dist": "application/octet-stream", "distz": "application/octet-stream", "djv": "image/vnd.djvu", "djvu": "image/vnd.djvu", "dll": "application/x-msdownload", "dmg": "application/x-apple-diskimage", "dmp": "application/vnd.tcpdump.pcap", "dms": "application/octet-stream", "dna": "application/vnd.dna", "doc": "application/msword", "docm": "application/vnd.ms-word.document.macroenabled.12", "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "dot": "application/msword", "dotm": "application/vnd.ms-word.template.macroenabled.12", "dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template", "dp": "application/vnd.osgi.dp", "dpg": "application/vnd.dpgraph", "dra": "audio/vnd.dra", "dsc": "text/prs.lines.tag", "dssc": "application/dssc+der", "dtb": "application/x-dtbook+xml", "dtd": "application/xml-dtd", "dts": "audio/vnd.dts", "dtshd": "audio/vnd.dts.hd", "dump": "application/octet-stream", "dvb": "video/vnd.dvb.file", "dvi": "application/x-dvi", "dwf": "model/vnd.dwf", "dwg": "image/vnd.dwg", "dxf": "image/vnd.dxf", "dxp": "application/vnd.spotfire.dxp", "dxr": "application/x-director", "ecelp4800": "audio/vnd.nuera.ecelp4800", "ecelp7470": "audio/vnd.nuera.ecelp7470", "ecelp9600": "audio/vnd.nuera.ecelp9600", "ecma": "application/ecmascript", "edm": "application/vnd.novadigm.edm", "edx": "application/vnd.novadigm.edx", "efif": "application/vnd.picsel", "ei6": "application/vnd.pg.osasli", "elc": "application/octet-stream", "emf": "application/x-msmetafile", "eml": "message/rfc822", "emma": "application/emma+xml", "emz": "application/x-msmetafile", "eol": "audio/vnd.digital-winds", "eot": "application/vnd.ms-fontobject", "eps": "application/postscript", "epub": "application/epub+zip", "es3": "application/vnd.eszigno3+xml", "esa": "application/vnd.osgi.subsystem", "esf": "application/vnd.epson.esf", "et3": "application/vnd.eszigno3+xml", "etx": "text/x-setext", "eva": "application/x-eva", "evy": "application/x-envoy", "exe": "application/x-msdownload", "exi": "application/exi", "ext": "application/vnd.novadigm.ext", "ez": "application/andrew-inset", "ez2": "application/vnd.ezpix-album", "ez3": "application/vnd.ezpix-package", "f": "text/x-fortran", "f4v": "video/x-f4v", "f77": "text/x-fortran", "f90": "text/x-fortran", "fbs": "image/vnd.fastbidsheet", "fcdt": "application/vnd.adobe.formscentral.fcdt", "fcs": "application/vnd.isac.fcs", "fdf": "application/vnd.fdf", "fe_launch": "application/vnd.denovo.fcselayout-link", "fg5": "application/vnd.fujitsu.oasysgp", "fgd": "application/x-director", "fh": "image/x-freehand", "fh4": "image/x-freehand", "fh5": "image/x-freehand", "fh7": "image/x-freehand", "fhc": "image/x-freehand", "fig": "application/x-xfig", "flac": "audio/x-flac", "fli": "video/x-fli", "flo": "application/vnd.micrografx.flo", "flv": "video/x-flv", "flw": "application/vnd.kde.kivio", "flx": "text/vnd.fmi.flexstor", "fly": "text/vnd.fly", "fm": "application/vnd.framemaker", "fnc": "application/vnd.frogans.fnc", "for": "text/x-fortran", "fpx": "image/vnd.fpx", "frame": "application/vnd.framemaker", "fsc": "application/vnd.fsc.weblaunch", "fst": "image/vnd.fst", "ftc": "application/vnd.fluxtime.clip", "fti": "application/vnd.anser-web-funds-transfer-initiation", "fvt": "video/vnd.fvt", "fxp": "application/vnd.adobe.fxp", "fxpl": "application/vnd.adobe.fxp", "fzs": "application/vnd.fuzzysheet", "g2w": "application/vnd.geoplan", "g3": "image/g3fax", "g3w": "application/vnd.geospace", "gac": "application/vnd.groove-account", "gam": "application/x-tads", "gbr": "application/rpki-ghostbusters", "gca": "application/x-gca-compressed", "gdl": "model/vnd.gdl", "geo": "application/vnd.dynageo", "gex": "application/vnd.geometry-explorer", "ggb": "application/vnd.geogebra.file", "ggt": "application/vnd.geogebra.tool", "ghf": "application/vnd.groove-help", "gif": "image/gif", "gim": "application/vnd.groove-identity-message", "glb": "model/gltf-binary", "gltf": "model/gltf+json", "gml": "application/gml+xml", "gmx": "application/vnd.gmx", "gnumeric": "application/x-gnumeric", "gph": "application/vnd.flographit", "gpx": "application/gpx+xml", "gqf": "application/vnd.grafeq", "gqs": "application/vnd.grafeq", "gram": "application/srgs", "gramps": "application/x-gramps-xml", "gre": "application/vnd.geometry-explorer", "grv": "application/vnd.groove-injector", "grxml": "application/srgs+xml", "gsf": "application/x-font-ghostscript", "gtar": "application/x-gtar", "gtm": "application/vnd.groove-tool-message", "gtw": "model/vnd.gtw", "gv": "text/vnd.graphviz", "gxf": "application/gxf", "gxt": "application/vnd.geonext", "h": "text/x-c", "h261": "video/h261", "h263": "video/h263", "h264": "video/h264", "hal": "application/vnd.hal+xml", "hbci": "application/vnd.hbci", "hdf": "application/x-hdf", "hh": "text/x-c", "hlp": "application/winhlp", "hpgl": "application/vnd.hp-hpgl", "hpid": "application/vnd.hp-hpid", "hps": "application/vnd.hp-hps", "hqx": "application/mac-binhex40", "htke": "application/vnd.kenameaapp", "htm": "text/html", "html": "text/html", "hvd": "application/vnd.yamaha.hv-dic", "hvp": "application/vnd.yamaha.hv-voice", "hvs": "application/vnd.yamaha.hv-script", "i2g": "application/vnd.intergeo", "icc": "application/vnd.iccprofile", "ice": "x-conference/x-cooltalk", "icm": "application/vnd.iccprofile", "ico": "image/x-icon", "ics": "text/calendar", "ief": "image/ief", "ifb": "text/calendar", "ifm": "application/vnd.shana.informed.formdata", "iges": "model/iges", "igl": "application/vnd.igloader", "igm": "application/vnd.insors.igm", "igs": "model/iges", "igx": "application/vnd.micrografx.igx", "iif": "application/vnd.shana.informed.interchange", "imp": "application/vnd.accpac.simply.imp", "ims": "application/vnd.ms-ims", "in": "text/plain", "ink": "application/inkml+xml", "inkml": "application/inkml+xml", "install": "application/x-install-instructions", "iota": "application/vnd.astraea-software.iota", "ipfix": "application/ipfix", "ipk": "application/vnd.shana.informed.package", "irm": "application/vnd.ibm.rights-management", "irp": "application/vnd.irepository.package+xml", "iso": "application/x-iso9660-image", "itp": "application/vnd.shana.informed.formtemplate", "ivp": "application/vnd.immervision-ivp", "ivu": "application/vnd.immervision-ivu", "jad": "text/vnd.sun.j2me.app-descriptor", "jam": "application/vnd.jam", "jar": "application/java-archive", "java": "text/x-java-source", "jisp": "application/vnd.jisp", "jlt": "application/vnd.hp-jlyt", "jnlp": "application/x-java-jnlp-file", "joda": "application/vnd.joost.joda-archive", "jpe": "image/jpeg", "jpeg": "image/jpeg", "jpg": "image/jpeg", "jpgm": "video/jpm", "jpgv": "video/jpeg", "jpm": "video/jpm", "js": "application/javascript", "json": "application/json", "jsonml": "application/jsonml+json", "kar": "audio/midi", "karbon": "application/vnd.kde.karbon", "kfo": "application/vnd.kde.kformula", "kia": "application/vnd.kidspiration", "kml": "application/vnd.google-earth.kml+xml", "kmz": "application/vnd.google-earth.kmz", "kne": "application/vnd.kinar", "knp": "application/vnd.kinar", "kon": "application/vnd.kde.kontour", "kpr": "application/vnd.kde.kpresenter", "kpt": "application/vnd.kde.kpresenter", "kpxx": "application/vnd.ds-keypoint", "ksp": "application/vnd.kde.kspread", "ktr": "application/vnd.kahootz", "ktx": "image/ktx", "ktz": "application/vnd.kahootz", "kwd": "application/vnd.kde.kword", "kwt": "application/vnd.kde.kword", "lasxml": "application/vnd.las.las+xml", "latex": "application/x-latex", "lbd": "application/vnd.llamagraphics.life-balance.desktop", "lbe": "application/vnd.llamagraphics.life-balance.exchange+xml", "les": "application/vnd.hhe.lesson-player", "lha": "application/x-lzh-compressed", "link66": "application/vnd.route66.link66+xml", "list": "text/plain", "list3820": "application/vnd.ibm.modcap", "listafp": "application/vnd.ibm.modcap", "lnk": "application/x-ms-shortcut", "log": "text/plain", "lostxml": "application/lost+xml", "lrf": "application/octet-stream", "lrm": "application/vnd.ms-lrm", "ltf": "application/vnd.frogans.ltf", "lvp": "audio/vnd.lucent.voice", "lwp": "application/vnd.lotus-wordpro", "lzh": "application/x-lzh-compressed", "m13": "application/x-msmediaview", "m14": "application/x-msmediaview", "m1v": "video/mpeg", "m21": "application/mp21", "m2a": "audio/mpeg", "m2v": "video/mpeg", "m3a": "audio/mpeg", "m3u": "audio/x-mpegurl", "m3u8": "application/vnd.apple.mpegurl", "m4u": "video/vnd.mpegurl", "m4v": "video/x-m4v", "ma": "application/mathematica", "mads": "application/mads+xml", "mag": "application/vnd.ecowin.chart", "maker": "application/vnd.framemaker", "man": "text/troff", "mar": "application/octet-stream", "mathml": "application/mathml+xml", "mb": "application/mathematica", "mbk": "application/vnd.mobius.mbk", "mbox": "application/mbox", "mc1": "application/vnd.medcalcdata", "mcd": "application/vnd.mcd", "mcurl": "text/vnd.curl.mcurl", "mdb": "application/x-msaccess", "mdi": "image/vnd.ms-modi", "me": "text/troff", "mesh": "model/mesh", "meta4": "application/metalink4+xml", "metalink": "application/metalink+xml", "mets": "application/mets+xml", "mfm": "application/vnd.mfmp", "mft": "application/rpki-manifest", "mgp": "application/vnd.osgeo.mapguide.package", "mgz": "application/vnd.proteus.magazine", "mid": "audio/midi", "midi": "audio/midi", "mie": "application/x-mie", "mif": "application/vnd.mif", "mime": "message/rfc822", "mj2": "video/mj2", "mjp2": "video/mj2", "mk3d": "video/x-matroska", "mka": "audio/x-matroska", "mks": "video/x-matroska", "mkv": "video/x-matroska", "mlp": "application/vnd.dolby.mlp", "mmd": "application/vnd.chipnuts.karaoke-mmd", "mmf": "application/vnd.smaf", "mmr": "image/vnd.fujixerox.edmics-mmr", "mng": "video/x-mng", "mny": "application/x-msmoney", "mobi": "application/x-mobipocket-ebook", "mods": "application/mods+xml", "mov": "video/quicktime", "movie": "video/x-sgi-movie", "mp2": "audio/mpeg", "mp21": "application/mp21", "mp2a": "audio/mpeg", "mp3": "audio/mpeg", "mp4": "video/mp4", "mp4a": "audio/mp4", "mp4s": "application/mp4", "mp4v": "video/mp4", "mpc": "application/vnd.mophun.certificate", "mpe": "video/mpeg", "mpeg": "video/mpeg", "mpg": "video/mpeg", "mpg4": "video/mp4", "mpga": "audio/mpeg", "mpkg": "application/vnd.apple.installer+xml", "mpm": "application/vnd.blueice.multipass", "mpn": "application/vnd.mophun.application", "mpp": "application/vnd.ms-project", "mpt": "application/vnd.ms-project", "mpy": "application/vnd.ibm.minipay", "mqy": "application/vnd.mobius.mqy", "mrc": "application/marc", "mrcx": "application/marcxml+xml", "ms": "text/troff", "mscml": "application/mediaservercontrol+xml", "mseed": "application/vnd.fdsn.mseed", "mseq": "application/vnd.mseq", "msf": "application/vnd.epson.msf", "msh": "model/mesh", "msi": "application/x-msdownload", "msl": "application/vnd.mobius.msl", "msty": "application/vnd.muvee.style", "mts": "model/vnd.mts", "mus": "application/vnd.musician", "musicxml": "application/vnd.recordare.musicxml+xml", "mvb": "application/x-msmediaview", "mwf": "application/vnd.mfer", "mxf": "application/mxf", "mxl": "application/vnd.recordare.musicxml", "mxml": "application/xv+xml", "mxs": "application/vnd.triscape.mxs", "mxu": "video/vnd.mpegurl", "n-gage": "application/vnd.nokia.n-gage.symbian.install", "n3": "text/n3", "nb": "application/mathematica", "nbp": "application/vnd.wolfram.player", "nc": "application/x-netcdf", "ncx": "application/x-dtbncx+xml", "nfo": "text/x-nfo", "ngdat": "application/vnd.nokia.n-gage.data", "nitf": "application/vnd.nitf", "nlu": "application/vnd.neurolanguage.nlu", "nml": "application/vnd.enliven", "nnd": "application/vnd.noblenet-directory", "nns": "application/vnd.noblenet-sealer", "nnw": "application/vnd.noblenet-web", "npx": "image/vnd.net-fpx", "nsc": "application/x-conference", "nsf": "application/vnd.lotus-notes", "ntf": "application/vnd.nitf", "nzb": "application/x-nzb", "oa2": "application/vnd.fujitsu.oasys2", "oa3": "application/vnd.fujitsu.oasys3", "oas": "application/vnd.fujitsu.oasys", "obd": "application/x-msbinder", "obj": "application/x-tgif", "oda": "application/oda", "odb": "application/vnd.oasis.opendocument.database", "odc": "application/vnd.oasis.opendocument.chart", "odf": "application/vnd.oasis.opendocument.formula", "odft": "application/vnd.oasis.opendocument.formula-template", "odg": "application/vnd.oasis.opendocument.graphics", "odi": "application/vnd.oasis.opendocument.image", "odm": "application/vnd.oasis.opendocument.text-master", "odp": "application/vnd.oasis.opendocument.presentation", "ods": "application/vnd.oasis.opendocument.spreadsheet", "odt": "application/vnd.oasis.opendocument.text", "oga": "audio/ogg", "ogg": "audio/ogg", "ogv": "video/ogg", "ogx": "application/ogg", "omdoc": "application/omdoc+xml", "onepkg": "application/onenote", "onetmp": "application/onenote", "onetoc": "application/onenote", "onetoc2": "application/onenote", "opf": "application/oebps-package+xml", "opml": "text/x-opml", "oprc": "application/vnd.palm", "org": "application/vnd.lotus-organizer", "osf": "application/vnd.yamaha.openscoreformat", "osfpvg": "application/vnd.yamaha.openscoreformat.osfpvg+xml", "otc": "application/vnd.oasis.opendocument.chart-template", "otf": "application/x-font-otf", "otg": "application/vnd.oasis.opendocument.graphics-template", "oth": "application/vnd.oasis.opendocument.text-web", "oti": "application/vnd.oasis.opendocument.image-template", "otp": "application/vnd.oasis.opendocument.presentation-template", "ots": "application/vnd.oasis.opendocument.spreadsheet-template", "ott": "application/vnd.oasis.opendocument.text-template", "oxps": "application/oxps", "oxt": "application/vnd.openofficeorg.extension", "p": "text/x-pascal", "p10": "application/pkcs10", "p12": "application/x-pkcs12", "p7b": "application/x-pkcs7-certificates", "p7c": "application/pkcs7-mime", "p7m": "application/pkcs7-mime", "p7r": "application/x-pkcs7-certreqresp", "p7s": "application/pkcs7-signature", "p8": "application/pkcs8", "pas": "text/x-pascal", "paw": "application/vnd.pawaafile", "pbd": "application/vnd.powerbuilder6", "pbm": "image/x-portable-bitmap", "pcap": "application/vnd.tcpdump.pcap", "pcf": "application/x-font-pcf", "pcl": "application/vnd.hp-pcl", "pclxl": "application/vnd.hp-pclxl", "pct": "image/x-pict", "pcurl": "application/vnd.curl.pcurl", "pcx": "image/x-pcx", "pdb": "application/vnd.palm", "pdf": "application/pdf", "pfa": "application/x-font-type1", "pfb": "application/x-font-type1", "pfm": "application/x-font-type1", "pfr": "application/font-tdpfr", "pfx": "application/x-pkcs12", "pgm": "image/x-portable-graymap", "pgn": "application/x-chess-pgn", "pgp": "application/pgp-encrypted", "pic": "image/x-pict", "pkg": "application/octet-stream", "pki": "application/pkixcmp", "pkipath": "application/pkix-pkipath", "plb": "application/vnd.3gpp.pic-bw-large", "plc": "application/vnd.mobius.plc", "plf": "application/vnd.pocketlearn", "pls": "application/pls+xml", "pml": "application/vnd.ctc-posml", "png": "image/png", "pnm": "image/x-portable-anymap", "portpkg": "application/vnd.macports.portpkg", "pot": "application/vnd.ms-powerpoint", "potm": "application/vnd.ms-powerpoint.template.macroenabled.12", "potx": "application/vnd.openxmlformats-officedocument.presentationml.template", "ppam": "application/vnd.ms-powerpoint.addin.macroenabled.12", "ppd": "application/vnd.cups-ppd", "ppm": "image/x-portable-pixmap", "pps": "application/vnd.ms-powerpoint", "ppsm": "application/vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "ppt": "application/vnd.ms-powerpoint", "pptm": "application/vnd.ms-powerpoint.presentation.macroenabled.12", "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation", "pqa": "application/vnd.palm", "prc": "application/x-mobipocket-ebook", "pre": "application/vnd.lotus-freelance", "prf": "application/pics-rules", "ps": "application/postscript", "psb": "application/vnd.3gpp.pic-bw-small", "psd": "image/vnd.adobe.photoshop", "psf": "application/x-font-linux-psf", "pskcxml": "application/pskc+xml", "ptid": "application/vnd.pvi.ptid1", "pub": "application/x-mspublisher", "pvb": "application/vnd.3gpp.pic-bw-var", "pwn": "application/vnd.3m.post-it-notes", "pya": "audio/vnd.ms-playready.media.pya", "pyv": "video/vnd.ms-playready.media.pyv", "qam": "application/vnd.epson.quickanime", "qbo": "application/vnd.intu.qbo", "qfx": "application/vnd.intu.qfx", "qps": "application/vnd.publishare-delta-tree", "qt": "video/quicktime", "qwd": "application/vnd.quark.quarkxpress", "qwt": "application/vnd.quark.quarkxpress", "qxb": "application/vnd.quark.quarkxpress", "qxd": "application/vnd.quark.quarkxpress", "qxl": "application/vnd.quark.quarkxpress", "qxt": "application/vnd.quark.quarkxpress", "ra": "audio/x-pn-realaudio", "ram": "audio/x-pn-realaudio", "rar": "application/x-rar-compressed", "ras": "image/x-cmu-raster", "rcprofile": "application/vnd.ipunplugged.rcprofile", "rdf": "application/rdf+xml", "rdz": "application/vnd.data-vision.rdz", "rep": "application/vnd.businessobjects", "res": "application/x-dtbresource+xml", "rgb": "image/x-rgb", "rif": "application/reginfo+xml", "rip": "audio/vnd.rip", "ris": "application/x-research-info-systems", "rl": "application/resource-lists+xml", "rlc": "image/vnd.fujixerox.edmics-rlc", "rld": "application/resource-lists-diff+xml", "rm": "application/vnd.rn-realmedia", "rmi": "audio/midi", "rmp": "audio/x-pn-realaudio-plugin", "rms": "application/vnd.jcp.javame.midlet-rms", "rmvb": "application/vnd.rn-realmedia-vbr", "rnc": "application/relax-ng-compact-syntax", "roa": "application/rpki-roa", "roff": "text/troff", "rp9": "application/vnd.cloanto.rp9", "rpss": "application/vnd.nokia.radio-presets", "rpst": "application/vnd.nokia.radio-preset", "rq": "application/sparql-query", "rs": "application/rls-services+xml", "rsd": "application/rsd+xml", "rss": "application/rss+xml", "rtf": "application/rtf", "rtx": "text/richtext", "s": "text/x-asm", "s3m": "audio/s3m", "saf": "application/vnd.yamaha.smaf-audio", "sbml": "application/sbml+xml", "sc": "application/vnd.ibm.secure-container", "scd": "application/x-msschedule", "scm": "application/vnd.lotus-screencam", "scq": "application/scvp-cv-request", "scs": "application/scvp-cv-response", "scurl": "text/vnd.curl.scurl", "sda": "application/vnd.stardivision.draw", "sdc": "application/vnd.stardivision.calc", "sdd": "application/vnd.stardivision.impress", "sdkd": "application/vnd.solent.sdkm+xml", "sdkm": "application/vnd.solent.sdkm+xml", "sdp": "application/sdp", "sdw": "application/vnd.stardivision.writer", "see": "application/vnd.seemail", "seed": "application/vnd.fdsn.seed", "sema": "application/vnd.sema", "semd": "application/vnd.semd", "semf": "application/vnd.semf", "ser": "application/java-serialized-object", "setpay": "application/set-payment-initiation", "setreg": "application/set-registration-initiation", "sfd-hdstx": "application/vnd.hydrostatix.sof-data", "sfs": "application/vnd.spotfire.sfs", "sfv": "text/x-sfv", "sgi": "image/sgi", "sgl": "application/vnd.stardivision.writer-global", "sgm": "text/sgml", "sgml": "text/sgml", "sh": "application/x-sh", "shar": "application/x-shar", "shf": "application/shf+xml", "sid": "image/x-mrsid-image", "sig": "application/pgp-signature", "sil": "audio/silk", "silo": "model/mesh", "sis": "application/vnd.symbian.install", "sisx": "application/vnd.symbian.install", "sit": "application/x-stuffit", "sitx": "application/x-stuffitx", "skd": "application/vnd.koan", "skm": "application/vnd.koan", "skp": "application/vnd.koan", "skt": "application/vnd.koan", "sldm": "application/vnd.ms-powerpoint.slide.macroenabled.12", "sldx": "application/vnd.openxmlformats-officedocument.presentationml.slide", "slt": "application/vnd.epson.salt", "sm": "application/vnd.stepmania.stepchart", "smf": "application/vnd.stardivision.math", "smi": "application/smil+xml", "smil": "application/smil+xml", "smv": "video/x-smv", "smzip": "application/vnd.stepmania.package", "snd": "audio/basic", "snf": "application/x-font-snf", "so": "application/octet-stream", "spc": "application/x-pkcs7-certificates", "spf": "application/vnd.yamaha.smaf-phrase", "spl": "application/x-futuresplash", "spot": "text/vnd.in3d.spot", "spp": "application/scvp-vp-response", "spq": "application/scvp-vp-request", "spx": "audio/ogg", "sql": "application/x-sql", "src": "application/x-wais-source", "srt": "application/x-subrip", "sru": "application/sru+xml", "srx": "application/sparql-results+xml", "ssdl": "application/ssdl+xml", "sse": "application/vnd.kodak-descriptor", "ssf": "application/vnd.epson.ssf", "ssml": "application/ssml+xml", "st": "application/vnd.sailingtracker.track", "stc": "application/vnd.sun.xml.calc.template", "std": "application/vnd.sun.xml.draw.template", "stf": "application/vnd.wt.stf", "sti": "application/vnd.sun.xml.impress.template", "stk": "application/hyperstudio", "stl": "application/vnd.ms-pki.stl", "str": "application/vnd.pg.format", "stw": "application/vnd.sun.xml.writer.template", "sub": "text/vnd.dvb.subtitle", "sus": "application/vnd.sus-calendar", "susp": "application/vnd.sus-calendar", "sv4cpio": "application/x-sv4cpio", "sv4crc": "application/x-sv4crc", "svc": "application/vnd.dvb.service", "svd": "application/vnd.svd", "svg": "image/svg+xml", "svgz": "image/svg+xml", "swa": "application/x-director", "swf": "application/x-shockwave-flash", "swi": "application/vnd.aristanetworks.swi", "sxc": "application/vnd.sun.xml.calc", "sxd": "application/vnd.sun.xml.draw", "sxg": "application/vnd.sun.xml.writer.global", "sxi": "application/vnd.sun.xml.impress", "sxm": "application/vnd.sun.xml.math", "sxw": "application/vnd.sun.xml.writer", "t": "text/troff", "t3": "application/x-t3vm-image", "taglet": "application/vnd.mynfc", "tao": "application/vnd.tao.intent-module-archive", "tar": "application/x-tar", "tcap": "application/vnd.3gpp2.tcap", "tcl": "application/x-tcl", "teacher": "application/vnd.smart.teacher", "tei": "application/tei+xml", "teicorpus": "application/tei+xml", "tex": "application/x-tex", "texi": "application/x-texinfo", "texinfo": "application/x-texinfo", "text": "text/plain", "tfi": "application/thraud+xml", "tfm": "application/x-tex-tfm", "tga": "image/x-tga", "thmx": "application/vnd.ms-officetheme", "tif": "image/tiff", "tiff": "image/tiff", "tmo": "application/vnd.tmobile-livetv", "torrent": "application/x-bittorrent", "tpl": "application/vnd.groove-tool-template", "tpt": "application/vnd.trid.tpt", "tr": "text/troff", "tra": "application/vnd.trueapp", "trm": "application/x-msterminal", "tsd": "application/timestamped-data", "tsv": "text/tab-separated-values", "ttc": "application/x-font-ttf", "ttf": "application/x-font-ttf", "ttl": "text/turtle", "twd": "application/vnd.simtech-mindmapper", "twds": "application/vnd.simtech-mindmapper", "txd": "application/vnd.genomatix.tuxedo", "txf": "application/vnd.mobius.txf", "txt": "text/plain", "u32": "application/x-authorware-bin", "udeb": "application/x-debian-package", "ufd": "application/vnd.ufdl", "ufdl": "application/vnd.ufdl", "ulx": "application/x-glulx", "umj": "application/vnd.umajin", "unityweb": "application/vnd.unity", "uoml": "application/vnd.uoml+xml", "uri": "text/uri-list", "uris": "text/uri-list", "urls": "text/uri-list", "ustar": "application/x-ustar", "utz": "application/vnd.uiq.theme", "uu": "text/x-uuencode", "uva": "audio/vnd.dece.audio", "uvd": "application/vnd.dece.data", "uvf": "application/vnd.dece.data", "uvg": "image/vnd.dece.graphic", "uvh": "video/vnd.dece.hd", "uvi": "image/vnd.dece.graphic", "uvm": "video/vnd.dece.mobile", "uvp": "video/vnd.dece.pd", "uvs": "video/vnd.dece.sd", "uvt": "application/vnd.dece.ttml+xml", "uvu": "video/vnd.uvvu.mp4", "uvv": "video/vnd.dece.video", "uvva": "audio/vnd.dece.audio", "uvvd": "application/vnd.dece.data", "uvvf": "application/vnd.dece.data", "uvvg": "image/vnd.dece.graphic", "uvvh": "video/vnd.dece.hd", "uvvi": "image/vnd.dece.graphic", "uvvm": "video/vnd.dece.mobile", "uvvp": "video/vnd.dece.pd", "uvvs": "video/vnd.dece.sd", "uvvt": "application/vnd.dece.ttml+xml", "uvvu": "video/vnd.uvvu.mp4", "uvvv": "video/vnd.dece.video", "uvvx": "application/vnd.dece.unspecified", "uvvz": "application/vnd.dece.zip", "uvx": "application/vnd.dece.unspecified", "uvz": "application/vnd.dece.zip", "vcard": "text/vcard", "vcd": "application/x-cdlink", "vcf": "text/x-vcard", "vcg": "application/vnd.groove-vcard", "vcs": "text/x-vcalendar", "vcx": "application/vnd.vcx", "vis": "application/vnd.visionary", "viv": "video/vnd.vivo", "vob": "video/x-ms-vob", "vor": "application/vnd.stardivision.writer", "vox": "application/x-authorware-bin", "vrml": "model/vrml", "vsd": "application/vnd.visio", "vsf": "application/vnd.vsf", "vss": "application/vnd.visio", "vst": "application/vnd.visio", "vsw": "application/vnd.visio", "vtu": "model/vnd.vtu", "vxml": "application/voicexml+xml", "w3d": "application/x-director", "wad": "application/x-doom", "wasm": "application/wasm", "wav": "audio/x-wav", "wax": "audio/x-ms-wax", "wbmp": "image/vnd.wap.wbmp", "wbs": "application/vnd.criticaltools.wbs+xml", "wbxml": "application/vnd.wap.wbxml", "wcm": "application/vnd.ms-works", "wdb": "application/vnd.ms-works", "wdp": "image/vnd.ms-photo", "weba": "audio/webm", "webm": "video/webm", "webp": "image/webp", "wg": "application/vnd.pmi.widget", "wgt": "application/widget", "wks": "application/vnd.ms-works", "wm": "video/x-ms-wm", "wma": "audio/x-ms-wma", "wmd": "application/x-ms-wmd", "wmf": "application/x-msmetafile", "wml": "text/vnd.wap.wml", "wmlc": "application/vnd.wap.wmlc", "wmls": "text/vnd.wap.wmlscript", "wmlsc": "application/vnd.wap.wmlscriptc", "wmv": "video/x-ms-wmv", "wmx": "video/x-ms-wmx", "wmz": "application/x-ms-wmz", "woff": "application/x-font-woff", "wpd": "application/vnd.wordperfect", "wpl": "application/vnd.ms-wpl", "wps": "application/vnd.ms-works", "wqd": "application/vnd.wqd", "wri": "application/x-mswrite", "wrl": "model/vrml", "wsdl": "application/wsdl+xml", "wspolicy": "application/wspolicy+xml", "wtb": "application/vnd.webturbo", "wvx": "video/x-ms-wvx", "x32": "application/x-authorware-bin", "x3d": "model/x3d+xml", "x3db": "model/x3d+binary", "x3dbz": "model/x3d+binary", "x3dv": "model/x3d+vrml", "x3dvz": "model/x3d+vrml", "x3dz": "model/x3d+xml", "xaml": "application/xaml+xml", "xap": "application/x-silverlight-app", "xar": "application/vnd.xara", "xbap": "application/x-ms-xbap", "xbd": "application/vnd.fujixerox.docuworks.binder", "xbm": "image/x-xbitmap", "xdf": "application/xcap-diff+xml", "xdm": "application/vnd.syncml.dm+xml", "xdp": "application/vnd.adobe.xdp+xml", "xdssc": "application/dssc+xml", "xdw": "application/vnd.fujixerox.docuworks", "xenc": "application/xenc+xml", "xer": "application/patch-ops-error+xml", "xfdf": "application/vnd.adobe.xfdf", "xfdl": "application/vnd.xfdl", "xht": "application/xhtml+xml", "xhtml": "application/xhtml+xml", "xhvml": "application/xv+xml", "xif": "image/vnd.xiff", "xla": "application/vnd.ms-excel", "xlam": "application/vnd.ms-excel.addin.macroenabled.12", "xlc": "application/vnd.ms-excel", "xlf": "application/x-xliff+xml", "xlm": "application/vnd.ms-excel", "xls": "application/vnd.ms-excel", "xlsb": "application/vnd.ms-excel.sheet.binary.macroenabled.12", "xlsm": "application/vnd.ms-excel.sheet.macroenabled.12", "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlt": "application/vnd.ms-excel", "xltm": "application/vnd.ms-excel.template.macroenabled.12", "xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "xlw": "application/vnd.ms-excel", "xm": "audio/xm", "xml": "application/xml", "xo": "application/vnd.olpc-sugar", "xop": "application/xop+xml", "xpi": "application/x-xpinstall", "xpl": "application/xproc+xml", "xpm": "image/x-xpixmap", "xpr": "application/vnd.is-xpr", "xps": "application/vnd.ms-xpsdocument", "xpw": "application/vnd.intercon.formnet", "xpx": "application/vnd.intercon.formnet", "xsl": "application/xml", "xslt": "application/xslt+xml", "xsm": "application/vnd.syncml+xml", "xspf": "application/xspf+xml", "xul": "application/vnd.mozilla.xul+xml", "xvm": "application/xv+xml", "xvml": "application/xv+xml", "xwd": "image/x-xwindowdump", "xyz": "chemical/x-xyz", "xz": "application/x-xz", "yang": "application/yang", "yin": "application/yin+xml", "z1": "application/x-zmachine", "z2": "application/x-zmachine", "z3": "application/x-zmachine", "z4": "application/x-zmachine", "z5": "application/x-zmachine", "z6": "application/x-zmachine", "z7": "application/x-zmachine", "z8": "application/x-zmachine", "zaz": "application/vnd.zzazz.deck+xml", "zip": "application/zip", "zir": "application/vnd.zul", "zirz": "application/vnd.zul", "zmm": "application/vnd.handheld-entertainment+xml"};
}
library mime.magic_number from "package:mime/src/magic_number.dart" as mag {
  class MagicNumber extends core::Object {
    final field core::String mimeType;
    final field core::List<core::int> numbers;
    final field core::List<core::int> mask;
    const constructor •(core::String mimeType, core::List<core::int> numbers, {core::List<core::int> mask = null}) → void
      : mag::MagicNumber::mimeType = mimeType, mag::MagicNumber::numbers = numbers, mag::MagicNumber::mask = mask, super core::Object::•()
      ;
    method matches(core::List<core::int> header) → core::bool {
      if(header.{core::List::length}.{core::num::<}(this.{mag::MagicNumber::numbers}.{core::List::length}))
        return false;
      for (core::int i = 0; i.{core::num::<}(this.{mag::MagicNumber::numbers}.{core::List::length}); i = i.{core::num::+}(1)) {
        if(!this.{mag::MagicNumber::mask}.{core::Object::==}(null)) {
          if(!this.{mag::MagicNumber::mask}.{core::List::[]}(i).{core::int::&}(this.{mag::MagicNumber::numbers}.{core::List::[]}(i)).{core::num::==}(this.{mag::MagicNumber::mask}.{core::List::[]}(i).{core::int::&}(header.{core::List::[]}(i))))
            return false;
        }
        else {
          if(!this.{mag::MagicNumber::numbers}.{core::List::[]}(i).{core::num::==}(header.{core::List::[]}(i)))
            return false;
        }
      }
      return true;
    }
  }
  static const field core::int DEFAULT_MAGIC_NUMBERS_MAX_LENGTH = 12;
  static const field core::List<mag::MagicNumber> DEFAULT_MAGIC_NUMBERS = const <mag::MagicNumber>[const mag::MagicNumber::•("application/pdf", const <core::int>[37, 80, 68, 70]), const mag::MagicNumber::•("application/postscript", const <core::int>[37, 81]), const mag::MagicNumber::•("image/gif", const <core::int>[71, 73, 70, 56, 55, 97]), const mag::MagicNumber::•("image/gif", const <core::int>[71, 73, 70, 56, 57, 97]), const mag::MagicNumber::•("image/jpeg", const <core::int>[255, 216]), const mag::MagicNumber::•("image/png", const <core::int>[137, 80, 78, 71, 13, 10, 26, 10]), const mag::MagicNumber::•("image/tiff", const <core::int>[73, 73, 42, 0]), const mag::MagicNumber::•("image/tiff", const <core::int>[77, 77, 0, 42]), const mag::MagicNumber::•("video/mp4", const <core::int>[0, 0, 0, 0, 102, 116, 121, 112, 51, 103, 112, 53], mask: const <core::int>[255, 255, 255, 0, 255, 255, 255, 255, 255, 255, 255, 255]), const mag::MagicNumber::•("model/gltf-binary", const <core::int>[70, 84, 108, 103])];
}
library from "package:code_buffer/code_buffer.dart" as cod {
  import "package:source_span/source_span.dart";
  class CodeBuffer extends core::Object implements core::StringBuffer {
    final field core::String newline;
    final field core::String space;
    final field dynamic sourceUrl;
    final field core::bool trailingNewline;
    final field core::List<cod::CodeBufferLine> _lines = <cod::CodeBufferLine>[];
    field cod::CodeBufferLine _currentLine = null;
    field cod::CodeBufferLine _lastLine = null;
    field core::int _indentationLevel = 0;
    field core::int _length = 0;
    constructor •({core::String space = "  ", core::String newline = "\n", core::bool trailingNewline = false, dynamic sourceUrl = null}) → void
      : cod::CodeBuffer::space = space, cod::CodeBuffer::newline = newline, cod::CodeBuffer::trailingNewline = trailingNewline, cod::CodeBuffer::sourceUrl = sourceUrl, super core::Object::•()
      ;
    static factory noWhitespace({dynamic sourceUrl = null}) → cod::CodeBuffer
      return new cod::CodeBuffer::•(space: "", newline: "", trailingNewline: false, sourceUrl: sourceUrl);
    get lastLine() → cod::CodeBufferLine
      return this.{cod::CodeBuffer::_lastLine};
    get lines() → core::List<cod::CodeBufferLine>
      return core::List::unmodifiable<cod::CodeBufferLine>(this.{cod::CodeBuffer::_lines});
    @core::override
    get isEmpty() → core::bool
      return this.{cod::CodeBuffer::_lines}.{core::Iterable::isEmpty};
    @core::override
    get isNotEmpty() → core::bool
      return this.{cod::CodeBuffer::_lines}.{core::Iterable::isNotEmpty};
    @core::override
    get length() → core::int
      return this.{cod::CodeBuffer::_length};
    method _createLine() → cod::CodeBufferLine {
      loc2::SourceLocation start = new loc2::SourceLocation::•(this.{cod::CodeBuffer::_length}, sourceUrl: this.{cod::CodeBuffer::sourceUrl}, line: this.{cod::CodeBuffer::_lines}.{core::List::length}, column: this.{cod::CodeBuffer::_indentationLevel}.{core::num::*}(this.{cod::CodeBuffer::space}.{core::String::length}));
      cod::CodeBufferLine line = let final cod::CodeBufferLine #t608 = new cod::CodeBufferLine::_(this.{cod::CodeBuffer::_indentationLevel}, start) in let final dynamic #t609 = #t608.{cod::CodeBufferLine::_end} = start in #t608;
      this.{cod::CodeBuffer::_lines}.{core::List::add}(this.{cod::CodeBuffer::_lastLine} = line);
      return line;
    }
    method indent() → void {
      this.{cod::CodeBuffer::_indentationLevel} = this.{cod::CodeBuffer::_indentationLevel}.{core::num::+}(1);
    }
    method outdent() → void {
      if(this.{cod::CodeBuffer::_indentationLevel}.{core::num::>}(0))
        this.{cod::CodeBuffer::_indentationLevel} = this.{cod::CodeBuffer::_indentationLevel}.{core::num::-}(1);
    }
    method copyInto(cod::CodeBuffer other) → void {
      if(this.{cod::CodeBuffer::_lines}.{core::Iterable::isEmpty})
        return;
      core::int i = 0;
      for (cod::CodeBufferLine line in this.{cod::CodeBuffer::_lines}) {
        core::int column = other.{cod::CodeBuffer::_indentationLevel}.{core::num::+}(line.{cod::CodeBufferLine::indentationLevel}).{core::num::*}(other.{cod::CodeBuffer::space}.{core::String::length});
        core::int offset = other.{cod::CodeBuffer::_length}.{core::num::+}(other.{cod::CodeBuffer::newline}.{core::String::length}).{core::num::+}(column);
        loc2::SourceLocation start = new loc2::SourceLocation::•(offset, sourceUrl: other.{cod::CodeBuffer::sourceUrl}, line: other.{cod::CodeBuffer::_lines}.{core::List::length}.{core::num::+}(i), column: column);
        loc2::SourceLocation end = new loc2::SourceLocation::•(offset.{core::num::+}(line.{cod::CodeBufferLine::span}.{span::SourceSpan::length}), sourceUrl: other.{cod::CodeBuffer::sourceUrl}, line: start.{loc2::SourceLocation::line}, column: column.{core::num::+}(line.{cod::CodeBufferLine::_buf}.{core::StringBuffer::length}));
        cod::CodeBufferLine clone = let final cod::CodeBufferLine #t610 = new cod::CodeBufferLine::_(line.{cod::CodeBufferLine::indentationLevel}.{core::num::+}(other.{cod::CodeBuffer::_indentationLevel}), start) in let final dynamic #t611 = #t610.{cod::CodeBufferLine::_end} = end in let final dynamic #t612 = #t610.{cod::CodeBufferLine::_buf}.{core::StringBuffer::write}(line.{cod::CodeBufferLine::_buf}.{core::StringBuffer::toString}()) in #t610;
        if(!line.{cod::CodeBufferLine::_lastSpan}.{core::Object::==}(null)) {
          loc2::SourceLocation s = line.{cod::CodeBufferLine::_lastSpan}.{span::SourceSpan::start};
          core::int lastSpanColumn = line.{cod::CodeBufferLine::indentationLevel}.{core::num::+}(other.{cod::CodeBuffer::_indentationLevel}).{core::num::*}(other.{cod::CodeBuffer::space}.{core::String::length}).{core::num::+}(line.{cod::CodeBufferLine::text}.{core::String::indexOf}(line.{cod::CodeBufferLine::_lastSpan}.{span::SourceSpan::text}));
          clone.{cod::CodeBufferLine::_lastSpan} = span::SourceSpan::•(new loc2::SourceLocation::•(offset.{core::num::+}(s.{loc2::SourceLocation::offset}), sourceUrl: other.{cod::CodeBuffer::sourceUrl}, line: clone.{cod::CodeBufferLine::span}.{span::SourceSpan::start}.{loc2::SourceLocation::line}, column: lastSpanColumn), new loc2::SourceLocation::•(offset.{core::num::+}(s.{loc2::SourceLocation::offset}).{core::num::+}(line.{cod::CodeBufferLine::_lastSpan}.{span::SourceSpan::length}), sourceUrl: other.{cod::CodeBuffer::sourceUrl}, line: clone.{cod::CodeBufferLine::span}.{span::SourceSpan::end}.{loc2::SourceLocation::line}, column: lastSpanColumn.{core::num::+}(line.{cod::CodeBufferLine::_lastSpan}.{span::SourceSpan::length})), line.{cod::CodeBufferLine::_lastSpan}.{span::SourceSpan::text});
        }
        other.{cod::CodeBuffer::_lines}.{core::List::add}(other.{cod::CodeBuffer::_currentLine} = other.{cod::CodeBuffer::_lastLine} = clone);
        other.{cod::CodeBuffer::_length} = offset.{core::num::+}(clone.{cod::CodeBufferLine::span}.{span::SourceSpan::length});
        i = i.{core::num::+}(1);
      }
      other.{cod::CodeBuffer::writeln}();
    }
    @core::override
    method clear() → void {
      this.{cod::CodeBuffer::_lines}.{core::List::clear}();
      this.{cod::CodeBuffer::_length} = this.{cod::CodeBuffer::_indentationLevel} = 0;
      this.{cod::CodeBuffer::_currentLine} = null;
    }
    @core::override
    method writeCharCode(core::int charCode) → void {
      this.{cod::CodeBuffer::_currentLine}.{core::Object::==}(null) ?{cod::CodeBufferLine} this.{cod::CodeBuffer::_currentLine} = this.{cod::CodeBuffer::_createLine}() : null;
      this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_buf}.{core::StringBuffer::writeCharCode}(charCode);
      loc2::SourceLocation end = this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_end};
      this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_end} = new loc2::SourceLocation::•(end.{loc2::SourceLocation::offset}.{core::num::+}(1), sourceUrl: end.{loc2::SourceLocation::sourceUrl}, line: end.{loc2::SourceLocation::line}, column: end.{loc2::SourceLocation::column}.{core::num::+}(1));
      this.{cod::CodeBuffer::_length} = this.{cod::CodeBuffer::_length}.{core::num::+}(1);
      this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_lastSpan} = span::SourceSpan::•(end, this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_end}, core::String::fromCharCode(charCode));
    }
    @core::override
    method write(core::Object obj) → void {
      core::String msg = obj.{core::Object::toString}();
      this.{cod::CodeBuffer::_currentLine}.{core::Object::==}(null) ?{cod::CodeBufferLine} this.{cod::CodeBuffer::_currentLine} = this.{cod::CodeBuffer::_createLine}() : null;
      this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_buf}.{core::StringBuffer::write}(msg);
      loc2::SourceLocation end = this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_end};
      this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_end} = new loc2::SourceLocation::•(end.{loc2::SourceLocation::offset}.{core::num::+}(msg.{core::String::length}), sourceUrl: end.{loc2::SourceLocation::sourceUrl}, line: end.{loc2::SourceLocation::line}, column: end.{loc2::SourceLocation::column}.{core::num::+}(msg.{core::String::length}));
      this.{cod::CodeBuffer::_length} = this.{cod::CodeBuffer::_length}.{core::num::+}(msg.{core::String::length});
      this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_lastSpan} = span::SourceSpan::•(end, this.{cod::CodeBuffer::_currentLine}.{cod::CodeBufferLine::_end}, msg);
    }
    @core::override
    method writeln([core::Object obj = ""]) → void {
      if(!obj.{core::Object::==}(null) && !obj.{core::Object::==}(""))
        this.{cod::CodeBuffer::write}(obj);
      this.{cod::CodeBuffer::_currentLine} = null;
      this.{cod::CodeBuffer::_length} = this.{cod::CodeBuffer::_length}.{core::num::+}(1);
    }
    @core::override
    method writeAll(core::Iterable<dynamic> objects, [core::String separator = ""]) → void {
      this.{cod::CodeBuffer::write}(objects.{core::Iterable::join}(separator));
    }
    @core::override
    method toString() → core::String {
      core::StringBuffer buf = new core::StringBuffer::•();
      core::int i = 0;
      for (cod::CodeBufferLine line in this.{cod::CodeBuffer::lines}) {
        if((let final core::int #t613 = i in let final core::int #t614 = i = #t613.{core::num::+}(1) in #t613).{core::num::>}(0))
          buf.{core::StringBuffer::write}(this.{cod::CodeBuffer::newline});
        for (core::int j = 0; j.{core::num::<}(line.{cod::CodeBufferLine::indentationLevel}); j = j.{core::num::+}(1))
          buf.{core::StringBuffer::write}(this.{cod::CodeBuffer::space});
        buf.{core::StringBuffer::write}(line.{cod::CodeBufferLine::_buf}.{core::StringBuffer::toString}());
      }
      if(this.{cod::CodeBuffer::trailingNewline}.{core::Object::==}(true))
        buf.{core::StringBuffer::write}(this.{cod::CodeBuffer::newline});
      return buf.{core::StringBuffer::toString}();
    }
  }
  class CodeBufferLine extends core::Object {
    final field core::Map<span::SourceSpan, span::SourceSpan> sourceMappings = <span::SourceSpan, span::SourceSpan>{};
    final field core::int indentationLevel;
    final field loc2::SourceLocation _start;
    final field core::StringBuffer _buf = new core::StringBuffer::•();
    field loc2::SourceLocation _end = null;
    field span::SourceSpan _lastSpan = null;
    constructor _(core::int indentationLevel, loc2::SourceLocation _start) → void
      : cod::CodeBufferLine::indentationLevel = indentationLevel, cod::CodeBufferLine::_start = _start, super core::Object::•()
      ;
    get lastSpan() → span::SourceSpan
      return this.{cod::CodeBufferLine::_lastSpan};
    get span() → span::SourceSpan
      return span::SourceSpan::•(this.{cod::CodeBufferLine::_start}, this.{cod::CodeBufferLine::_end}, this.{cod::CodeBufferLine::_buf}.{core::StringBuffer::toString}());
    get text() → core::String
      return this.{cod::CodeBufferLine::_buf}.{core::StringBuffer::toString}();
  }
}
library from "package:matcher/matcher.dart" as mat {
  export "package:matcher/src/core_matchers.dart";
  export "package:matcher/src/custom_matcher.dart";
  export "package:matcher/src/description.dart";
  export "package:matcher/src/equals_matcher.dart";
  export "package:matcher/src/error_matchers.dart";
  export "package:matcher/src/interfaces.dart";
  export "package:matcher/src/iterable_matchers.dart";
  export "package:matcher/src/map_matchers.dart";
  export "package:matcher/src/numeric_matchers.dart";
  export "package:matcher/src/operator_matchers.dart";
  export "package:matcher/src/order_matchers.dart";
  export "package:matcher/src/string_matchers.dart";
  export "package:matcher/src/type_matcher.dart";
  export "package:matcher/src/util.dart";
}
library from "package:source_span/source_span.dart" as sou {
  export "package:source_span/src/file.dart";
  export "package:source_span/src/location.dart";
  export "package:source_span/src/location_mixin.dart";
  export "package:source_span/src/span.dart";
  export "package:source_span/src/span_exception.dart";
  export "package:source_span/src/span_mixin.dart";
  export "package:source_span/src/span_with_context.dart";
}
library from "package:string_scanner/src/exception.dart" as exc2 {
  import "package:source_span/source_span.dart";
  class StringScannerException extends spa3::SourceSpanFormatException {
    constructor •(core::String message, span::SourceSpan span, core::String source) → void
      : super spa3::SourceSpanFormatException::•(message, span, source)
      ;
    get source() → core::String
      return super.{spa3::SourceSpanFormatException::source} as{TypeError} core::String;
    get sourceUrl() → core::Uri
      return this.{spa3::SourceSpanException::span}.{span::SourceSpan::sourceUrl};
  }
}
library from "package:string_scanner/src/line_scanner.dart" as lin {
  import "package:charcode/ascii.dart";
  import "package:string_scanner/src/string_scanner.dart";
  class LineScanner extends str::StringScanner {
    field core::int _line = 0;
    field core::int _column = 0;
    constructor •(core::String string, {dynamic sourceUrl = null, core::int position = null}) → void
      : super str::StringScanner::•(string, sourceUrl: sourceUrl, position: position)
      ;
    get line() → core::int
      return this.{lin::LineScanner::_line};
    get column() → core::int
      return this.{lin::LineScanner::_column};
    get state() → lin::LineScannerState
      return new lin::LineScannerState::_(this, this.{str::StringScanner::position}, this.{lin::LineScanner::line}, this.{lin::LineScanner::column});
    get _betweenCRLF() → core::bool
      return this.{str::StringScanner::peekChar}(1.{core::int::unary-}()).{core::num::==}(dol::$cr) && this.{str::StringScanner::peekChar}().{core::num::==}(dol::$lf);
    set state(lin::LineScannerState state) → void {
      if(!core::identical(state.{lin::LineScannerState::_scanner}, this)) {
        throw new core::ArgumentError::•("The given LineScannerState was not returned by this LineScanner.");
      }
      super.{str::StringScanner::position} = state.{lin::LineScannerState::position};
      this.{lin::LineScanner::_line} = state.{lin::LineScannerState::line};
      this.{lin::LineScanner::_column} = state.{lin::LineScannerState::column};
    }
    set position(core::int newPosition) → void {
      core::int oldPosition = this.{str::StringScanner::position};
      super.{str::StringScanner::position} = newPosition;
      if(newPosition.{core::num::>}(oldPosition)) {
        core::List<core::Match> newlines = this.{lin::LineScanner::_newlinesIn}(this.{str::StringScanner::string}.{core::String::substring}(oldPosition, newPosition));
        this.{lin::LineScanner::_line} = this.{lin::LineScanner::_line}.{core::num::+}(newlines.{core::List::length});
        if(newlines.{core::Iterable::isEmpty}) {
          this.{lin::LineScanner::_column} = this.{lin::LineScanner::_column}.{core::num::+}(newPosition.{core::num::-}(oldPosition));
        }
        else {
          this.{lin::LineScanner::_column} = newPosition.{core::num::-}(newlines.{core::Iterable::last}.{core::Match::end});
        }
      }
      else {
        core::List<core::Match> newlines = this.{lin::LineScanner::_newlinesIn}(this.{str::StringScanner::string}.{core::String::substring}(newPosition, oldPosition));
        if(this.{lin::LineScanner::_betweenCRLF})
          newlines.{core::List::removeLast}();
        this.{lin::LineScanner::_line} = this.{lin::LineScanner::_line}.{core::num::-}(newlines.{core::List::length});
        if(newlines.{core::Iterable::isEmpty}) {
          this.{lin::LineScanner::_column} = this.{lin::LineScanner::_column}.{core::num::-}(oldPosition.{core::num::-}(newPosition));
        }
        else {
          this.{lin::LineScanner::_column} = newPosition.{core::num::-}(this.{str::StringScanner::string}.{core::String::lastIndexOf}(lin::_newlineRegExp, newPosition)).{core::num::-}(1);
        }
      }
    }
    method scanChar(core::int character) → core::bool {
      if(!super.{str::StringScanner::scanChar}(character))
        return false;
      this.{lin::LineScanner::_adjustLineAndColumn}(character);
      return true;
    }
    method readChar() → core::int {
      core::int character = super.{str::StringScanner::readChar}();
      this.{lin::LineScanner::_adjustLineAndColumn}(character);
      return character;
    }
    method _adjustLineAndColumn(core::int character) → void {
      if(character.{core::num::==}(dol::$lf) || character.{core::num::==}(dol::$cr) && !this.{str::StringScanner::peekChar}().{core::num::==}(dol::$lf)) {
        this.{lin::LineScanner::_line} = this.{lin::LineScanner::_line}.{core::num::+}(1);
        this.{lin::LineScanner::_column} = 0;
      }
      else {
        this.{lin::LineScanner::_column} = this.{lin::LineScanner::_column}.{core::num::+}(1);
      }
    }
    method scan(core::Pattern pattern) → core::bool {
      if(!super.{str::StringScanner::scan}(pattern))
        return false;
      core::List<core::Match> newlines = this.{lin::LineScanner::_newlinesIn}(this.{str::StringScanner::lastMatch}.{core::Match::[]}(0));
      this.{lin::LineScanner::_line} = this.{lin::LineScanner::_line}.{core::num::+}(newlines.{core::List::length});
      if(newlines.{core::Iterable::isEmpty}) {
        this.{lin::LineScanner::_column} = this.{lin::LineScanner::_column}.{core::num::+}(this.{str::StringScanner::lastMatch}.{core::Match::[]}(0).{core::String::length});
      }
      else {
        this.{lin::LineScanner::_column} = this.{str::StringScanner::lastMatch}.{core::Match::[]}(0).{core::String::length}.{core::num::-}(newlines.{core::Iterable::last}.{core::Match::end});
      }
      return true;
    }
    method _newlinesIn(core::String text) → core::List<core::Match> {
      core::List<core::Match> newlines = lin::_newlineRegExp.{core::RegExp::allMatches}(text).{core::Iterable::toList}();
      if(this.{lin::LineScanner::_betweenCRLF})
        newlines.{core::List::removeLast}();
      return newlines;
    }
  }
  class LineScannerState extends core::Object {
    final field lin::LineScanner _scanner;
    final field core::int position;
    final field core::int line;
    final field core::int column;
    constructor _(lin::LineScanner _scanner, core::int position, core::int line, core::int column) → void
      : lin::LineScannerState::_scanner = _scanner, lin::LineScannerState::position = position, lin::LineScannerState::line = line, lin::LineScannerState::column = column, super core::Object::•()
      ;
  }
  static final field core::RegExp _newlineRegExp = core::RegExp::•("\\r\\n?|\\n");
}
library from "package:string_scanner/src/span_scanner.dart" as spa {
  import "package:source_span/source_span.dart";
  import "package:string_scanner/src/eager_span_scanner.dart";
  import "package:string_scanner/src/exception.dart";
  import "package:string_scanner/src/line_scanner.dart";
  import "package:string_scanner/src/relative_span_scanner.dart";
  import "package:string_scanner/src/string_scanner.dart";
  import "package:string_scanner/src/utils.dart";
  class SpanScanner extends str::StringScanner implements lin::LineScanner {
    final field file3::SourceFile _sourceFile;
    field file3::FileSpan _lastSpan = null;
    static field dynamic _redirecting# = <dynamic>[spa::SpanScanner::eager, spa::SpanScanner::within];
    constructor •(core::String string, {dynamic sourceUrl = null, core::int position = null}) → void
      : spa::SpanScanner::_sourceFile = new file3::SourceFile::fromString(string, url: sourceUrl), super str::StringScanner::•(string, sourceUrl: sourceUrl, position: position)
      ;
    get line() → core::int
      return this.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::getLine}(this.{str::StringScanner::position});
    get column() → core::int
      return this.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::getColumn}(this.{str::StringScanner::position});
    get state() → lin::LineScannerState
      return new spa::_SpanScannerState::•(this, this.{str::StringScanner::position});
    set state(lin::LineScannerState state) → void {
      if(!(state is spa::_SpanScannerState) || !core::identical((state as spa::_SpanScannerState).{spa::_SpanScannerState::_scanner}, this)) {
        throw new core::ArgumentError::•("The given LineScannerState was not returned by this LineScanner.");
      }
      this.{str::StringScanner::position} = state.{lin::LineScannerState::position};
    }
    get lastSpan() → file3::FileSpan {
      if(this.{str::StringScanner::lastMatch}.{core::Object::==}(null))
        this.{spa::SpanScanner::_lastSpan} = null;
      return this.{spa::SpanScanner::_lastSpan};
    }
    get location() → file3::FileLocation
      return this.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::location}(this.{str::StringScanner::position});
    get emptySpan() → file3::FileSpan
      return this.{spa::SpanScanner::location}.{file3::FileLocation::pointSpan}();
    static factory eager(core::String string, {dynamic sourceUrl, core::int position}) → spa::SpanScanner
      let dynamic #redirecting_factory = eag::EagerSpanScanner::• in invalid-expression;
    static factory within(file3::FileSpan span) → spa::SpanScanner
      let dynamic #redirecting_factory = rel::RelativeSpanScanner::• in invalid-expression;
    method spanFrom(lin::LineScannerState startState, [lin::LineScannerState endState = null]) → file3::FileSpan {
      core::int endPosition = endState.{core::Object::==}(null) ?{core::int} this.{str::StringScanner::position} : endState.{lin::LineScannerState::position};
      return this.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::span}(startState.{lin::LineScannerState::position}, endPosition);
    }
    method matches(core::Pattern pattern) → core::bool {
      if(!super.{str::StringScanner::matches}(pattern)) {
        this.{spa::SpanScanner::_lastSpan} = null;
        return false;
      }
      this.{spa::SpanScanner::_lastSpan} = this.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::span}(this.{str::StringScanner::position}, this.{str::StringScanner::lastMatch}.{core::Match::end});
      return true;
    }
    method error(core::String message, {core::Match match = null, core::int position = null, core::int length = null}) → void {
      uti4::validateErrorArgs(this.{str::StringScanner::string}, match, position, length);
      if(match.{core::Object::==}(null) && position.{core::num::==}(null) && length.{core::num::==}(null))
        match = this.{str::StringScanner::lastMatch};
      if(position.{core::num::==}(null)) {
        position = match.{core::Object::==}(null) ?{core::int} this.{str::StringScanner::position} : match.{core::Match::start};
      }
      if(length.{core::num::==}(null))
        length = match.{core::Object::==}(null) ?{core::int} 0 : match.{core::Match::end}.{core::num::-}(match.{core::Match::start});
      file3::FileSpan span = this.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::span}(position, position.{core::num::+}(length));
      throw new exc2::StringScannerException::•(message, span, this.{str::StringScanner::string});
    }
  }
  class _SpanScannerState extends core::Object implements lin::LineScannerState {
    final field spa::SpanScanner _scanner;
    final field core::int position;
    constructor •(spa::SpanScanner _scanner, core::int position) → void
      : spa::_SpanScannerState::_scanner = _scanner, spa::_SpanScannerState::position = position, super core::Object::•()
      ;
    get line() → core::int
      return this.{spa::_SpanScannerState::_scanner}.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::getLine}(this.{spa::_SpanScannerState::position});
    get column() → core::int
      return this.{spa::_SpanScannerState::_scanner}.{spa::SpanScanner::_sourceFile}.{file3::SourceFile::getColumn}(this.{spa::_SpanScannerState::position});
  }
}
library from "package:string_scanner/src/string_scanner.dart" as str {
  import "package:charcode/charcode.dart";
  import "package:meta/meta.dart";
  import "package:source_span/source_span.dart";
  import "package:string_scanner/src/exception.dart";
  import "package:string_scanner/src/utils.dart";
  class StringScanner extends core::Object {
    final field core::Uri sourceUrl;
    final field core::String string;
    field core::int _position = 0;
    field core::Match _lastMatch = null;
    field core::int _lastMatchPosition = null;
    constructor •(core::String string, {dynamic sourceUrl = null, core::int position = null}) → void
      : str::StringScanner::string = string, str::StringScanner::sourceUrl = (sourceUrl is core::String ?{dynamic} core::Uri::parse(sourceUrl{core::String}) : sourceUrl) as{TypeError} core::Uri, super core::Object::•() {
      if(!position.{core::num::==}(null))
        this.{str::StringScanner::position} = position;
    }
    get position() → core::int
      return this.{str::StringScanner::_position};
    set position(core::int position) → void {
      if(position.{core::num::<}(0) || position.{core::num::>}(this.{str::StringScanner::string}.{core::String::length})) {
        throw new core::ArgumentError::•("Invalid position ${position}");
      }
      this.{str::StringScanner::_position} = position;
      this.{str::StringScanner::_lastMatch} = null;
    }
    get lastMatch() → core::Match {
      if(!this.{str::StringScanner::_position}.{core::num::==}(this.{str::StringScanner::_lastMatchPosition}))
        this.{str::StringScanner::_lastMatch} = null;
      return this.{str::StringScanner::_lastMatch};
    }
    get rest() → core::String
      return this.{str::StringScanner::string}.{core::String::substring}(this.{str::StringScanner::position});
    get isDone() → core::bool
      return this.{str::StringScanner::position}.{core::num::==}(this.{str::StringScanner::string}.{core::String::length});
    method readChar() → core::int {
      if(this.{str::StringScanner::isDone})
        this.{str::StringScanner::_fail}("more input");
      return this.{str::StringScanner::string}.{core::String::codeUnitAt}(let final core::int #t615 = this.{str::StringScanner::_position} in let final core::int #t616 = this.{str::StringScanner::_position} = #t615.{core::num::+}(1) in #t615);
    }
    method peekChar([core::int offset = null]) → core::int {
      if(offset.{core::num::==}(null))
        offset = 0;
      core::int index = this.{str::StringScanner::position}.{core::num::+}(offset);
      if(index.{core::num::<}(0) || index.{core::num::>=}(this.{str::StringScanner::string}.{core::String::length}))
        return null;
      return this.{str::StringScanner::string}.{core::String::codeUnitAt}(index);
    }
    method scanChar(core::int character) → core::bool {
      if(this.{str::StringScanner::isDone})
        return false;
      if(!this.{str::StringScanner::string}.{core::String::codeUnitAt}(this.{str::StringScanner::_position}).{core::num::==}(character))
        return false;
      this.{str::StringScanner::_position} = this.{str::StringScanner::_position}.{core::num::+}(1);
      return true;
    }
    method expectChar(core::int character, {core::String name = null}) → void {
      if(this.{str::StringScanner::scanChar}(character))
        return;
      if(name.{core::String::==}(null)) {
        if(character.{core::num::==}(dol::$backslash)) {
          name = "\"\\\"";
        }
        else
          if(character.{core::num::==}(dol::$double_quote)) {
            name = "\"\\\"\"";
          }
          else {
            name = "\"${core::String::fromCharCode(character)}\"";
          }
      }
      this.{str::StringScanner::_fail}(name);
    }
    method scan(core::Pattern pattern) → core::bool {
      core::bool success = this.{str::StringScanner::matches}(pattern);
      if(success) {
        this.{str::StringScanner::_position} = this.{str::StringScanner::_lastMatch}.{core::Match::end};
        this.{str::StringScanner::_lastMatchPosition} = this.{str::StringScanner::_position};
      }
      return success;
    }
    method expect(core::Pattern pattern, {core::String name = null}) → void {
      if(this.{str::StringScanner::scan}(pattern))
        return;
      if(name.{core::String::==}(null)) {
        if(pattern is core::RegExp) {
          core::String source = pattern{core::RegExp}.{core::RegExp::pattern};
          if(!str::_slashAutoEscape)
            source = source.{core::String::replaceAll}("/", "\\/");
          name = "/${source}/";
        }
        else {
          name = pattern.{core::Object::toString}().{core::String::replaceAll}("\\", "\\\\").{core::String::replaceAll}("\"", "\\\"");
          name = "\"${name}\"";
        }
      }
      this.{str::StringScanner::_fail}(name);
    }
    method expectDone() → void {
      if(this.{str::StringScanner::isDone})
        return;
      this.{str::StringScanner::_fail}("no more input");
    }
    method matches(core::Pattern pattern) → core::bool {
      this.{str::StringScanner::_lastMatch} = pattern.{core::Pattern::matchAsPrefix}(this.{str::StringScanner::string}, this.{str::StringScanner::position});
      this.{str::StringScanner::_lastMatchPosition} = this.{str::StringScanner::_position};
      return !this.{str::StringScanner::_lastMatch}.{core::Object::==}(null);
    }
    method substring(core::int start, [core::int end = null]) → core::String {
      if(end.{core::num::==}(null))
        end = this.{str::StringScanner::position};
      return this.{str::StringScanner::string}.{core::String::substring}(start, end);
    }
    @meta::alwaysThrows
    method error(core::String message, {core::Match match = null, core::int position = null, core::int length = null}) → void {
      uti4::validateErrorArgs(this.{str::StringScanner::string}, match, position, length);
      if(match.{core::Object::==}(null) && position.{core::num::==}(null) && length.{core::num::==}(null))
        match = this.{str::StringScanner::lastMatch};
      if(position.{core::num::==}(null)) {
        position = match.{core::Object::==}(null) ?{core::int} this.{str::StringScanner::position} : match.{core::Match::start};
      }
      if(length.{core::num::==}(null))
        length = match.{core::Object::==}(null) ?{core::int} 0 : match.{core::Match::end}.{core::num::-}(match.{core::Match::start});
      file3::SourceFile sourceFile = new file3::SourceFile::fromString(this.{str::StringScanner::string}, url: this.{str::StringScanner::sourceUrl});
      file3::FileSpan span = sourceFile.{file3::SourceFile::span}(position, position.{core::num::+}(length));
      throw new exc2::StringScannerException::•(message, span, this.{str::StringScanner::string});
    }
    method _fail(core::String name) → void {
      this.{str::StringScanner::error}("expected ${name}.", position: this.{str::StringScanner::position}, length: 0);
    }
  }
  static final field core::bool _slashAutoEscape = core::RegExp::•("/").{core::RegExp::pattern}.{core::String::==}("\\/");
}
library http_server.http_body from "package:http_server/src/http_body.dart" as htt7 {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:http_server/src/http_body_impl.dart";
  class HttpBodyHandler extends asy::StreamTransformerBase<_ht::HttpRequest, htt7::HttpRequestBody> {
    field htt8::HttpBodyHandlerTransformer _transformer;
    constructor •({con2::Encoding defaultEncoding = con2::utf8}) → void
      : htt7::HttpBodyHandler::_transformer = new htt8::HttpBodyHandlerTransformer::•(defaultEncoding), super asy::StreamTransformerBase::•()
      ;
    static method processRequest(_ht::HttpRequest request, {con2::Encoding defaultEncoding = con2::utf8}) → asy::Future<htt7::HttpRequestBody> {
      return htt8::HttpBodyHandlerImpl::processRequest(request, defaultEncoding);
    }
    static method processResponse(_ht::HttpClientResponse response, {con2::Encoding defaultEncoding = con2::utf8}) → asy::Future<htt7::HttpClientResponseBody> {
      return htt8::HttpBodyHandlerImpl::processResponse(response, defaultEncoding);
    }
    method bind(generic-covariant-impl asy::Stream<_ht::HttpRequest> stream) → asy::Stream<htt7::HttpRequestBody> {
      return this.{htt7::HttpBodyHandler::_transformer}.{htt8::HttpBodyHandlerTransformer::bind}(stream);
    }
  }
  abstract class HttpBody extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get type() → core::String;
    abstract get body() → dynamic;
  }
  abstract class HttpClientResponseBody extends htt7::HttpBody {
    synthetic constructor •() → void
      : super htt7::HttpBody::•()
      ;
    abstract get response() → _ht::HttpClientResponse;
  }
  abstract class HttpRequestBody extends htt7::HttpBody {
    synthetic constructor •() → void
      : super htt7::HttpBody::•()
      ;
    abstract get request() → _ht::HttpRequest;
  }
  abstract class HttpBodyFileUpload extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get filename() → core::String;
    abstract get contentType() → _ht::ContentType;
    abstract get content() → dynamic;
  }
}
library http_server.http_multipart_form_data from "package:http_server/src/http_multipart_form_data.dart" as htt4 {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:mime/mime.dart";
  import "package:http_server/src/http_multipart_form_data_impl.dart";
  abstract class HttpMultipartFormData extends core::Object implements asy::Stream<dynamic> {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get contentType() → _ht::ContentType;
    abstract get contentDisposition() → _ht::HeaderValue;
    abstract get contentTransferEncoding() → _ht::HeaderValue;
    abstract get isText() → core::bool;
    abstract get isBinary() → core::bool;
    abstract method value(core::String name) → core::String;
    static method parse(sha::MimeMultipart multipart, {con2::Encoding defaultEncoding = con2::utf8}) → htt4::HttpMultipartFormData
      return htt9::HttpMultipartFormDataImpl::parse(multipart, defaultEncoding);
  }
}
library http_server.virtual_directory from "package:http_server/src/virtual_directory.dart" as vir {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:mime/mime.dart";
  import "package:path/path.dart";
  typedef _DirCallback = (io::Directory, _ht::HttpRequest) → dynamic;
  typedef _ErrorCallback = (_ht::HttpRequest) → dynamic;
  class _DirectoryRedirect extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
  }
  class VirtualDirectory extends core::Object {
    final field core::String root;
    field core::bool allowDirectoryListing = false;
    field core::bool followLinks = true;
    field core::bool jailRoot = true;
    final field core::List<core::String> _pathPrefixSegments;
    final field core::RegExp _invalidPathRegExp = core::RegExp::•("[\\/\u0000]");
    field (_ht::HttpRequest) → dynamic _errorCallback = null;
    field (io::Directory, _ht::HttpRequest) → dynamic _dirCallback = null;
    constructor •(core::String root, {core::String pathPrefix = null}) → void
      : vir::VirtualDirectory::root = root, vir::VirtualDirectory::_pathPrefixSegments = vir::VirtualDirectory::_parsePathPrefix(pathPrefix), super core::Object::•()
      ;
    static method _parsePathPrefix(core::String pathPrefix) → core::List<core::String> {
      if(pathPrefix.{core::String::==}(null))
        return <core::String>[];
      return core::_Uri::•(path: pathPrefix).{core::Uri::pathSegments}.{core::Iterable::where}((core::String segment) → core::bool => segment.{core::String::isNotEmpty}).{core::Iterable::toList}();
    }
    method serve(asy::Stream<_ht::HttpRequest> requests) → asy::StreamSubscription<_ht::HttpRequest>
      return requests.{asy::Stream::listen}(this.{vir::VirtualDirectory::serveRequest});
    method serveRequest(_ht::HttpRequest request) → asy::Future<dynamic> {
      core::Iterator<core::String> iterator = request.{_ht::HttpRequest::uri}.{core::Uri::pathSegments}.{core::Iterable::iterator};
      for (core::String segment in this.{vir::VirtualDirectory::_pathPrefixSegments}) {
        if(!iterator.{core::Iterator::moveNext}() || !iterator.{core::Iterator::current}.{core::String::==}(segment)) {
          this.{vir::VirtualDirectory::_serveErrorPage}(_ht::HttpStatus::notFound, request);
          return request.{_ht::HttpRequest::response}.{io::IOSink::done};
        }
      }
      return this.{vir::VirtualDirectory::_locateResource}(".", let final core::Iterator<core::String> #t617 = iterator in let final dynamic #t618 = #t617.{core::Iterator::moveNext}() in #t617).{asy::Future::then}<dynamic>((dynamic entity) → asy::Future<dynamic> {
        if(entity is io::File) {
          this.{vir::VirtualDirectory::serveFile}(entity{io::File}, request);
        }
        else
          if(entity is io::Directory) {
            if(this.{vir::VirtualDirectory::allowDirectoryListing}) {
              this.{vir::VirtualDirectory::_serveDirectory}(entity{io::Directory}, request);
            }
            else {
              this.{vir::VirtualDirectory::_serveErrorPage}(_ht::HttpStatus::notFound, request);
            }
          }
          else
            if(entity is vir::_DirectoryRedirect) {
              request.{_ht::HttpRequest::response}.{_ht::HttpResponse::redirect}(core::Uri::parse("${request.{_ht::HttpRequest::uri}}/"), status: _ht::HttpStatus::movedPermanently);
            }
            else {
              assert(entity.{core::Object::==}(null));
              this.{vir::VirtualDirectory::_serveErrorPage}(_ht::HttpStatus::notFound, request);
            }
        return request.{_ht::HttpRequest::response}.{io::IOSink::done};
      });
    }
    set directoryHandler((io::Directory, _ht::HttpRequest) → void callback) → void {
      this.{vir::VirtualDirectory::_dirCallback} = callback;
    }
    set errorPageHandler((_ht::HttpRequest) → void callback) → void {
      this.{vir::VirtualDirectory::_errorCallback} = callback;
    }
    method _locateResource(core::String path, core::Iterator<core::String> segments) → asy::Future<dynamic> {
      if(segments.{core::Iterator::current}.{core::String::==}(".."))
        return asy::Future::value<dynamic>(null);
      path = path::normalize(path);
      if(this.{vir::VirtualDirectory::jailRoot} && path::split(path).{core::Iterable::first}.{core::String::==}(".."))
        return asy::Future::value<dynamic>(null);
      function fullPath() → core::String
        return path::join(this.{vir::VirtualDirectory::root}, path);
      return io::FileSystemEntity::type(fullPath.call(), followLinks: false).{asy::Future::then}<dynamic>((io::FileSystemEntityType type) → core::Object {
        #L97:
        switch(type) {
          #L98:
          case io::FileSystemEntityType::file:
            {
              if(segments.{core::Iterator::current}.{core::String::==}(null)) {
                return io::File::•(fullPath.call());
              }
              break #L97;
            }
          #L99:
          case io::FileSystemEntityType::directory:
            {
              function dirFullPath() → core::String
                return "${fullPath.call()}${path::separator}";
              core::String current = segments.{core::Iterator::current};
              if(current.{core::String::==}(null)) {
                if(path.{core::String::==}("."))
                  return io::Directory::•(dirFullPath.call());
                return const vir::_DirectoryRedirect::•();
              }
              core::bool hasNext = segments.{core::Iterator::moveNext}();
              if(!hasNext && current.{core::String::==}("")) {
                return io::Directory::•(dirFullPath.call());
              }
              else {
                if(this.{vir::VirtualDirectory::_invalidPathRegExp}.{core::RegExp::hasMatch}(current))
                  break #L97;
                return this.{vir::VirtualDirectory::_locateResource}(path::join(path, current), segments);
              }
              break #L97;
            }
          #L100:
          case io::FileSystemEntityType::link:
            {
              if(this.{vir::VirtualDirectory::followLinks}) {
                return io::Link::•(fullPath.call()).{io::Link::target}().{asy::Future::then}<dynamic>((core::String target) → asy::Future<dynamic> {
                  core::String targetPath = path::normalize(target);
                  if(path::isAbsolute(targetPath)) {
                    if(this.{vir::VirtualDirectory::jailRoot})
                      return null;
                    return this.{vir::VirtualDirectory::_locateResource}(targetPath, segments);
                  }
                  else {
                    targetPath = path::join(path::dirname(path), targetPath);
                    return this.{vir::VirtualDirectory::_locateResource}(targetPath, segments);
                  }
                });
              }
              break #L97;
            }
        }
        return null;
      });
    }
    method serveFile(io::File file, _ht::HttpRequest request) → void {
      _ht::HttpResponse response = request.{_ht::HttpRequest::response};
      file.{io::File::lastModified}().{asy::Future::then}<dynamic>((core::DateTime lastModified) → asy::Future<dynamic> {
        if(!request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::ifModifiedSince}.{core::DateTime::==}(null) && !lastModified.{core::DateTime::isAfter}(request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::ifModifiedSince})) {
          response.{_ht::HttpResponse::statusCode} = _ht::HttpStatus::notModified;
          response.{io::IOSink::close}();
          return null;
        }
        response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}(_ht::HttpHeaders::lastModifiedHeader, lastModified);
        response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}(_ht::HttpHeaders::acceptRangesHeader, "bytes");
        return file.{io::File::length}().{asy::Future::then}<dynamic>((core::int length) → core::Null {
          core::String range = request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::value}(_ht::HttpHeaders::rangeHeader);
          if(!range.{core::String::==}(null)) {
            core::Match matches = core::RegExp::•("^bytes=(\\d*)\\-(\\d*)\$").{core::RegExp::firstMatch}(range);
            if(!matches.{core::Object::==}(null) && (matches.{core::Match::[]}(1).{core::String::isNotEmpty} || matches.{core::Match::[]}(2).{core::String::isNotEmpty})) {
              core::int start;
              core::int end;
              if(matches.{core::Match::[]}(1).{core::String::isEmpty}) {
                start = length.{core::num::-}(core::int::parse(matches.{core::Match::[]}(2)));
                if(start.{core::num::<}(0))
                  start = 0;
                end = length.{core::num::-}(1);
              }
              else {
                start = core::int::parse(matches.{core::Match::[]}(1));
                end = matches.{core::Match::[]}(2).{core::String::isEmpty} ?{core::int} length.{core::num::-}(1) : core::int::parse(matches.{core::Match::[]}(2));
              }
              if(start.{core::num::<=}(end)) {
                if(end.{core::num::>=}(length)) {
                  end = length.{core::num::-}(1);
                }
                if(start.{core::num::>=}(length)) {
                  let final _ht::HttpResponse #t619 = response in let final dynamic #t620 = #t619.{_ht::HttpResponse::statusCode} = _ht::HttpStatus::requestedRangeNotSatisfiable in let final dynamic #t621 = #t619.{io::IOSink::close}() in #t619;
                  return;
                }
                response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}(_ht::HttpHeaders::contentLengthHeader, end.{core::num::-}(start).{core::num::+}(1));
                let final _ht::HttpResponse #t622 = response in let final dynamic #t623 = #t622.{_ht::HttpResponse::statusCode} = _ht::HttpStatus::partialContent in let final dynamic #t624 = #t622.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}(_ht::HttpHeaders::contentRangeHeader, "bytes ${start}-${end}/${length}") in #t622;
                if(request.{_ht::HttpRequest::method}.{core::String::==}("HEAD")) {
                  response.{io::IOSink::close}();
                }
                else {
                  file.{io::File::openRead}(start, end.{core::num::+}(1)).{asy::Stream::pipe}(new vir::_VirtualDirectoryFileStream::•(response, file.{io::File::path})).{asy::Future::catchError}((dynamic _) → core::Null {});
                }
                return;
              }
            }
          }
          response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}(_ht::HttpHeaders::contentLengthHeader, length);
          if(request.{_ht::HttpRequest::method}.{core::String::==}("HEAD")) {
            response.{io::IOSink::close}();
          }
          else {
            file.{io::File::openRead}().{asy::Stream::pipe}(new vir::_VirtualDirectoryFileStream::•(response, file.{io::File::path})).{asy::Future::catchError}((dynamic _) → core::Null {});
          }
        });
      }).{asy::Future::catchError}((dynamic _) → core::Null {
        response.{_ht::HttpResponse::statusCode} = _ht::HttpStatus::notFound;
        response.{io::IOSink::close}();
      });
    }
    method _serveDirectory(io::Directory dir, _ht::HttpRequest request) → void {
      if(!this.{vir::VirtualDirectory::_dirCallback}.{core::Object::==}(null)) {
        this.{vir::VirtualDirectory::_dirCallback}(dir, request);
        return;
      }
      _ht::HttpResponse response = request.{_ht::HttpRequest::response};
      dir.{io::FileSystemEntity::stat}().{asy::Future::then}<dynamic>((io::FileStat stats) → core::Null {
        if(!request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::ifModifiedSince}.{core::DateTime::==}(null) && !stats.{io::FileStat::modified}.{core::DateTime::isAfter}(request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::ifModifiedSince})) {
          response.{_ht::HttpResponse::statusCode} = _ht::HttpStatus::notModified;
          response.{io::IOSink::close}();
          return;
        }
        response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::contentType} = _ht::ContentType::•("text", "html", parameters: <core::String, core::String>{"charset": "utf-8"});
        response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::set}(_ht::HttpHeaders::lastModifiedHeader, stats.{io::FileStat::modified});
        core::String path = core::Uri::decodeComponent(request.{_ht::HttpRequest::uri}.{core::Uri::path});
        core::String encodedPath = const con2::HtmlEscape::•().{con2::HtmlEscape::convert}(path);
        core::String header = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<title>Index of ${encodedPath}</title>\n</head>\n<body>\n<h1>Index of ${encodedPath}</h1>\n<table>\n  <tr>\n    <td>Name</td>\n    <td>Last modified</td>\n    <td>Size</td>\n  </tr>\n";
        core::String server = response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::value}(_ht::HttpHeaders::serverHeader);
        server.{core::String::==}(null) ?{core::String} server = "" : null;
        core::String footer = "</table>\n${server}\n</body>\n</html>\n";
        response.{io::IOSink::write}(header);
        function add(core::String name, core::String modified, dynamic size, core::bool folder) → void {
          size.{core::Object::==}(null) ?{dynamic} size = "-" : null;
          modified.{core::String::==}(null) ?{core::String} modified = "" : null;
          core::String encodedSize = const con2::HtmlEscape::•().{con2::HtmlEscape::convert}(size.{core::Object::toString}());
          core::String encodedModified = const con2::HtmlEscape::•().{con2::HtmlEscape::convert}(modified);
          core::String encodedLink = const con2::HtmlEscape::•(con2::HtmlEscapeMode::attribute).{con2::HtmlEscape::convert}(core::Uri::encodeComponent(name));
          if(folder) {
            encodedLink = encodedLink.{core::String::+}("/");
            name = name.{core::String::+}("/");
          }
          core::String encodedName = const con2::HtmlEscape::•().{con2::HtmlEscape::convert}(name);
          core::String entry = "  <tr>\n    <td><a href=\"${encodedLink}\">${encodedName}</a></td>\n    <td>${encodedModified}</td>\n    <td style=\"text-align: right\">${encodedSize}</td>\n  </tr>";
          response.{io::IOSink::write}(entry);
        }
        if(!path.{core::String::==}("/")) {
          add.call("..", null, null, true);
        }
        dir.{io::Directory::list}(followLinks: true).{asy::Stream::listen}((io::FileSystemEntity entity) → core::Null {
          core::String name = path::basename(entity.{io::FileSystemEntity::path});
          io::FileStat stat = entity.{io::FileSystemEntity::statSync}();
          if(entity is io::File) {
            add.call(name, stat.{io::FileStat::modified}.{core::DateTime::toString}(), stat.{io::FileStat::size}, false);
          }
          else
            if(entity is io::Directory) {
              add.call(name, stat.{io::FileStat::modified}.{core::DateTime::toString}(), null, true);
            }
        }, onError: (dynamic e) → core::Null {}, onDone: () → core::Null {
          response.{io::IOSink::write}(footer);
          response.{io::IOSink::close}();
        });
      }, onError: (dynamic e) → core::Null {
        response.{io::IOSink::close}();
      });
    }
    method _serveErrorPage(core::int error, _ht::HttpRequest request) → void {
      _ht::HttpResponse response = request.{_ht::HttpRequest::response};
      response.{_ht::HttpResponse::statusCode} = error;
      if(!this.{vir::VirtualDirectory::_errorCallback}.{core::Object::==}(null)) {
        this.{vir::VirtualDirectory::_errorCallback}(request);
        return;
      }
      response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::contentType} = _ht::ContentType::•("text", "html", parameters: <core::String, core::String>{"charset": "utf-8"});
      core::String path = core::Uri::decodeComponent(request.{_ht::HttpRequest::uri}.{core::Uri::path});
      core::String encodedPath = const con2::HtmlEscape::•().{con2::HtmlEscape::convert}(path);
      core::String encodedReason = const con2::HtmlEscape::•().{con2::HtmlEscape::convert}(response.{_ht::HttpResponse::reasonPhrase});
      core::String encodedError = const con2::HtmlEscape::•().{con2::HtmlEscape::convert}(error.{core::int::toString}());
      core::String server = response.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::value}(_ht::HttpHeaders::serverHeader);
      server.{core::String::==}(null) ?{core::String} server = "" : null;
      core::String page = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<title>${encodedReason}: ${encodedPath}</title>\n</head>\n<body>\n<h1>Error ${encodedError} at '${encodedPath}': ${encodedReason}</h1>\n${server}\n</body>\n</html>";
      response.{io::IOSink::write}(page);
      response.{io::IOSink::close}();
    }
  }
  class _VirtualDirectoryFileStream extends asy::StreamConsumer<core::List<core::int>> {
    final field _ht::HttpResponse response;
    final field core::String path;
    field core::List<core::int> buffer = <core::int>[];
    constructor •(_ht::HttpResponse response, core::String path) → void
      : vir::_VirtualDirectoryFileStream::response = response, vir::_VirtualDirectoryFileStream::path = path, super asy::StreamConsumer::•()
      ;
    method addStream(generic-covariant-impl asy::Stream<core::List<core::int>> stream) → asy::Future<dynamic> {
      stream.{asy::Stream::listen}((core::List<core::int> data) → core::Null {
        if(this.{vir::_VirtualDirectoryFileStream::buffer}.{core::Object::==}(null)) {
          this.{vir::_VirtualDirectoryFileStream::response}.{io::IOSink::add}(data);
          return;
        }
        if(this.{vir::_VirtualDirectoryFileStream::buffer}.{core::Iterable::isEmpty}) {
          if(data.{core::List::length}.{core::num::>=}(mim::defaultMagicNumbersMaxLength)) {
            this.{vir::_VirtualDirectoryFileStream::setMimeType}(data);
            this.{vir::_VirtualDirectoryFileStream::response}.{io::IOSink::add}(data);
            this.{vir::_VirtualDirectoryFileStream::buffer} = null;
          }
          else {
            this.{vir::_VirtualDirectoryFileStream::buffer}.{core::List::addAll}(data);
          }
        }
        else {
          this.{vir::_VirtualDirectoryFileStream::buffer}.{core::List::addAll}(data);
          if(this.{vir::_VirtualDirectoryFileStream::buffer}.{core::List::length}.{core::num::>=}(mim::defaultMagicNumbersMaxLength)) {
            this.{vir::_VirtualDirectoryFileStream::setMimeType}(this.{vir::_VirtualDirectoryFileStream::buffer});
            this.{vir::_VirtualDirectoryFileStream::response}.{io::IOSink::add}(this.{vir::_VirtualDirectoryFileStream::buffer});
            this.{vir::_VirtualDirectoryFileStream::buffer} = null;
          }
        }
      }, onDone: () → core::Null {
        if(!this.{vir::_VirtualDirectoryFileStream::buffer}.{core::Object::==}(null)) {
          if(this.{vir::_VirtualDirectoryFileStream::buffer}.{core::Iterable::isEmpty}) {
            this.{vir::_VirtualDirectoryFileStream::setMimeType}(null);
          }
          else {
            this.{vir::_VirtualDirectoryFileStream::setMimeType}(this.{vir::_VirtualDirectoryFileStream::buffer});
            this.{vir::_VirtualDirectoryFileStream::response}.{io::IOSink::add}(this.{vir::_VirtualDirectoryFileStream::buffer});
          }
        }
        this.{vir::_VirtualDirectoryFileStream::response}.{io::IOSink::close}();
      }, onError: this.{vir::_VirtualDirectoryFileStream::response}.{io::IOSink::addError});
      return this.{vir::_VirtualDirectoryFileStream::response}.{io::IOSink::done};
    }
    method close() → asy::Future<dynamic>
      return asy::Future::value<dynamic>();
    method setMimeType(core::List<core::int> bytes) → void {
      core::String mimeType = mim::lookupMimeType(this.{vir::_VirtualDirectoryFileStream::path}, headerBytes: bytes);
      if(!mimeType.{core::String::==}(null)) {
        this.{vir::_VirtualDirectoryFileStream::response}.{_ht::HttpResponse::headers}.{_ht::HttpHeaders::contentType} = _ht::ContentType::parse(mimeType);
      }
    }
  }
}
library http_server.virtual_host from "package:http_server/src/virtual_host.dart" as vir2 {
  import "dart:async";
  import "dart:io";
  abstract class VirtualHost extends core::Object {
    abstract get unhandled() → asy::Stream<_ht::HttpRequest>;
    static factory •([asy::Stream<_ht::HttpRequest> source = null]) → vir2::VirtualHost
      return new vir2::_VirtualHost::•(source);
    abstract method addSource(asy::Stream<_ht::HttpRequest> source) → void;
    abstract method addHost(core::String host) → asy::Stream<_ht::HttpRequest>;
  }
  class _VirtualHostDomain extends core::Object {
    field asy::StreamController<_ht::HttpRequest> any = null;
    field asy::StreamController<_ht::HttpRequest> exact = null;
    field core::Map<core::String, vir2::_VirtualHostDomain> subDomains = <core::String, vir2::_VirtualHostDomain>{};
    synthetic constructor •() → void
      : super core::Object::•()
      ;
  }
  class _VirtualHost extends core::Object implements vir2::VirtualHost {
    final field vir2::_VirtualHostDomain _topDomain = new vir2::_VirtualHostDomain::•();
    field asy::StreamController<_ht::HttpRequest> _unhandledController = null;
    constructor •([asy::Stream<_ht::HttpRequest> source = null]) → void
      : super core::Object::•() {
      if(!source.{core::Object::==}(null))
        this.{vir2::_VirtualHost::addSource}(source);
    }
    get unhandled() → asy::Stream<_ht::HttpRequest> {
      this.{vir2::_VirtualHost::_unhandledController}.{core::Object::==}(null) ?{asy::StreamController<_ht::HttpRequest>} this.{vir2::_VirtualHost::_unhandledController} = asy::StreamController::•<_ht::HttpRequest>() : null;
      return this.{vir2::_VirtualHost::_unhandledController}.{asy::StreamController::stream};
    }
    method addSource(asy::Stream<_ht::HttpRequest> source) → void {
      source.{asy::Stream::listen}((_ht::HttpRequest request) → core::Null {
        core::String host = request.{_ht::HttpRequest::headers}.{_ht::HttpHeaders::host};
        if(host.{core::String::==}(null)) {
          this.{vir2::_VirtualHost::_unhandled}(request);
          return;
        }
        core::List<core::String> domains = host.{core::String::split}(".");
        vir2::_VirtualHostDomain current = this.{vir2::_VirtualHost::_topDomain};
        asy::StreamController<dynamic> any;
        #L101:
        for (core::int i = domains.{core::List::length}.{core::num::-}(1); i.{core::num::>=}(0); i = i.{core::num::-}(1)) {
          if(!current.{vir2::_VirtualHostDomain::any}.{core::Object::==}(null))
            any = current.{vir2::_VirtualHostDomain::any};
          if(i.{core::num::==}(0)) {
            vir2::_VirtualHostDomain last = current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::[]}(domains.{core::List::[]}(i));
            if(!last.{core::Object::==}(null) && !last.{vir2::_VirtualHostDomain::exact}.{core::Object::==}(null)) {
              last.{vir2::_VirtualHostDomain::exact}.{asy::StreamController::add}(request);
              return;
            }
          }
          else {
            if(!current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::containsKey}(domains.{core::List::[]}(i))) {
              break #L101;
            }
            current = current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::[]}(domains.{core::List::[]}(i));
          }
        }
        if(!any.{core::Object::==}(null)) {
          any.{asy::StreamController::add}(request);
          return;
        }
        this.{vir2::_VirtualHost::_unhandled}(request);
      });
    }
    method addHost(core::String host) → asy::Stream<_ht::HttpRequest> {
      if(host.{core::String::lastIndexOf}("*").{core::num::>}(0)) {
        throw new core::ArgumentError::•("Wildcards are only allowed in the beginning of a host");
      }
      asy::StreamController<_ht::HttpRequest> controller = asy::StreamController::•<_ht::HttpRequest>();
      core::List<core::String> domains = host.{core::String::split}(".");
      vir2::_VirtualHostDomain current = this.{vir2::_VirtualHost::_topDomain};
      for (core::int i = domains.{core::List::length}.{core::num::-}(1); i.{core::num::>=}(0); i = i.{core::num::-}(1)) {
        if(domains.{core::List::[]}(i).{core::String::==}("*")) {
          if(!current.{vir2::_VirtualHostDomain::any}.{core::Object::==}(null)) {
            throw new core::ArgumentError::•("Host is already provided");
          }
          current.{vir2::_VirtualHostDomain::any} = controller;
        }
        else {
          if(!current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::containsKey}(domains.{core::List::[]}(i))) {
            current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::[]=}(domains.{core::List::[]}(i), new vir2::_VirtualHostDomain::•());
          }
          if(i.{core::num::>}(0)) {
            current = current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::[]}(domains.{core::List::[]}(i));
          }
          else {
            if(!current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::[]}(domains.{core::List::[]}(i)).{vir2::_VirtualHostDomain::exact}.{core::Object::==}(null)) {
              throw new core::ArgumentError::•("Host is already provided");
            }
            current.{vir2::_VirtualHostDomain::subDomains}.{core::Map::[]}(domains.{core::List::[]}(i)).{vir2::_VirtualHostDomain::exact} = controller;
          }
        }
      }
      return controller.{asy::StreamController::stream};
    }
    method _unhandled(_ht::HttpRequest request) → void {
      if(!this.{vir2::_VirtualHost::_unhandledController}.{core::Object::==}(null)) {
        this.{vir2::_VirtualHost::_unhandledController}.{asy::StreamController::add}(request);
        return;
      }
      request.{_ht::HttpRequest::response}.{_ht::HttpResponse::statusCode} = _ht::HttpStatus::forbidden;
      request.{_ht::HttpRequest::response}.{io::IOSink::close}();
    }
  }
}
library from "package:body_parser/src/get_value.dart" as get {
  import "package:dart2_constant/convert.dart";
  static method getValue(core::String value) → dynamic {
    try {
      core::num numValue = core::num::parse(value);
      if(!numValue.{core::num::isNaN})
        return numValue;
      else
        return value;
    }
    on core::FormatException catch(no-exception-var) {
      if(value.{core::String::startsWith}("[") && value.{core::String::endsWith}("]"))
        return con4::json.{con2::JsonCodec::decode}(value);
      else
        if(value.{core::String::startsWith}("{") && value.{core::String::endsWith}("}"))
          return con4::json.{con2::JsonCodec::decode}(value);
        else
          if(value.{core::String::trim}().{core::String::toLowerCase}().{core::String::==}("null"))
            return null;
          else
            return value;
    }
  }
}
library from "package:stack_trace/src/lazy_chain.dart" as laz {
  import "package:stack_trace/src/chain.dart";
  import "package:stack_trace/src/frame.dart";
  import "package:stack_trace/src/lazy_trace.dart";
  import "package:stack_trace/src/trace.dart";
  typedef ChainThunk = () → cha3::Chain;
  class LazyChain extends core::Object implements cha3::Chain {
    final field () → cha3::Chain _thunk;
    field cha3::Chain _inner = null;
    constructor •(() → cha3::Chain _thunk) → void
      : laz::LazyChain::_thunk = _thunk, super core::Object::•()
      ;
    get _chain() → cha3::Chain {
      if(this.{laz::LazyChain::_inner}.{core::Object::==}(null))
        this.{laz::LazyChain::_inner} = this.{laz::LazyChain::_thunk}();
      return this.{laz::LazyChain::_inner};
    }
    get traces() → core::List<tra::Trace>
      return this.{laz::LazyChain::_chain}.{cha3::Chain::traces};
    get terse() → cha3::Chain
      return this.{laz::LazyChain::_chain}.{cha3::Chain::terse};
    method foldFrames((fra::Frame) → core::bool predicate, {core::bool terse = false}) → cha3::Chain
      return new laz::LazyChain::•(() → cha3::Chain => this.{laz::LazyChain::_chain}.{cha3::Chain::foldFrames}(predicate, terse: terse));
    method toTrace() → tra::Trace
      return new laz2::LazyTrace::•(() → tra::Trace => this.{laz::LazyChain::_chain}.{cha3::Chain::toTrace}());
    method toString() → core::String
      return this.{laz::LazyChain::_chain}.{cha3::Chain::toString}();
  }
}
library from "package:stack_trace/src/stack_zone_specification.dart" as sta2 {
  import "dart:async";
  import "package:stack_trace/src/chain.dart";
  import "package:stack_trace/src/lazy_chain.dart";
  import "package:stack_trace/src/lazy_trace.dart";
  import "package:stack_trace/src/trace.dart";
  import "package:stack_trace/src/utils.dart";
  typedef _ChainHandler = (dynamic, cha3::Chain) → void;
  class StackZoneSpecification extends core::Object {
    static final field core::Object disableKey = new core::Object::•();
    final field core::Expando<sta2::_Node> _chains = new core::Expando::•<sta2::_Node>("stack chains");
    final field (dynamic, cha3::Chain) → void _onError;
    field sta2::_Node _currentNode = null;
    final field core::bool _errorZone;
    constructor •((dynamic, cha3::Chain) → void _onError, {core::bool errorZone = true}) → void
      : sta2::StackZoneSpecification::_onError = _onError, sta2::StackZoneSpecification::_errorZone = errorZone, super core::Object::•()
      ;
    get _disabled() → core::bool
      return asy::Zone::current.{asy::Zone::[]}(sta2::StackZoneSpecification::disableKey).{core::Object::==}(true);
    method toSpec() → asy::ZoneSpecification {
      return new asy::_ZoneSpecification::•(handleUncaughtError: this.{sta2::StackZoneSpecification::_errorZone} ?{(asy::Zone, asy::ZoneDelegate, asy::Zone, dynamic, core::StackTrace) → void} this.{sta2::StackZoneSpecification::_handleUncaughtError} : null, registerCallback: this.{sta2::StackZoneSpecification::_registerCallback}, registerUnaryCallback: this.{sta2::StackZoneSpecification::_registerUnaryCallback}, registerBinaryCallback: this.{sta2::StackZoneSpecification::_registerBinaryCallback}, errorCallback: this.{sta2::StackZoneSpecification::_errorCallback});
    }
    method currentChain([core::int level = 0]) → cha3::Chain
      return this.{sta2::StackZoneSpecification::_createNode}(level.{core::num::+}(1)).{sta2::_Node::toChain}();
    method chainFor(core::StackTrace trace) → cha3::Chain {
      if(trace is cha3::Chain)
        return trace{cha3::Chain};
      trace.{core::Object::==}(null) ?{core::StackTrace} trace = core::StackTrace::current : null;
      sta2::_Node previous = let final sta2::_Node #t625 = this.{sta2::StackZoneSpecification::_chains}.{core::Expando::[]}(trace) in #t625.==(null) ?{sta2::_Node} this.{sta2::StackZoneSpecification::_currentNode} : #t625;
      if(previous.{core::Object::==}(null)) {
        if(trace is tra::Trace)
          return new cha3::Chain::•(<tra::Trace>[trace{tra::Trace}]);
        return new laz::LazyChain::•(() → cha3::Chain => cha3::Chain::parse(trace.{core::StackTrace::toString}()));
      }
      else {
        if(!(trace is tra::Trace)) {
          core::StackTrace original = trace;
          trace = new laz2::LazyTrace::•(() → tra::Trace => tra::Trace::parse(this.{sta2::StackZoneSpecification::_trimVMChain}(original)));
        }
        return new sta2::_Node::•(trace, previous).{sta2::_Node::toChain}();
      }
    }
    method _registerCallback<R extends core::Object = dynamic>(asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, () → sta2::StackZoneSpecification::_registerCallback::R f) → () → sta2::StackZoneSpecification::_registerCallback::R {
      if(f.{core::Object::==}(null) || this.{sta2::StackZoneSpecification::_disabled})
        return parent.{asy::ZoneDelegate::registerCallback}<sta2::StackZoneSpecification::_registerCallback::R>(zone, f);
      sta2::_Node node = this.{sta2::StackZoneSpecification::_createNode}(1);
      return parent.{asy::ZoneDelegate::registerCallback}<sta2::StackZoneSpecification::_registerCallback::R>(zone, () → sta2::StackZoneSpecification::_registerCallback::R => this.{sta2::StackZoneSpecification::_run}<sta2::StackZoneSpecification::_registerCallback::R>(f, node));
    }
    method _registerUnaryCallback<R extends core::Object = dynamic, T extends core::Object = dynamic>(asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, (sta2::StackZoneSpecification::_registerUnaryCallback::T) → sta2::StackZoneSpecification::_registerUnaryCallback::R f) → (sta2::StackZoneSpecification::_registerUnaryCallback::T) → sta2::StackZoneSpecification::_registerUnaryCallback::R {
      if(f.{core::Object::==}(null) || this.{sta2::StackZoneSpecification::_disabled})
        return parent.{asy::ZoneDelegate::registerUnaryCallback}<sta2::StackZoneSpecification::_registerUnaryCallback::R, sta2::StackZoneSpecification::_registerUnaryCallback::T>(zone, f);
      sta2::_Node node = this.{sta2::StackZoneSpecification::_createNode}(1);
      return parent.{asy::ZoneDelegate::registerUnaryCallback}<sta2::StackZoneSpecification::_registerUnaryCallback::R, sta2::StackZoneSpecification::_registerUnaryCallback::T>(zone, (sta2::StackZoneSpecification::_registerUnaryCallback::T arg) → sta2::StackZoneSpecification::_registerUnaryCallback::R {
        return this.{sta2::StackZoneSpecification::_run}<sta2::StackZoneSpecification::_registerUnaryCallback::R>(() → sta2::StackZoneSpecification::_registerUnaryCallback::R => f.call(arg), node);
      });
    }
    method _registerBinaryCallback<R extends core::Object = dynamic, T1 extends core::Object = dynamic, T2 extends core::Object = dynamic>(asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, core::Function f) → (sta2::StackZoneSpecification::_registerBinaryCallback::T1, sta2::StackZoneSpecification::_registerBinaryCallback::T2) → sta2::StackZoneSpecification::_registerBinaryCallback::R {
      if(f.{core::Function::==}(null) || this.{sta2::StackZoneSpecification::_disabled})
        return parent.{asy::ZoneDelegate::registerBinaryCallback}<sta2::StackZoneSpecification::_registerBinaryCallback::R, sta2::StackZoneSpecification::_registerBinaryCallback::T1, sta2::StackZoneSpecification::_registerBinaryCallback::T2>(zone, f as{TypeError} (sta2::StackZoneSpecification::_registerBinaryCallback::T1, sta2::StackZoneSpecification::_registerBinaryCallback::T2) → sta2::StackZoneSpecification::_registerBinaryCallback::R);
      sta2::_Node node = this.{sta2::StackZoneSpecification::_createNode}(1);
      return parent.{asy::ZoneDelegate::registerBinaryCallback}<sta2::StackZoneSpecification::_registerBinaryCallback::R, sta2::StackZoneSpecification::_registerBinaryCallback::T1, sta2::StackZoneSpecification::_registerBinaryCallback::T2>(zone, (sta2::StackZoneSpecification::_registerBinaryCallback::T1 arg1, sta2::StackZoneSpecification::_registerBinaryCallback::T2 arg2) → sta2::StackZoneSpecification::_registerBinaryCallback::R {
        return this.{sta2::StackZoneSpecification::_run}<sta2::StackZoneSpecification::_registerBinaryCallback::R>(() → sta2::StackZoneSpecification::_registerBinaryCallback::R => f.call(arg1, arg2) as{TypeError} sta2::StackZoneSpecification::_registerBinaryCallback::R, node);
      });
    }
    method _handleUncaughtError(asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, dynamic error, core::StackTrace stackTrace) → void {
      if(this.{sta2::StackZoneSpecification::_disabled}) {
        parent.{asy::ZoneDelegate::handleUncaughtError}(zone, error, stackTrace);
        return;
      }
      cha3::Chain stackChain = this.{sta2::StackZoneSpecification::chainFor}(stackTrace);
      if(this.{sta2::StackZoneSpecification::_onError}.{core::Object::==}(null)) {
        parent.{asy::ZoneDelegate::handleUncaughtError}(zone, error, stackChain);
        return;
      }
      try {
        self.{asy::Zone::parent}.{asy::Zone::runBinary}<void, dynamic, cha3::Chain>(this.{sta2::StackZoneSpecification::_onError}, error, stackChain);
      }
      on dynamic catch(final dynamic newError, final core::StackTrace newStackTrace) {
        if(core::identical(newError, error)) {
          parent.{asy::ZoneDelegate::handleUncaughtError}(zone, error, stackChain);
        }
        else {
          parent.{asy::ZoneDelegate::handleUncaughtError}(zone, newError, newStackTrace);
        }
      }
    }
    method _errorCallback(asy::Zone self, asy::ZoneDelegate parent, asy::Zone zone, core::Object error, core::StackTrace stackTrace) → asy::AsyncError {
      if(this.{sta2::StackZoneSpecification::_disabled})
        return parent.{asy::ZoneDelegate::errorCallback}(zone, error, stackTrace);
      if(stackTrace.{core::Object::==}(null)) {
        stackTrace = this.{sta2::StackZoneSpecification::_createNode}(2).{sta2::_Node::toChain}();
      }
      else {
        if(this.{sta2::StackZoneSpecification::_chains}.{core::Expando::[]}(stackTrace).{core::Object::==}(null))
          this.{sta2::StackZoneSpecification::_chains}.{core::Expando::[]=}(stackTrace, this.{sta2::StackZoneSpecification::_createNode}(2));
      }
      asy::AsyncError asyncError = parent.{asy::ZoneDelegate::errorCallback}(zone, error, stackTrace);
      return asyncError.{core::Object::==}(null) ?{asy::AsyncError} new asy::AsyncError::•(error, stackTrace) : asyncError;
    }
    method _createNode([core::int level = 0]) → sta2::_Node
      return new sta2::_Node::•(this.{sta2::StackZoneSpecification::_currentTrace}(level.{core::num::+}(1)), this.{sta2::StackZoneSpecification::_currentNode});
    method _run<T extends core::Object = dynamic>(() → sta2::StackZoneSpecification::_run::T f, sta2::_Node node) → sta2::StackZoneSpecification::_run::T {
      sta2::_Node previousNode = this.{sta2::StackZoneSpecification::_currentNode};
      this.{sta2::StackZoneSpecification::_currentNode} = node;
      try
        try {
          return f.call();
        }
        on dynamic catch(final dynamic e, final core::StackTrace stackTrace) {
          let final core::Expando<sta2::_Node> #t626 = this.{sta2::StackZoneSpecification::_chains} in let final core::StackTrace #t627 = stackTrace in #t626.{core::Expando::[]}(#t627).{core::Object::==}(null) ?{sta2::_Node} let final sta2::_Node #t628 = node in let final void #t629 = #t626.{core::Expando::[]=}(#t627, #t628) in #t628 : null;
          rethrow;
        }
      finally {
        this.{sta2::StackZoneSpecification::_currentNode} = previousNode;
      }
    }
    method _currentTrace([core::int level = null]) → tra::Trace {
      level.{core::num::==}(null) ?{core::int} level = 0 : null;
      core::StackTrace stackTrace = core::StackTrace::current;
      return new laz2::LazyTrace::•(() → tra::Trace {
        core::String text = this.{sta2::StackZoneSpecification::_trimVMChain}(stackTrace);
        tra::Trace trace = tra::Trace::parse(text);
        return new tra::Trace::•(trace.{tra::Trace::frames}.{core::Iterable::skip}(level.{core::num::+}(uti2::inJS ?{core::int} 2 : 1)), original: text);
      });
    }
    method _trimVMChain(core::StackTrace trace) → core::String {
      core::String text = trace.{core::StackTrace::toString}();
      core::int index = text.{core::String::indexOf}(uti2::vmChainGap);
      return index.{core::num::==}(1.{core::int::unary-}()) ?{core::String} text : text.{core::String::substring}(0, index);
    }
  }
  class _Node extends core::Object {
    final field tra::Trace trace;
    final field sta2::_Node previous;
    constructor •(core::StackTrace trace, [sta2::_Node previous = null]) → void
      : sta2::_Node::previous = previous, sta2::_Node::trace = tra::Trace::from(trace), super core::Object::•()
      ;
    method toChain() → cha3::Chain {
      core::List<tra::Trace> nodes = <tra::Trace>[];
      sta2::_Node node = this;
      while (!node.{core::Object::==}(null)) {
        nodes.{core::List::add}(node.{sta2::_Node::trace});
        node = node.{sta2::_Node::previous};
      }
      return new cha3::Chain::•(nodes);
    }
  }
}
library from "package:stack_trace/src/utils.dart" as uti2 {
  static const field core::String chainGap = "===== asynchronous gap ===========================\n";
  static const field core::String vmChainGap = "<asynchronous suspension>\n";
  static final field core::bool inJS = 0.0 is core::int;
}
library from "package:stack_trace/src/lazy_trace.dart" as laz2 {
  import "package:stack_trace/src/frame.dart";
  import "package:stack_trace/src/trace.dart";
  typedef TraceThunk = () → tra::Trace;
  class LazyTrace extends core::Object implements tra::Trace {
    final field () → tra::Trace _thunk;
    field tra::Trace _inner = null;
    constructor •(() → tra::Trace _thunk) → void
      : laz2::LazyTrace::_thunk = _thunk, super core::Object::•()
      ;
    get _trace() → tra::Trace {
      if(this.{laz2::LazyTrace::_inner}.{core::Object::==}(null))
        this.{laz2::LazyTrace::_inner} = this.{laz2::LazyTrace::_thunk}();
      return this.{laz2::LazyTrace::_inner};
    }
    get frames() → core::List<fra::Frame>
      return this.{laz2::LazyTrace::_trace}.{tra::Trace::frames};
    get original() → core::StackTrace
      return this.{laz2::LazyTrace::_trace}.{tra::Trace::original};
    get vmTrace() → core::StackTrace
      return this.{laz2::LazyTrace::_trace}.{tra::Trace::vmTrace};
    get terse() → tra::Trace
      return new laz2::LazyTrace::•(() → tra::Trace => this.{laz2::LazyTrace::_trace}.{tra::Trace::terse});
    method foldFrames((fra::Frame) → core::bool predicate, {core::bool terse = false}) → tra::Trace
      return new laz2::LazyTrace::•(() → tra::Trace => this.{laz2::LazyTrace::_trace}.{tra::Trace::foldFrames}(predicate, terse: terse));
    method toString() → core::String
      return this.{laz2::LazyTrace::_trace}.{tra::Trace::toString}();
    set frames(core::List<fra::Frame> _) → void
      return throw new core::UnimplementedError::•();
  }
}
library from "package:stack_trace/src/vm_trace.dart" as vm_ {
  import "package:stack_trace/src/frame.dart";
  class VMTrace extends core::Object implements core::StackTrace {
    final field core::List<fra::Frame> frames;
    constructor •(core::List<fra::Frame> frames) → void
      : vm_::VMTrace::frames = frames, super core::Object::•()
      ;
    method toString() → core::String {
      core::int i = 1;
      return this.{vm_::VMTrace::frames}.{core::Iterable::map}<core::String>((fra::Frame frame) → core::String {
        core::String number = "#${let final core::int #t630 = i in let final core::int #t631 = i = #t630.{core::num::+}(1) in #t630}".{core::String::padRight}(8);
        core::String member = frame.{fra::Frame::member}.{core::String::replaceAllMapped}(core::RegExp::•("[^.]+\\.<async>"), (core::Match match) → core::String => "${match.{core::Match::[]}(1)}.<${match.{core::Match::[]}(1)}_async_body>").{core::String::replaceAll}("<fn>", "<anonymous closure>");
        core::int line = frame.{fra::Frame::line}.{core::num::==}(null) ?{core::int} 0 : frame.{fra::Frame::line};
        core::int column = frame.{fra::Frame::column}.{core::num::==}(null) ?{core::int} 0 : frame.{fra::Frame::column};
        return "${number}${member} (${frame.{fra::Frame::uri}}:${line}:${column})\n";
      }).{core::Iterable::join}();
    }
  }
}
library from "package:collection/src/algorithms.dart" as alg {
  import "dart:math" as math;
  import "package:collection/src/utils.dart";
  static const field core::int _MERGE_SORT_LIMIT = 32;
  static method binarySearch<T extends core::Object = dynamic>(core::List<alg::binarySearch::T> sortedList, alg::binarySearch::T value, {(alg::binarySearch::T, alg::binarySearch::T) → core::int compare = null}) → core::int {
    compare.{core::Object::==}(null) ?{(alg::binarySearch::T, alg::binarySearch::T) → core::int} compare = uti5::defaultCompare<alg::binarySearch::T>() : null;
    core::int min = 0;
    core::int max = sortedList.{core::List::length};
    while (min.{core::num::<}(max)) {
      core::int mid = min.{core::num::+}(max.{core::num::-}(min).{core::int::>>}(1));
      alg::binarySearch::T element = sortedList.{core::List::[]}(mid);
      core::int comp = compare.call(element, value);
      if(comp.{core::num::==}(0))
        return mid;
      if(comp.{core::num::<}(0)) {
        min = mid.{core::num::+}(1);
      }
      else {
        max = mid;
      }
    }
    return 1.{core::int::unary-}();
  }
  static method lowerBound<T extends core::Object = dynamic>(core::List<alg::lowerBound::T> sortedList, alg::lowerBound::T value, {(alg::lowerBound::T, alg::lowerBound::T) → core::int compare = null}) → core::int {
    compare.{core::Object::==}(null) ?{(alg::lowerBound::T, alg::lowerBound::T) → core::int} compare = uti5::defaultCompare<alg::lowerBound::T>() : null;
    core::int min = 0;
    core::int max = sortedList.{core::List::length};
    while (min.{core::num::<}(max)) {
      core::int mid = min.{core::num::+}(max.{core::num::-}(min).{core::int::>>}(1));
      alg::lowerBound::T element = sortedList.{core::List::[]}(mid);
      core::int comp = compare.call(element, value);
      if(comp.{core::num::<}(0)) {
        min = mid.{core::num::+}(1);
      }
      else {
        max = mid;
      }
    }
    return min;
  }
  static method shuffle(core::List<dynamic> list, [core::int start = 0, core::int end = null]) → void {
    math::Random random = math::Random::•();
    if(end.{core::num::==}(null))
      end = list.{core::List::length};
    core::int length = end.{core::num::-}(start);
    while (length.{core::num::>}(1)) {
      core::int pos = random.{math::Random::nextInt}(length);
      length = length.{core::num::-}(1);
      dynamic tmp1 = list.{core::List::[]}(start.{core::num::+}(pos));
      list.{core::List::[]=}(start.{core::num::+}(pos), list.{core::List::[]}(start.{core::num::+}(length)));
      list.{core::List::[]=}(start.{core::num::+}(length), tmp1);
    }
  }
  static method reverse(core::List<dynamic> list, [core::int start = 0, core::int end = null]) → void {
    if(end.{core::num::==}(null))
      end = list.{core::List::length};
    alg::_reverse(list, start, end);
  }
  static method _reverse(core::List<dynamic> list, core::int start, core::int end) → void {
    for (core::int i = start, core::int j = end.{core::num::-}(1); i.{core::num::<}(j); i = i.{core::num::+}(1), j = j.{core::num::-}(1)) {
      dynamic tmp = list.{core::List::[]}(i);
      list.{core::List::[]=}(i, list.{core::List::[]}(j));
      list.{core::List::[]=}(j, tmp);
    }
  }
  static method insertionSort<T extends core::Object = dynamic>(core::List<alg::insertionSort::T> list, {(alg::insertionSort::T, alg::insertionSort::T) → core::int compare = null, core::int start = 0, core::int end = null}) → void {
    compare.{core::Object::==}(null) ?{(alg::insertionSort::T, alg::insertionSort::T) → core::int} compare = uti5::defaultCompare<alg::insertionSort::T>() : null;
    end.{core::num::==}(null) ?{core::int} end = list.{core::List::length} : null;
    for (core::int pos = start.{core::num::+}(1); pos.{core::num::<}(end); pos = pos.{core::num::+}(1)) {
      core::int min = start;
      core::int max = pos;
      alg::insertionSort::T element = list.{core::List::[]}(pos);
      while (min.{core::num::<}(max)) {
        core::int mid = min.{core::num::+}(max.{core::num::-}(min).{core::int::>>}(1));
        core::int comparison = compare.call(element, list.{core::List::[]}(mid));
        if(comparison.{core::num::<}(0)) {
          max = mid;
        }
        else {
          min = mid.{core::num::+}(1);
        }
      }
      list.{core::List::setRange}(min.{core::num::+}(1), pos.{core::num::+}(1), list, min);
      list.{core::List::[]=}(min, element);
    }
  }
  static method mergeSort<T extends core::Object = dynamic>(core::List<alg::mergeSort::T> list, {core::int start = 0, core::int end = null, (alg::mergeSort::T, alg::mergeSort::T) → core::int compare = null}) → void {
    end.{core::num::==}(null) ?{core::int} end = list.{core::List::length} : null;
    compare.{core::Object::==}(null) ?{(alg::mergeSort::T, alg::mergeSort::T) → core::int} compare = uti5::defaultCompare<alg::mergeSort::T>() : null;
    core::int length = end.{core::num::-}(start);
    if(length.{core::num::<}(2))
      return;
    if(length.{core::num::<}(alg::_MERGE_SORT_LIMIT)) {
      alg::insertionSort<alg::mergeSort::T>(list, compare: compare, start: start, end: end);
      return;
    }
    core::int middle = start.{core::num::+}(end.{core::num::-}(start).{core::int::>>}(1));
    core::int firstLength = middle.{core::num::-}(start);
    core::int secondLength = end.{core::num::-}(middle);
    core::List<alg::mergeSort::T> scratchSpace = core::List::•<alg::mergeSort::T>(secondLength);
    alg::_mergeSort<alg::mergeSort::T>(list, compare, middle, end, scratchSpace, 0);
    core::int firstTarget = end.{core::num::-}(firstLength);
    alg::_mergeSort<alg::mergeSort::T>(list, compare, start, middle, list, firstTarget);
    alg::_merge<alg::mergeSort::T>(compare, list, firstTarget, end, scratchSpace, 0, secondLength, list, start);
  }
  static method _movingInsertionSort<T extends core::Object = dynamic>(core::List<alg::_movingInsertionSort::T> list, (alg::_movingInsertionSort::T, alg::_movingInsertionSort::T) → core::int compare, core::int start, core::int end, core::List<alg::_movingInsertionSort::T> target, core::int targetOffset) → void {
    core::int length = end.{core::num::-}(start);
    if(length.{core::num::==}(0))
      return;
    target.{core::List::[]=}(targetOffset, list.{core::List::[]}(start));
    for (core::int i = 1; i.{core::num::<}(length); i = i.{core::num::+}(1)) {
      alg::_movingInsertionSort::T element = list.{core::List::[]}(start.{core::num::+}(i));
      core::int min = targetOffset;
      core::int max = targetOffset.{core::num::+}(i);
      while (min.{core::num::<}(max)) {
        core::int mid = min.{core::num::+}(max.{core::num::-}(min).{core::int::>>}(1));
        if(compare.call(element, target.{core::List::[]}(mid)).{core::num::<}(0)) {
          max = mid;
        }
        else {
          min = mid.{core::num::+}(1);
        }
      }
      target.{core::List::setRange}(min.{core::num::+}(1), targetOffset.{core::num::+}(i).{core::num::+}(1), target, min);
      target.{core::List::[]=}(min, element);
    }
  }
  static method _mergeSort<T extends core::Object = dynamic>(core::List<alg::_mergeSort::T> list, (alg::_mergeSort::T, alg::_mergeSort::T) → core::int compare, core::int start, core::int end, core::List<alg::_mergeSort::T> target, core::int targetOffset) → void {
    core::int length = end.{core::num::-}(start);
    if(length.{core::num::<}(alg::_MERGE_SORT_LIMIT)) {
      alg::_movingInsertionSort<alg::_mergeSort::T>(list, compare, start, end, target, targetOffset);
      return;
    }
    core::int middle = start.{core::num::+}(length.{core::int::>>}(1));
    core::int firstLength = middle.{core::num::-}(start);
    core::int secondLength = end.{core::num::-}(middle);
    core::int targetMiddle = targetOffset.{core::num::+}(firstLength);
    alg::_mergeSort<alg::_mergeSort::T>(list, compare, middle, end, target, targetMiddle);
    alg::_mergeSort<alg::_mergeSort::T>(list, compare, start, middle, list, middle);
    alg::_merge<alg::_mergeSort::T>(compare, list, middle, middle.{core::num::+}(firstLength), target, targetMiddle, targetMiddle.{core::num::+}(secondLength), target, targetOffset);
  }
  static method _merge<T extends core::Object = dynamic>((alg::_merge::T, alg::_merge::T) → core::int compare, core::List<alg::_merge::T> firstList, core::int firstStart, core::int firstEnd, core::List<alg::_merge::T> secondList, core::int secondStart, core::int secondEnd, core::List<alg::_merge::T> target, core::int targetOffset) → void {
    assert(firstStart.{core::num::<}(firstEnd));
    assert(secondStart.{core::num::<}(secondEnd));
    core::int cursor1 = firstStart;
    core::int cursor2 = secondStart;
    alg::_merge::T firstElement = firstList.{core::List::[]}(let final core::int #t632 = cursor1 in let final core::int #t633 = cursor1 = #t632.{core::num::+}(1) in #t632);
    alg::_merge::T secondElement = secondList.{core::List::[]}(let final core::int #t634 = cursor2 in let final core::int #t635 = cursor2 = #t634.{core::num::+}(1) in #t634);
    #L102:
    while (true)
      #L103:
      {
        if(compare.call(firstElement, secondElement).{core::num::<=}(0)) {
          target.{core::List::[]=}(let final core::int #t636 = targetOffset in let final core::int #t637 = targetOffset = #t636.{core::num::+}(1) in #t636, firstElement);
          if(cursor1.{core::num::==}(firstEnd))
            break #L102;
          firstElement = firstList.{core::List::[]}(let final core::int #t638 = cursor1 in let final core::int #t639 = cursor1 = #t638.{core::num::+}(1) in #t638);
        }
        else {
          target.{core::List::[]=}(let final core::int #t640 = targetOffset in let final core::int #t641 = targetOffset = #t640.{core::num::+}(1) in #t640, secondElement);
          if(!cursor2.{core::num::==}(secondEnd)) {
            secondElement = secondList.{core::List::[]}(let final core::int #t642 = cursor2 in let final core::int #t643 = cursor2 = #t642.{core::num::+}(1) in #t642);
            break #L103;
          }
          target.{core::List::[]=}(let final core::int #t644 = targetOffset in let final core::int #t645 = targetOffset = #t644.{core::num::+}(1) in #t644, firstElement);
          target.{core::List::setRange}(targetOffset, targetOffset.{core::num::+}(firstEnd.{core::num::-}(cursor1)), firstList, cursor1);
          return;
        }
      }
    target.{core::List::[]=}(let final core::int #t646 = targetOffset in let final core::int #t647 = targetOffset = #t646.{core::num::+}(1) in #t646, secondElement);
    target.{core::List::setRange}(targetOffset, targetOffset.{core::num::+}(secondEnd.{core::num::-}(cursor2)), secondList, cursor2);
  }
}
library from "package:collection/src/canonicalized_map.dart" as can {
  import "dart:collection";
  import "package:collection/src/utils.dart";
  typedef _Canonicalize<C extends core::Object = dynamic, K extends core::Object = dynamic> = (K) → C;
  typedef _IsValidKey = (core::Object) → core::bool;
  class CanonicalizedMap<C extends core::Object = dynamic, K extends core::Object = dynamic, V extends core::Object = dynamic> extends core::Object implements core::Map<can::CanonicalizedMap::K, can::CanonicalizedMap::V> {
    final field (can::CanonicalizedMap::K) → can::CanonicalizedMap::C _canonicalize;
    final field (core::Object) → core::bool _isValidKeyFn;
    final field core::Map<can::CanonicalizedMap::C, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V>> _base = new _js::LinkedMap::•<can::CanonicalizedMap::C, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V>>();
    constructor •((can::CanonicalizedMap::K) → can::CanonicalizedMap::C canonicalize, {(core::Object) → core::bool isValidKey = null}) → void
      : can::CanonicalizedMap::_canonicalize = canonicalize, can::CanonicalizedMap::_isValidKeyFn = isValidKey, super core::Object::•()
      ;
    constructor from(core::Map<can::CanonicalizedMap::K, can::CanonicalizedMap::V> other, (can::CanonicalizedMap::K) → can::CanonicalizedMap::C canonicalize, {(core::Object) → core::bool isValidKey = null}) → void
      : can::CanonicalizedMap::_canonicalize = canonicalize, can::CanonicalizedMap::_isValidKeyFn = isValidKey, super core::Object::•() {
      this.{can::CanonicalizedMap::addAll}(other);
    }
    operator [](core::Object key) → can::CanonicalizedMap::V {
      if(!this.{can::CanonicalizedMap::_isValidKey}(key))
        return null;
      uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair = this.{can::CanonicalizedMap::_base}.{core::Map::[]}(this.{can::CanonicalizedMap::_canonicalize}(key as can::CanonicalizedMap::K));
      return pair.{core::Object::==}(null) ?{can::CanonicalizedMap::V} null : pair.{uti5::Pair::last};
    }
    operator []=(generic-covariant-impl can::CanonicalizedMap::K key, generic-covariant-impl can::CanonicalizedMap::V value) → void {
      if(!this.{can::CanonicalizedMap::_isValidKey}(key))
        return;
      this.{can::CanonicalizedMap::_base}.{core::Map::[]=}(this.{can::CanonicalizedMap::_canonicalize}(key), new uti5::Pair::•<can::CanonicalizedMap::K, can::CanonicalizedMap::V>(key, value));
    }
    method addAll(generic-covariant-impl core::Map<can::CanonicalizedMap::K, can::CanonicalizedMap::V> other) → void {
      other.{core::Map::forEach}((can::CanonicalizedMap::K key, can::CanonicalizedMap::V value) → void => let final can::CanonicalizedMap::K #t648 = key in let final can::CanonicalizedMap::V #t649 = value in let final void #t650 = this.{can::CanonicalizedMap::[]=}(#t648, #t649) in #t649);
    }
    method addEntries(generic-covariant-impl core::Iterable<core::MapEntry<can::CanonicalizedMap::K, can::CanonicalizedMap::V>> entries) → void
      return this.{can::CanonicalizedMap::_base}.{core::Map::addEntries}(entries.{core::Iterable::map}<core::MapEntry<can::CanonicalizedMap::C, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V>>>((core::MapEntry<can::CanonicalizedMap::K, can::CanonicalizedMap::V> e) → core::MapEntry<can::CanonicalizedMap::C, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V>> => new core::MapEntry::_<can::CanonicalizedMap::C, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V>>(this.{can::CanonicalizedMap::_canonicalize}(e.{core::MapEntry::key}), new uti5::Pair::•<can::CanonicalizedMap::K, can::CanonicalizedMap::V>(e.{core::MapEntry::key}, e.{core::MapEntry::value}))));
    method cast<K2 extends core::Object = dynamic, V2 extends core::Object = dynamic>() → core::Map<can::CanonicalizedMap::cast::K2, can::CanonicalizedMap::cast::V2>
      return this.{can::CanonicalizedMap::_base}.{core::Map::cast}<can::CanonicalizedMap::cast::K2, can::CanonicalizedMap::cast::V2>();
    method clear() → void {
      this.{can::CanonicalizedMap::_base}.{core::Map::clear}();
    }
    method containsKey(core::Object key) → core::bool {
      if(!this.{can::CanonicalizedMap::_isValidKey}(key))
        return false;
      return this.{can::CanonicalizedMap::_base}.{core::Map::containsKey}(this.{can::CanonicalizedMap::_canonicalize}(key as can::CanonicalizedMap::K));
    }
    method containsValue(core::Object value) → core::bool
      return this.{can::CanonicalizedMap::_base}.{core::Map::values}.{core::Iterable::any}((uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → core::bool => pair.{uti5::Pair::last}.{core::Object::==}(value));
    get entries() → core::Iterable<core::MapEntry<can::CanonicalizedMap::K, can::CanonicalizedMap::V>>
      return this.{can::CanonicalizedMap::_base}.{core::Map::entries}.{core::Iterable::map}<core::MapEntry<can::CanonicalizedMap::K, can::CanonicalizedMap::V>>((core::MapEntry<can::CanonicalizedMap::C, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V>> e) → core::MapEntry<can::CanonicalizedMap::K, can::CanonicalizedMap::V> => new core::MapEntry::_<can::CanonicalizedMap::K, can::CanonicalizedMap::V>(e.{core::MapEntry::value}.{uti5::Pair::first}, e.{core::MapEntry::value}.{uti5::Pair::last}));
    method forEach((can::CanonicalizedMap::K, can::CanonicalizedMap::V) → void f) → void {
      this.{can::CanonicalizedMap::_base}.{core::Map::forEach}((can::CanonicalizedMap::C key, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → void => f.call(pair.{uti5::Pair::first}, pair.{uti5::Pair::last}));
    }
    get isEmpty() → core::bool
      return this.{can::CanonicalizedMap::_base}.{core::Map::isEmpty};
    get isNotEmpty() → core::bool
      return this.{can::CanonicalizedMap::_base}.{core::Map::isNotEmpty};
    get keys() → core::Iterable<can::CanonicalizedMap::K>
      return this.{can::CanonicalizedMap::_base}.{core::Map::values}.{core::Iterable::map}<can::CanonicalizedMap::K>((uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → can::CanonicalizedMap::K => pair.{uti5::Pair::first});
    get length() → core::int
      return this.{can::CanonicalizedMap::_base}.{core::Map::length};
    method map<K2 extends core::Object = dynamic, V2 extends core::Object = dynamic>((can::CanonicalizedMap::K, can::CanonicalizedMap::V) → core::MapEntry<can::CanonicalizedMap::map::K2, can::CanonicalizedMap::map::V2> transform) → core::Map<can::CanonicalizedMap::map::K2, can::CanonicalizedMap::map::V2>
      return this.{can::CanonicalizedMap::_base}.{core::Map::map}<can::CanonicalizedMap::map::K2, can::CanonicalizedMap::map::V2>((can::CanonicalizedMap::C _, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → core::MapEntry<can::CanonicalizedMap::map::K2, can::CanonicalizedMap::map::V2> => transform.call(pair.{uti5::Pair::first}, pair.{uti5::Pair::last}));
    method putIfAbsent(generic-covariant-impl can::CanonicalizedMap::K key, generic-covariant-impl () → can::CanonicalizedMap::V ifAbsent) → can::CanonicalizedMap::V {
      return this.{can::CanonicalizedMap::_base}.{core::Map::putIfAbsent}(this.{can::CanonicalizedMap::_canonicalize}(key), () → uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> => new uti5::Pair::•<can::CanonicalizedMap::K, can::CanonicalizedMap::V>(key, ifAbsent.call())).{uti5::Pair::last};
    }
    method remove(core::Object key) → can::CanonicalizedMap::V {
      if(!this.{can::CanonicalizedMap::_isValidKey}(key))
        return null;
      uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair = this.{can::CanonicalizedMap::_base}.{core::Map::remove}(this.{can::CanonicalizedMap::_canonicalize}(key as can::CanonicalizedMap::K));
      return pair.{core::Object::==}(null) ?{can::CanonicalizedMap::V} null : pair.{uti5::Pair::last};
    }
    method removeWhere((can::CanonicalizedMap::K, can::CanonicalizedMap::V) → core::bool test) → void
      return this.{can::CanonicalizedMap::_base}.{core::Map::removeWhere}((can::CanonicalizedMap::C _, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → core::bool => test.call(pair.{uti5::Pair::first}, pair.{uti5::Pair::last}));
    @core::deprecated
    method retype<K2 extends core::Object = dynamic, V2 extends core::Object = dynamic>() → core::Map<can::CanonicalizedMap::retype::K2, can::CanonicalizedMap::retype::V2>
      return this.{can::CanonicalizedMap::cast}<can::CanonicalizedMap::retype::K2, can::CanonicalizedMap::retype::V2>();
    method update(generic-covariant-impl can::CanonicalizedMap::K key, generic-covariant-impl (can::CanonicalizedMap::V) → can::CanonicalizedMap::V update, {generic-covariant-impl () → can::CanonicalizedMap::V ifAbsent = null}) → can::CanonicalizedMap::V
      return this.{can::CanonicalizedMap::_base}.{core::Map::update}(this.{can::CanonicalizedMap::_canonicalize}(key), (uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> => new uti5::Pair::•<can::CanonicalizedMap::K, can::CanonicalizedMap::V>(key, update.call(pair.{uti5::Pair::last})), ifAbsent: ifAbsent.{core::Object::==}(null) ?{() → uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V>} null : () → uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> => new uti5::Pair::•<can::CanonicalizedMap::K, can::CanonicalizedMap::V>(key, ifAbsent.call())).{uti5::Pair::last};
    method updateAll(generic-covariant-impl (can::CanonicalizedMap::K, can::CanonicalizedMap::V) → can::CanonicalizedMap::V update) → void
      return this.{can::CanonicalizedMap::_base}.{core::Map::updateAll}((can::CanonicalizedMap::C _, uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> => new uti5::Pair::•<can::CanonicalizedMap::K, can::CanonicalizedMap::V>(pair.{uti5::Pair::first}, update.call(pair.{uti5::Pair::first}, pair.{uti5::Pair::last})));
    get values() → core::Iterable<can::CanonicalizedMap::V>
      return this.{can::CanonicalizedMap::_base}.{core::Map::values}.{core::Iterable::map}<can::CanonicalizedMap::V>((uti5::Pair<can::CanonicalizedMap::K, can::CanonicalizedMap::V> pair) → can::CanonicalizedMap::V => pair.{uti5::Pair::last});
    method toString() → core::String {
      if(can::_isToStringVisiting(this)) {
        return "{...}";
      }
      core::StringBuffer result = new core::StringBuffer::•();
      try {
        can::_toStringVisiting.{core::List::add}(this);
        result.{core::StringBuffer::write}("{");
        core::bool first = true;
        this.{can::CanonicalizedMap::forEach}((can::CanonicalizedMap::K k, can::CanonicalizedMap::V v) → core::Null {
          if(!first) {
            result.{core::StringBuffer::write}(", ");
          }
          first = false;
          result.{core::StringBuffer::write}("${k}: ${v}");
        });
        result.{core::StringBuffer::write}("}");
      }
      finally {
        assert(core::identical(can::_toStringVisiting.{core::Iterable::last}, this));
        can::_toStringVisiting.{core::List::removeLast}();
      }
      return result.{core::StringBuffer::toString}();
    }
    method _isValidKey(core::Object key) → core::bool
      return (key.{core::Object::==}(null) || key is can::CanonicalizedMap::K) && (this.{can::CanonicalizedMap::_isValidKeyFn}.{core::Object::==}(null) || this.{can::CanonicalizedMap::_isValidKeyFn}(key));
  }
  static final field core::List<dynamic> _toStringVisiting = <dynamic>[];
  static method _isToStringVisiting(dynamic o) → core::bool
    return can::_toStringVisiting.{core::Iterable::any}((dynamic e) → core::bool => core::identical(o, e));
}
library from "package:collection/src/combined_wrappers/combined_iterable.dart" as com3 {
  import "dart:collection";
  class CombinedIterableView<T extends core::Object = dynamic> extends col::IterableBase<com3::CombinedIterableView::T> {
    final field core::Iterable<core::Iterable<com3::CombinedIterableView::T>> _iterables;
    const constructor •(core::Iterable<core::Iterable<com3::CombinedIterableView::T>> _iterables) → void
      : com3::CombinedIterableView::_iterables = _iterables, super col::IterableBase::•()
      ;
    get iterator() → core::Iterator<com3::CombinedIterableView::T>
      return new com3::_CombinedIterator::•<com3::CombinedIterableView::T>(this.{com3::CombinedIterableView::_iterables}.{core::Iterable::map}<core::Iterator<com3::CombinedIterableView::T>>((core::Iterable<com3::CombinedIterableView::T> i) → core::Iterator<com3::CombinedIterableView::T> => i.{core::Iterable::iterator}).{core::Iterable::iterator});
    method contains(core::Object element) → core::bool
      return this.{com3::CombinedIterableView::_iterables}.{core::Iterable::any}((core::Iterable<com3::CombinedIterableView::T> i) → core::bool => i.{core::Iterable::contains}(element));
    get isEmpty() → core::bool
      return this.{com3::CombinedIterableView::_iterables}.{core::Iterable::every}((core::Iterable<com3::CombinedIterableView::T> i) → core::bool => i.{core::Iterable::isEmpty});
    get length() → core::int
      return this.{com3::CombinedIterableView::_iterables}.{core::Iterable::fold}<core::int>(0, (core::int length, core::Iterable<com3::CombinedIterableView::T> i) → core::int => length.{core::num::+}(i.{core::Iterable::length}));
  }
  class _CombinedIterator<T extends core::Object = dynamic> extends core::Object implements core::Iterator<com3::_CombinedIterator::T> {
    final field core::Iterator<core::Iterator<com3::_CombinedIterator::T>> _iterators;
    constructor •(core::Iterator<core::Iterator<com3::_CombinedIterator::T>> _iterators) → void
      : com3::_CombinedIterator::_iterators = _iterators, super core::Object::•()
      ;
    get current() → com3::_CombinedIterator::T
      return let final core::Iterator<com3::_CombinedIterator::T> #t651 = this.{com3::_CombinedIterator::_iterators}.{core::Iterator::current} in #t651.==(null) ?{com3::_CombinedIterator::T} null : #t651.{core::Iterator::current};
    method moveNext() → core::bool {
      core::Iterator<com3::_CombinedIterator::T> current = this.{com3::_CombinedIterator::_iterators}.{core::Iterator::current};
      if(!current.{core::Object::==}(null) && current.{core::Iterator::moveNext}()) {
        return true;
      }
      return this.{com3::_CombinedIterator::_iterators}.{core::Iterator::moveNext}() && this.{com3::_CombinedIterator::moveNext}();
    }
  }
}
library from "package:collection/src/combined_wrappers/combined_list.dart" as com4 {
  import "dart:collection";
  class CombinedListView<T extends core::Object = dynamic> extends col::ListBase<com4::CombinedListView::T> implements col::UnmodifiableListView<com4::CombinedListView::T> {
    final field core::List<core::List<com4::CombinedListView::T>> _lists;
    constructor •(core::List<core::List<com4::CombinedListView::T>> _lists) → void
      : com4::CombinedListView::_lists = _lists, super col::ListBase::•()
      ;
    static method _throw() → void {
      throw new core::UnsupportedError::•("Cannot modify an unmodifiable List");
    }
    set length(core::int length) → void {
      com4::CombinedListView::_throw();
    }
    get length() → core::int
      return this.{com4::CombinedListView::_lists}.{core::Iterable::fold}<core::int>(0, (core::int length, core::List<com4::CombinedListView::T> list) → core::int => length.{core::num::+}(list.{core::List::length}));
    operator [](core::int index) → com4::CombinedListView::T {
      core::int initialIndex = index;
      for (core::int i = 0; i.{core::num::<}(this.{com4::CombinedListView::_lists}.{core::List::length}); i = i.{core::num::+}(1)) {
        core::List<com4::CombinedListView::T> list = this.{com4::CombinedListView::_lists}.{core::List::[]}(i);
        if(index.{core::num::<}(list.{core::List::length})) {
          return list.{core::List::[]}(index);
        }
        index = index.{core::num::-}(list.{core::List::length});
      }
      throw new core::IndexError::•(initialIndex, this, "index", null, this.{com4::CombinedListView::length});
    }
    operator []=(core::int index, generic-covariant-impl com4::CombinedListView::T value) → void {
      com4::CombinedListView::_throw();
    }
    method clear() → void {
      com4::CombinedListView::_throw();
    }
    method remove(core::Object element) → core::bool {
      com4::CombinedListView::_throw();
      return null;
    }
    method removeWhere((com4::CombinedListView::T) → core::bool test) → void {
      com4::CombinedListView::_throw();
    }
    method retainWhere((com4::CombinedListView::T) → core::bool test) → void {
      com4::CombinedListView::_throw();
    }
  }
}
library from "package:collection/src/combined_wrappers/combined_map.dart" as com5 {
  import "dart:collection";
  import "package:collection/src/combined_wrappers/combined_iterable.dart";
  class CombinedMapView<K extends core::Object = dynamic, V extends core::Object = dynamic> extends col::UnmodifiableMapBase<com5::CombinedMapView::K, com5::CombinedMapView::V> {
    final field core::Iterable<core::Map<com5::CombinedMapView::K, com5::CombinedMapView::V>> _maps;
    constructor •(core::Iterable<core::Map<com5::CombinedMapView::K, com5::CombinedMapView::V>> _maps) → void
      : com5::CombinedMapView::_maps = _maps, super col::MapBase::•()
      ;
    operator [](core::Object key) → com5::CombinedMapView::V {
      for (core::Map<com5::CombinedMapView::K, com5::CombinedMapView::V> map in this.{com5::CombinedMapView::_maps}) {
        com5::CombinedMapView::V value = map.{core::Map::[]}(key);
        if(!value.{core::Object::==}(null) || map.{core::Map::containsKey}(value)) {
          return value;
        }
      }
      return null;
    }
    get keys() → core::Iterable<com5::CombinedMapView::K>
      return new com3::CombinedIterableView::•<com5::CombinedMapView::K>(this.{com5::CombinedMapView::_maps}.{core::Iterable::map}<core::Iterable<com5::CombinedMapView::K>>((core::Map<com5::CombinedMapView::K, com5::CombinedMapView::V> m) → core::Iterable<com5::CombinedMapView::K> => m.{core::Map::keys}));
  }
}
library from "package:collection/src/comparators.dart" as com6 {
  static const field core::int _zero = 48;
  static const field core::int _upperCaseA = 65;
  static const field core::int _upperCaseZ = 90;
  static const field core::int _lowerCaseA = 97;
  static const field core::int _lowerCaseZ = 122;
  static const field core::int _asciiCaseBit = 32;
  static method equalsIgnoreAsciiCase(core::String a, core::String b) → core::bool {
    if(!a.{core::String::length}.{core::num::==}(b.{core::String::length}))
      return false;
    for (core::int i = 0; i.{core::num::<}(a.{core::String::length}); i = i.{core::num::+}(1))
      #L104:
      {
        core::int aChar = a.{core::String::codeUnitAt}(i);
        core::int bChar = b.{core::String::codeUnitAt}(i);
        if(aChar.{core::num::==}(bChar))
          break #L104;
        if(!aChar.{core::int::^}(bChar).{core::num::==}(com6::_asciiCaseBit))
          return false;
        core::int aCharLowerCase = aChar.{core::int::|}(com6::_asciiCaseBit);
        if(com6::_lowerCaseA.{core::num::<=}(aCharLowerCase) && aCharLowerCase.{core::num::<=}(com6::_lowerCaseZ)) {
          break #L104;
        }
        return false;
      }
    return true;
  }
  static method hashIgnoreAsciiCase(core::String string) → core::int {
    core::int hash = 0;
    for (core::int i = 0; i.{core::num::<}(string.{core::String::length}); i = i.{core::num::+}(1)) {
      core::int char = string.{core::String::codeUnitAt}(i);
      if(com6::_lowerCaseA.{core::num::<=}(char) && char.{core::num::<=}(com6::_lowerCaseZ))
        char = char.{core::num::-}(com6::_asciiCaseBit);
      hash = 536870911.{core::int::&}(hash.{core::num::+}(char));
      hash = 536870911.{core::int::&}(hash.{core::num::+}(524287.{core::int::&}(hash).{core::int::<<}(10)));
      hash = hash.{core::int::>>}(6);
    }
    hash = 536870911.{core::int::&}(hash.{core::num::+}(67108863.{core::int::&}(hash).{core::int::<<}(3)));
    hash = hash.{core::int::>>}(11);
    return 536870911.{core::int::&}(hash.{core::num::+}(16383.{core::int::&}(hash).{core::int::<<}(15)));
  }
  static method compareAsciiUpperCase(core::String a, core::String b) → core::int {
    core::int defaultResult = 0;
    for (core::int i = 0; i.{core::num::<}(a.{core::String::length}); i = i.{core::num::+}(1))
      #L105:
      {
        if(i.{core::num::>=}(b.{core::String::length}))
          return 1;
        core::int aChar = a.{core::String::codeUnitAt}(i);
        core::int bChar = b.{core::String::codeUnitAt}(i);
        if(aChar.{core::num::==}(bChar))
          break #L105;
        core::int aUpperCase = aChar;
        core::int bUpperCase = bChar;
        if(com6::_lowerCaseA.{core::num::<=}(aChar) && aChar.{core::num::<=}(com6::_lowerCaseZ)) {
          aUpperCase = aUpperCase.{core::num::-}(com6::_asciiCaseBit);
        }
        if(com6::_lowerCaseA.{core::num::<=}(bChar) && bChar.{core::num::<=}(com6::_lowerCaseZ)) {
          bUpperCase = bUpperCase.{core::num::-}(com6::_asciiCaseBit);
        }
        if(!aUpperCase.{core::num::==}(bUpperCase))
          return aUpperCase.{core::num::-}(bUpperCase).{core::int::sign};
        if(defaultResult.{core::num::==}(0))
          defaultResult = aChar.{core::num::-}(bChar);
      }
    if(b.{core::String::length}.{core::num::>}(a.{core::String::length}))
      return 1.{core::int::unary-}();
    return defaultResult.{core::int::sign};
  }
  static method compareAsciiLowerCase(core::String a, core::String b) → core::int {
    core::int defaultResult = 0;
    for (core::int i = 0; i.{core::num::<}(a.{core::String::length}); i = i.{core::num::+}(1))
      #L106:
      {
        if(i.{core::num::>=}(b.{core::String::length}))
          return 1;
        core::int aChar = a.{core::String::codeUnitAt}(i);
        core::int bChar = b.{core::String::codeUnitAt}(i);
        if(aChar.{core::num::==}(bChar))
          break #L106;
        core::int aLowerCase = aChar;
        core::int bLowerCase = bChar;
        if(com6::_upperCaseA.{core::num::<=}(bChar) && bChar.{core::num::<=}(com6::_upperCaseZ)) {
          bLowerCase = bLowerCase.{core::num::+}(com6::_asciiCaseBit);
        }
        if(com6::_upperCaseA.{core::num::<=}(aChar) && aChar.{core::num::<=}(com6::_upperCaseZ)) {
          aLowerCase = aLowerCase.{core::num::+}(com6::_asciiCaseBit);
        }
        if(!aLowerCase.{core::num::==}(bLowerCase))
          return aLowerCase.{core::num::-}(bLowerCase).{core::int::sign};
        if(defaultResult.{core::num::==}(0))
          defaultResult = aChar.{core::num::-}(bChar);
      }
    if(b.{core::String::length}.{core::num::>}(a.{core::String::length}))
      return 1.{core::int::unary-}();
    return defaultResult.{core::int::sign};
  }
  static method compareNatural(core::String a, core::String b) → core::int {
    for (core::int i = 0; i.{core::num::<}(a.{core::String::length}); i = i.{core::num::+}(1)) {
      if(i.{core::num::>=}(b.{core::String::length}))
        return 1;
      core::int aChar = a.{core::String::codeUnitAt}(i);
      core::int bChar = b.{core::String::codeUnitAt}(i);
      if(!aChar.{core::num::==}(bChar)) {
        return com6::_compareNaturally(a, b, i, aChar, bChar);
      }
    }
    if(b.{core::String::length}.{core::num::>}(a.{core::String::length}))
      return 1.{core::int::unary-}();
    return 0;
  }
  static method compareAsciiLowerCaseNatural(core::String a, core::String b) → core::int {
    core::int defaultResult = 0;
    for (core::int i = 0; i.{core::num::<}(a.{core::String::length}); i = i.{core::num::+}(1))
      #L107:
      {
        if(i.{core::num::>=}(b.{core::String::length}))
          return 1;
        core::int aChar = a.{core::String::codeUnitAt}(i);
        core::int bChar = b.{core::String::codeUnitAt}(i);
        if(aChar.{core::num::==}(bChar))
          break #L107;
        core::int aLowerCase = aChar;
        core::int bLowerCase = bChar;
        if(com6::_upperCaseA.{core::num::<=}(aChar) && aChar.{core::num::<=}(com6::_upperCaseZ)) {
          aLowerCase = aLowerCase.{core::num::+}(com6::_asciiCaseBit);
        }
        if(com6::_upperCaseA.{core::num::<=}(bChar) && bChar.{core::num::<=}(com6::_upperCaseZ)) {
          bLowerCase = bLowerCase.{core::num::+}(com6::_asciiCaseBit);
        }
        if(!aLowerCase.{core::num::==}(bLowerCase)) {
          return com6::_compareNaturally(a, b, i, aLowerCase, bLowerCase);
        }
        if(defaultResult.{core::num::==}(0))
          defaultResult = aChar.{core::num::-}(bChar);
      }
    if(b.{core::String::length}.{core::num::>}(a.{core::String::length}))
      return 1.{core::int::unary-}();
    return defaultResult.{core::int::sign};
  }
  static method compareAsciiUpperCaseNatural(core::String a, core::String b) → core::int {
    core::int defaultResult = 0;
    for (core::int i = 0; i.{core::num::<}(a.{core::String::length}); i = i.{core::num::+}(1))
      #L108:
      {
        if(i.{core::num::>=}(b.{core::String::length}))
          return 1;
        core::int aChar = a.{core::String::codeUnitAt}(i);
        core::int bChar = b.{core::String::codeUnitAt}(i);
        if(aChar.{core::num::==}(bChar))
          break #L108;
        core::int aUpperCase = aChar;
        core::int bUpperCase = bChar;
        if(com6::_lowerCaseA.{core::num::<=}(aChar) && aChar.{core::num::<=}(com6::_lowerCaseZ)) {
          aUpperCase = aUpperCase.{core::num::-}(com6::_asciiCaseBit);
        }
        if(com6::_lowerCaseA.{core::num::<=}(bChar) && bChar.{core::num::<=}(com6::_lowerCaseZ)) {
          bUpperCase = bUpperCase.{core::num::-}(com6::_asciiCaseBit);
        }
        if(!aUpperCase.{core::num::==}(bUpperCase)) {
          return com6::_compareNaturally(a, b, i, aUpperCase, bUpperCase);
        }
        if(defaultResult.{core::num::==}(0))
          defaultResult = aChar.{core::num::-}(bChar);
      }
    if(b.{core::String::length}.{core::num::>}(a.{core::String::length}))
      return 1.{core::int::unary-}();
    return defaultResult.{core::int::sign};
  }
  static method _compareNaturally(core::String a, core::String b, core::int index, core::int aChar, core::int bChar) → core::int {
    assert(!aChar.{core::num::==}(bChar));
    core::bool aIsDigit = com6::_isDigit(aChar);
    core::bool bIsDigit = com6::_isDigit(bChar);
    if(aIsDigit) {
      if(bIsDigit) {
        return com6::_compareNumerically(a, b, aChar, bChar, index);
      }
      else
        if(index.{core::num::>}(0) && com6::_isDigit(a.{core::String::codeUnitAt}(index.{core::num::-}(1)))) {
          return 1;
        }
    }
    else
      if(bIsDigit && index.{core::num::>}(0) && com6::_isDigit(b.{core::String::codeUnitAt}(index.{core::num::-}(1)))) {
        return 1.{core::int::unary-}();
      }
    return aChar.{core::num::-}(bChar).{core::int::sign};
  }
  static method _compareNumerically(core::String a, core::String b, core::int aChar, core::int bChar, core::int index) → core::int {
    if(com6::_isNonZeroNumberSuffix(a, index)) {
      core::int result = com6::_compareDigitCount(a, b, index, index);
      if(!result.{core::num::==}(0))
        return result;
      return aChar.{core::num::-}(bChar).{core::int::sign};
    }
    core::int aIndex = index;
    core::int bIndex = index;
    if(aChar.{core::num::==}(com6::_zero)) {
      do {
        aIndex = aIndex.{core::num::+}(1);
        if(aIndex.{core::num::==}(a.{core::String::length}))
          return 1.{core::int::unary-}();
        aChar = a.{core::String::codeUnitAt}(aIndex);
      }
      while (aChar.{core::num::==}(com6::_zero))
      if(!com6::_isDigit(aChar))
        return 1.{core::int::unary-}();
    }
    else
      if(bChar.{core::num::==}(com6::_zero)) {
        do {
          bIndex = bIndex.{core::num::+}(1);
          if(bIndex.{core::num::==}(b.{core::String::length}))
            return 1;
          bChar = b.{core::String::codeUnitAt}(bIndex);
        }
        while (bChar.{core::num::==}(com6::_zero))
        if(!com6::_isDigit(bChar))
          return 1;
      }
    if(!aChar.{core::num::==}(bChar)) {
      core::int result = com6::_compareDigitCount(a, b, aIndex, bIndex);
      if(!result.{core::num::==}(0))
        return result;
      return aChar.{core::num::-}(bChar).{core::int::sign};
    }
    #L109:
    while (true)
      #L110:
      {
        core::bool aIsDigit = false;
        core::bool bIsDigit = false;
        aChar = 0;
        bChar = 0;
        if((aIndex = aIndex.{core::num::+}(1)).{core::num::<}(a.{core::String::length})) {
          aChar = a.{core::String::codeUnitAt}(aIndex);
          aIsDigit = com6::_isDigit(aChar);
        }
        if((bIndex = bIndex.{core::num::+}(1)).{core::num::<}(b.{core::String::length})) {
          bChar = b.{core::String::codeUnitAt}(bIndex);
          bIsDigit = com6::_isDigit(bChar);
        }
        if(aIsDigit) {
          if(bIsDigit) {
            if(aChar.{core::num::==}(bChar))
              break #L110;
            break #L109;
          }
          return 1;
        }
        else
          if(bIsDigit) {
            return 1.{core::int::unary-}();
          }
          else {
            return aIndex.{core::num::-}(bIndex).{core::int::sign};
          }
      }
    core::int result = com6::_compareDigitCount(a, b, aIndex, bIndex);
    if(!result.{core::num::==}(0))
      return result;
    return aChar.{core::num::-}(bChar).{core::int::sign};
  }
  static method _compareDigitCount(core::String a, core::String b, core::int i, core::int j) → core::int {
    while ((i = i.{core::num::+}(1)).{core::num::<}(a.{core::String::length}))
      #L111:
      {
        core::bool aIsDigit = com6::_isDigit(a.{core::String::codeUnitAt}(i));
        if((j = j.{core::num::+}(1)).{core::num::==}(b.{core::String::length}))
          return aIsDigit ?{core::int} 1 : 0;
        core::bool bIsDigit = com6::_isDigit(b.{core::String::codeUnitAt}(j));
        if(aIsDigit) {
          if(bIsDigit)
            break #L111;
          return 1;
        }
        else
          if(bIsDigit) {
            return 1.{core::int::unary-}();
          }
          else {
            return 0;
          }
      }
    if((j = j.{core::num::+}(1)).{core::num::<}(b.{core::String::length}) && com6::_isDigit(b.{core::String::codeUnitAt}(j))) {
      return 1.{core::int::unary-}();
    }
    return 0;
  }
  static method _isDigit(core::int charCode) → core::bool
    return charCode.{core::int::^}(com6::_zero).{core::num::<=}(9);
  static method _isNonZeroNumberSuffix(core::String string, core::int index) → core::bool {
    while ((index = index.{core::num::-}(1)).{core::num::>=}(0)) {
      core::int char = string.{core::String::codeUnitAt}(index);
      if(!char.{core::num::==}(com6::_zero))
        return com6::_isDigit(char);
    }
    return false;
  }
}
library from "package:collection/src/equality.dart" as equ {
  import "dart:collection";
  import "package:collection/src/comparators.dart";
  typedef _GetKey<E extends core::Object = dynamic, F extends core::Object = dynamic> = (E) → F;
  abstract class Equality<E extends core::Object = dynamic> extends core::Object {
    static field dynamic _redirecting# = <dynamic>[equ::Equality::•];
    static factory •<E extends core::Object = dynamic>() → equ::Equality<equ::Equality::•::E>
      let dynamic #redirecting_factory = equ::DefaultEquality::• in let equ::Equality::•::E #typeArg0 = null in invalid-expression;
    abstract method equals(generic-covariant-impl equ::Equality::E e1, generic-covariant-impl equ::Equality::E e2) → core::bool;
    abstract method hash(generic-covariant-impl equ::Equality::E e) → core::int;
    abstract method isValidKey(core::Object o) → core::bool;
  }
  class EqualityBy<E extends core::Object = dynamic, F extends core::Object = dynamic> extends core::Object implements equ::Equality<equ::EqualityBy::E> {
    final field (equ::EqualityBy::E) → equ::EqualityBy::F _getKey;
    final field equ::Equality<equ::EqualityBy::F> _inner;
    constructor •((equ::EqualityBy::E) → equ::EqualityBy::F getKey, [equ::Equality<equ::EqualityBy::F> inner = const equ::DefaultEquality::•<core::Null>()]) → void
      : equ::EqualityBy::_getKey = getKey, equ::EqualityBy::_inner = inner, super core::Object::•()
      ;
    method equals(generic-covariant-impl equ::EqualityBy::E e1, generic-covariant-impl equ::EqualityBy::E e2) → core::bool
      return this.{equ::EqualityBy::_inner}.{equ::Equality::equals}(this.{equ::EqualityBy::_getKey}(e1), this.{equ::EqualityBy::_getKey}(e2));
    method hash(generic-covariant-impl equ::EqualityBy::E e) → core::int
      return this.{equ::EqualityBy::_inner}.{equ::Equality::hash}(this.{equ::EqualityBy::_getKey}(e));
    method isValidKey(core::Object o) → core::bool {
      if(o is equ::EqualityBy::E) {
        final equ::EqualityBy::F value = this.{equ::EqualityBy::_getKey}(o{equ::EqualityBy::E});
        return value is equ::EqualityBy::F && this.{equ::EqualityBy::_inner}.{equ::Equality::isValidKey}(value{equ::EqualityBy::F});
      }
      return false;
    }
  }
  class DefaultEquality<E extends core::Object = dynamic> extends core::Object implements equ::Equality<equ::DefaultEquality::E> {
    const constructor •() → void
      : super core::Object::•()
      ;
    method equals(generic-covariant-impl core::Object e1, generic-covariant-impl core::Object e2) → core::bool
      return e1.{core::Object::==}(e2);
    method hash(generic-covariant-impl core::Object e) → core::int
      return e.{core::Object::hashCode};
    method isValidKey(core::Object o) → core::bool
      return true;
  }
  class IdentityEquality<E extends core::Object = dynamic> extends core::Object implements equ::Equality<equ::IdentityEquality::E> {
    const constructor •() → void
      : super core::Object::•()
      ;
    method equals(generic-covariant-impl equ::IdentityEquality::E e1, generic-covariant-impl equ::IdentityEquality::E e2) → core::bool
      return core::identical(e1, e2);
    method hash(generic-covariant-impl equ::IdentityEquality::E e) → core::int
      return core::identityHashCode(e);
    method isValidKey(core::Object o) → core::bool
      return true;
  }
  class IterableEquality<E extends core::Object = dynamic> extends core::Object implements equ::Equality<core::Iterable<equ::IterableEquality::E>> {
    final field equ::Equality<equ::IterableEquality::E> _elementEquality;
    const constructor •([equ::Equality<equ::IterableEquality::E> elementEquality = const equ::DefaultEquality::•<core::Null>()]) → void
      : equ::IterableEquality::_elementEquality = elementEquality, super core::Object::•()
      ;
    method equals(generic-covariant-impl core::Iterable<equ::IterableEquality::E> elements1, generic-covariant-impl core::Iterable<equ::IterableEquality::E> elements2) → core::bool {
      if(core::identical(elements1, elements2))
        return true;
      if(elements1.{core::Object::==}(null) || elements2.{core::Object::==}(null))
        return false;
      core::Iterator<equ::IterableEquality::E> it1 = elements1.{core::Iterable::iterator};
      core::Iterator<equ::IterableEquality::E> it2 = elements2.{core::Iterable::iterator};
      while (true) {
        core::bool hasNext = it1.{core::Iterator::moveNext}();
        if(!hasNext.{core::Object::==}(it2.{core::Iterator::moveNext}()))
          return false;
        if(!hasNext)
          return true;
        if(!this.{equ::IterableEquality::_elementEquality}.{equ::Equality::equals}(it1.{core::Iterator::current}, it2.{core::Iterator::current}))
          return false;
      }
    }
    method hash(generic-covariant-impl core::Iterable<equ::IterableEquality::E> elements) → core::int {
      if(elements.{core::Object::==}(null))
        return null.{core::Null::hashCode};
      core::int hash = 0;
      for (equ::IterableEquality::E element in elements) {
        core::int c = this.{equ::IterableEquality::_elementEquality}.{equ::Equality::hash}(element);
        hash = hash.{core::num::+}(c).{core::int::&}(equ::_HASH_MASK);
        hash = hash.{core::num::+}(hash.{core::int::<<}(10)).{core::int::&}(equ::_HASH_MASK);
        hash = hash.{core::int::^}(hash.{core::int::>>}(6));
      }
      hash = hash.{core::num::+}(hash.{core::int::<<}(3)).{core::int::&}(equ::_HASH_MASK);
      hash = hash.{core::int::^}(hash.{core::int::>>}(11));
      hash = hash.{core::num::+}(hash.{core::int::<<}(15)).{core::int::&}(equ::_HASH_MASK);
      return hash;
    }
    method isValidKey(core::Object o) → core::bool
      return o is core::Iterable<equ::IterableEquality::E>;
  }
  class ListEquality<E extends core::Object = dynamic> extends core::Object implements equ::Equality<core::List<equ::ListEquality::E>> {
    final field equ::Equality<equ::ListEquality::E> _elementEquality;
    const constructor •([equ::Equality<equ::ListEquality::E> elementEquality = const equ::DefaultEquality::•<core::Null>()]) → void
      : equ::ListEquality::_elementEquality = elementEquality, super core::Object::•()
      ;
    method equals(generic-covariant-impl core::List<equ::ListEquality::E> list1, generic-covariant-impl core::List<equ::ListEquality::E> list2) → core::bool {
      if(core::identical(list1, list2))
        return true;
      if(list1.{core::Object::==}(null) || list2.{core::Object::==}(null))
        return false;
      core::int length = list1.{core::List::length};
      if(!length.{core::num::==}(list2.{core::List::length}))
        return false;
      for (core::int i = 0; i.{core::num::<}(length); i = i.{core::num::+}(1)) {
        if(!this.{equ::ListEquality::_elementEquality}.{equ::Equality::equals}(list1.{core::List::[]}(i), list2.{core::List::[]}(i)))
          return false;
      }
      return true;
    }
    method hash(generic-covariant-impl core::List<equ::ListEquality::E> list) → core::int {
      if(list.{core::Object::==}(null))
        return null.{core::Null::hashCode};
      core::int hash = 0;
      for (core::int i = 0; i.{core::num::<}(list.{core::List::length}); i = i.{core::num::+}(1)) {
        core::int c = this.{equ::ListEquality::_elementEquality}.{equ::Equality::hash}(list.{core::List::[]}(i));
        hash = hash.{core::num::+}(c).{core::int::&}(equ::_HASH_MASK);
        hash = hash.{core::num::+}(hash.{core::int::<<}(10)).{core::int::&}(equ::_HASH_MASK);
        hash = hash.{core::int::^}(hash.{core::int::>>}(6));
      }
      hash = hash.{core::num::+}(hash.{core::int::<<}(3)).{core::int::&}(equ::_HASH_MASK);
      hash = hash.{core::int::^}(hash.{core::int::>>}(11));
      hash = hash.{core::num::+}(hash.{core::int::<<}(15)).{core::int::&}(equ::_HASH_MASK);
      return hash;
    }
    method isValidKey(core::Object o) → core::bool
      return o is core::List<equ::ListEquality::E>;
  }
  abstract class _UnorderedEquality<E extends core::Object = dynamic, T extends core::Iterable<equ::_UnorderedEquality::E> = core::Iterable<dynamic>> extends core::Object implements equ::Equality<equ::_UnorderedEquality::T> {
    final field equ::Equality<equ::_UnorderedEquality::E> _elementEquality;
    const constructor •(equ::Equality<equ::_UnorderedEquality::E> _elementEquality) → void
      : equ::_UnorderedEquality::_elementEquality = _elementEquality, super core::Object::•()
      ;
    method equals(generic-covariant-impl equ::_UnorderedEquality::T elements1, generic-covariant-impl equ::_UnorderedEquality::T elements2) → core::bool {
      if(core::identical(elements1, elements2))
        return true;
      if(elements1.{core::Object::==}(null) || elements2.{core::Object::==}(null))
        return false;
      col::HashMap<equ::_UnorderedEquality::E, core::int> counts = col::HashMap::•<equ::_UnorderedEquality::E, core::int>(equals: this.{equ::_UnorderedEquality::_elementEquality}.{equ::Equality::equals}, hashCode: this.{equ::_UnorderedEquality::_elementEquality}.{equ::Equality::hash}, isValidKey: this.{equ::_UnorderedEquality::_elementEquality}.{equ::Equality::isValidKey});
      core::int length = 0;
      for (equ::_UnorderedEquality::E e in elements1) {
        core::int count = counts.{core::Map::[]}(e);
        if(count.{core::num::==}(null))
          count = 0;
        counts.{core::Map::[]=}(e, count.{core::num::+}(1));
        length = length.{core::num::+}(1);
      }
      for (equ::_UnorderedEquality::E e in elements2) {
        core::int count = counts.{core::Map::[]}(e);
        if(count.{core::num::==}(null) || count.{core::num::==}(0))
          return false;
        counts.{core::Map::[]=}(e, count.{core::num::-}(1));
        length = length.{core::num::-}(1);
      }
      return length.{core::num::==}(0);
    }
    method hash(generic-covariant-impl equ::_UnorderedEquality::T elements) → core::int {
      if(elements.{core::Object::==}(null))
        return null.{core::Null::hashCode};
      core::int hash = 0;
      for (equ::_UnorderedEquality::E element in elements) {
        core::int c = this.{equ::_UnorderedEquality::_elementEquality}.{equ::Equality::hash}(element);
        hash = hash.{core::num::+}(c).{core::int::&}(equ::_HASH_MASK);
      }
      hash = hash.{core::num::+}(hash.{core::int::<<}(3)).{core::int::&}(equ::_HASH_MASK);
      hash = hash.{core::int::^}(hash.{core::int::>>}(11));
      hash = hash.{core::num::+}(hash.{core::int::<<}(15)).{core::int::&}(equ::_HASH_MASK);
      return hash;
    }
  }
  class UnorderedIterableEquality<E extends core::Object = dynamic> extends equ::_UnorderedEquality<equ::UnorderedIterableEquality::E, core::Iterable<equ::UnorderedIterableEquality::E>> {
    const constructor •([equ::Equality<equ::UnorderedIterableEquality::E> elementEquality = const equ::DefaultEquality::•<core::Null>()]) → void
      : super equ::_UnorderedEquality::•(elementEquality)
      ;
    method isValidKey(core::Object o) → core::bool
      return o is core::Iterable<equ::UnorderedIterableEquality::E>;
  }
  class SetEquality<E extends core::Object = dynamic> extends equ::_UnorderedEquality<equ::SetEquality::E, core::Set<equ::SetEquality::E>> {
    const constructor •([equ::Equality<equ::SetEquality::E> elementEquality = const equ::DefaultEquality::•<core::Null>()]) → void
      : super equ::_UnorderedEquality::•(elementEquality)
      ;
    method isValidKey(core::Object o) → core::bool
      return o is core::Set<equ::SetEquality::E>;
  }
  class _MapEntry extends core::Object {
    final field equ::MapEquality<dynamic, dynamic> equality;
    final field dynamic key;
    final field dynamic value;
    constructor •(equ::MapEquality<dynamic, dynamic> equality, dynamic key, dynamic value) → void
      : equ::_MapEntry::equality = equality, equ::_MapEntry::key = key, equ::_MapEntry::value = value, super core::Object::•()
      ;
    get hashCode() → core::int
      return 3.{core::num::*}(this.{equ::_MapEntry::equality}.{equ::MapEquality::_keyEquality}.{equ::Equality::hash}(this.{equ::_MapEntry::key})).{core::num::+}(7.{core::num::*}(this.{equ::_MapEntry::equality}.{equ::MapEquality::_valueEquality}.{equ::Equality::hash}(this.{equ::_MapEntry::value}))).{core::int::&}(equ::_HASH_MASK);
    operator ==(core::Object other) → core::bool
      return other is equ::_MapEntry && this.{equ::_MapEntry::equality}.{equ::MapEquality::_keyEquality}.{equ::Equality::equals}(this.{equ::_MapEntry::key}, other{equ::_MapEntry}.{equ::_MapEntry::key}) && this.{equ::_MapEntry::equality}.{equ::MapEquality::_valueEquality}.{equ::Equality::equals}(this.{equ::_MapEntry::value}, other{equ::_MapEntry}.{equ::_MapEntry::value});
  }
  class MapEquality<K extends core::Object = dynamic, V extends core::Object = dynamic> extends core::Object implements equ::Equality<core::Map<equ::MapEquality::K, equ::MapEquality::V>> {
    final field equ::Equality<equ::MapEquality::K> _keyEquality;
    final field equ::Equality<equ::MapEquality::V> _valueEquality;
    const constructor •({equ::Equality<equ::MapEquality::K> keys = const equ::DefaultEquality::•<core::Null>(), equ::Equality<equ::MapEquality::V> values = const equ::DefaultEquality::•<core::Null>()}) → void
      : equ::MapEquality::_keyEquality = keys, equ::MapEquality::_valueEquality = values, super core::Object::•()
      ;
    method equals(generic-covariant-impl core::Map<equ::MapEquality::K, equ::MapEquality::V> map1, generic-covariant-impl core::Map<equ::MapEquality::K, equ::MapEquality::V> map2) → core::bool {
      if(core::identical(map1, map2))
        return true;
      if(map1.{core::Object::==}(null) || map2.{core::Object::==}(null))
        return false;
      core::int length = map1.{core::Map::length};
      if(!length.{core::num::==}(map2.{core::Map::length}))
        return false;
      core::Map<equ::_MapEntry, core::int> equalElementCounts = col::HashMap::•<equ::_MapEntry, core::int>();
      for (equ::MapEquality::K key in map1.{core::Map::keys}) {
        equ::_MapEntry entry = new equ::_MapEntry::•(this, key, map1.{core::Map::[]}(key));
        core::int count = equalElementCounts.{core::Map::[]}(entry);
        if(count.{core::num::==}(null))
          count = 0;
        equalElementCounts.{core::Map::[]=}(entry, count.{core::num::+}(1));
      }
      for (equ::MapEquality::K key in map2.{core::Map::keys}) {
        equ::_MapEntry entry = new equ::_MapEntry::•(this, key, map2.{core::Map::[]}(key));
        core::int count = equalElementCounts.{core::Map::[]}(entry);
        if(count.{core::num::==}(null) || count.{core::num::==}(0))
          return false;
        equalElementCounts.{core::Map::[]=}(entry, count.{core::num::-}(1));
      }
      return true;
    }
    method hash(generic-covariant-impl core::Map<equ::MapEquality::K, equ::MapEquality::V> map) → core::int {
      if(map.{core::Object::==}(null))
        return null.{core::Null::hashCode};
      core::int hash = 0;
      for (equ::MapEquality::K key in map.{core::Map::keys}) {
        core::int keyHash = this.{equ::MapEquality::_keyEquality}.{equ::Equality::hash}(key);
        core::int valueHash = this.{equ::MapEquality::_valueEquality}.{equ::Equality::hash}(map.{core::Map::[]}(key));
        hash = hash.{core::num::+}(3.{core::num::*}(keyHash)).{core::num::+}(7.{core::num::*}(valueHash)).{core::int::&}(equ::_HASH_MASK);
      }
      hash = hash.{core::num::+}(hash.{core::int::<<}(3)).{core::int::&}(equ::_HASH_MASK);
      hash = hash.{core::int::^}(hash.{core::int::>>}(11));
      hash = hash.{core::num::+}(hash.{core::int::<<}(15)).{core::int::&}(equ::_HASH_MASK);
      return hash;
    }
    method isValidKey(core::Object o) → core::bool
      return o is core::Map<equ::MapEquality::K, equ::MapEquality::V>;
  }
  class MultiEquality<E extends core::Object = dynamic> extends core::Object implements equ::Equality<equ::MultiEquality::E> {
    final field core::Iterable<equ::Equality<equ::MultiEquality::E>> _equalities;
    const constructor •(core::Iterable<equ::Equality<equ::MultiEquality::E>> equalities) → void
      : equ::MultiEquality::_equalities = equalities, super core::Object::•()
      ;
    method equals(generic-covariant-impl equ::MultiEquality::E e1, generic-covariant-impl equ::MultiEquality::E e2) → core::bool {
      for (equ::Equality<equ::MultiEquality::E> eq in this.{equ::MultiEquality::_equalities}) {
        if(eq.{equ::Equality::isValidKey}(e1))
          return eq.{equ::Equality::isValidKey}(e2) && eq.{equ::Equality::equals}(e1, e2);
      }
      return false;
    }
    method hash(generic-covariant-impl equ::MultiEquality::E e) → core::int {
      for (equ::Equality<equ::MultiEquality::E> eq in this.{equ::MultiEquality::_equalities}) {
        if(eq.{equ::Equality::isValidKey}(e))
          return eq.{equ::Equality::hash}(e);
      }
      return 0;
    }
    method isValidKey(core::Object o) → core::bool {
      for (equ::Equality<equ::MultiEquality::E> eq in this.{equ::MultiEquality::_equalities}) {
        if(eq.{equ::Equality::isValidKey}(o))
          return true;
      }
      return false;
    }
  }
  class DeepCollectionEquality extends core::Object implements equ::Equality<dynamic> {
    final field equ::Equality<dynamic> _base;
    final field core::bool _unordered;
    const constructor •([equ::Equality<dynamic> base = const equ::DefaultEquality::•<dynamic>()]) → void
      : equ::DeepCollectionEquality::_base = base, equ::DeepCollectionEquality::_unordered = false, super core::Object::•()
      ;
    const constructor unordered([equ::Equality<dynamic> base = const equ::DefaultEquality::•<dynamic>()]) → void
      : equ::DeepCollectionEquality::_base = base, equ::DeepCollectionEquality::_unordered = true, super core::Object::•()
      ;
    method equals(generic-covariant-impl dynamic e1, generic-covariant-impl dynamic e2) → core::bool {
      if(e1 is core::Set<dynamic>) {
        return e2 is core::Set<dynamic> && new equ::SetEquality::•<dynamic>(this).{equ::_UnorderedEquality::equals}(e1{core::Set<dynamic>}, e2{core::Set<dynamic>});
      }
      if(e1 is core::Map<dynamic, dynamic>) {
        return e2 is core::Map<dynamic, dynamic> && new equ::MapEquality::•<dynamic, dynamic>(keys: this, values: this).{equ::MapEquality::equals}(e1{core::Map<dynamic, dynamic>}, e2{core::Map<dynamic, dynamic>});
      }
      if(!this.{equ::DeepCollectionEquality::_unordered}) {
        if(e1 is core::List<dynamic>) {
          return e2 is core::List<dynamic> && new equ::ListEquality::•<dynamic>(this).{equ::ListEquality::equals}(e1{core::List<dynamic>}, e2{core::List<dynamic>});
        }
        if(e1 is core::Iterable<dynamic>) {
          return e2 is core::Iterable<dynamic> && new equ::IterableEquality::•<dynamic>(this).{equ::IterableEquality::equals}(e1{core::Iterable<dynamic>}, e2{core::Iterable<dynamic>});
        }
      }
      else
        if(e1 is core::Iterable<dynamic>) {
          if(!(e1{core::Iterable<dynamic>} is core::List<dynamic>).{core::Object::==}(e2 is core::List<dynamic>))
            return false;
          return e2 is core::Iterable<dynamic> && new equ::UnorderedIterableEquality::•<dynamic>(this).{equ::_UnorderedEquality::equals}(e1{core::Iterable<dynamic>}, e2{core::Iterable<dynamic>});
        }
      return this.{equ::DeepCollectionEquality::_base}.{equ::Equality::equals}(e1, e2);
    }
    method hash(generic-covariant-impl core::Object o) → core::int {
      if(o is core::Set<dynamic>)
        return new equ::SetEquality::•<dynamic>(this).{equ::_UnorderedEquality::hash}(o{core::Set<dynamic>});
      if(o is core::Map<dynamic, dynamic>)
        return new equ::MapEquality::•<dynamic, dynamic>(keys: this, values: this).{equ::MapEquality::hash}(o{core::Map<dynamic, dynamic>});
      if(!this.{equ::DeepCollectionEquality::_unordered}) {
        if(o is core::List<dynamic>)
          return new equ::ListEquality::•<dynamic>(this).{equ::ListEquality::hash}(o{core::List<dynamic>});
        if(o is core::Iterable<dynamic>)
          return new equ::IterableEquality::•<dynamic>(this).{equ::IterableEquality::hash}(o{core::Iterable<dynamic>});
      }
      else
        if(o is core::Iterable<dynamic>) {
          return new equ::UnorderedIterableEquality::•<dynamic>(this).{equ::_UnorderedEquality::hash}(o{core::Iterable<dynamic>});
        }
      return this.{equ::DeepCollectionEquality::_base}.{equ::Equality::hash}(o);
    }
    method isValidKey(core::Object o) → core::bool
      return o is core::Iterable<dynamic> || o is core::Map<dynamic, dynamic> || this.{equ::DeepCollectionEquality::_base}.{equ::Equality::isValidKey}(o);
  }
  class CaseInsensitiveEquality extends core::Object implements equ::Equality<core::String> {
    const constructor •() → void
      : super core::Object::•()
      ;
    method equals(generic-covariant-impl core::String string1, generic-covariant-impl core::String string2) → core::bool
      return com6::equalsIgnoreAsciiCase(string1, string2);
    method hash(generic-covariant-impl core::String string) → core::int
      return com6::hashIgnoreAsciiCase(string);
    method isValidKey(core::Object object) → core::bool
      return object is core::String;
  }
  static const field core::int _HASH_MASK = 2147483647;
}
library from "package:collection/src/equality_map.dart" as equ2 {
  import "dart:collection";
  import "package:collection/src/equality.dart";
  import "package:collection/src/wrappers.dart";
  class EqualityMap<K extends core::Object = dynamic, V extends core::Object = dynamic> extends wra::DelegatingMap<equ2::EqualityMap::K, equ2::EqualityMap::V> {
    constructor •(equ::Equality<equ2::EqualityMap::K> equality) → void
      : super wra::DelegatingMap::•(col::LinkedHashMap::•<equ2::EqualityMap::K, equ2::EqualityMap::V>(equals: equality.{equ::Equality::equals}, hashCode: equality.{equ::Equality::hash}, isValidKey: equality.{equ::Equality::isValidKey}))
      ;
    constructor from(equ::Equality<equ2::EqualityMap::K> equality, core::Map<equ2::EqualityMap::K, equ2::EqualityMap::V> other) → void
      : super wra::DelegatingMap::•(col::LinkedHashMap::•<equ2::EqualityMap::K, equ2::EqualityMap::V>(equals: equality.{equ::Equality::equals}, hashCode: equality.{equ::Equality::hash}, isValidKey: equality.{equ::Equality::isValidKey})) {
      this.{wra::DelegatingMap::addAll}(other);
    }
  }
}
library from "package:collection/src/equality_set.dart" as equ3 {
  import "dart:collection";
  import "package:collection/src/equality.dart";
  import "package:collection/src/wrappers.dart";
  class EqualitySet<E extends core::Object = dynamic> extends wra::DelegatingSet<equ3::EqualitySet::E> {
    constructor •(equ::Equality<equ3::EqualitySet::E> equality) → void
      : super wra::DelegatingSet::•(col::LinkedHashSet::•<equ3::EqualitySet::E>(equals: equality.{equ::Equality::equals}, hashCode: equality.{equ::Equality::hash}, isValidKey: equality.{equ::Equality::isValidKey}))
      ;
    constructor from(equ::Equality<equ3::EqualitySet::E> equality, core::Iterable<equ3::EqualitySet::E> other) → void
      : super wra::DelegatingSet::•(col::LinkedHashSet::•<equ3::EqualitySet::E>(equals: equality.{equ::Equality::equals}, hashCode: equality.{equ::Equality::hash}, isValidKey: equality.{equ::Equality::isValidKey})) {
      this.{wra::DelegatingSet::addAll}(other);
    }
  }
}
library from "package:collection/src/functions.dart" as fun {
  import "dart:collection";
  import "dart:math" as math;
  import "package:collection/src/utils.dart";
  static method mapMap<K1 extends core::Object = dynamic, V1 extends core::Object = dynamic, K2 extends core::Object = dynamic, V2 extends core::Object = dynamic>(core::Map<fun::mapMap::K1, fun::mapMap::V1> map, {(fun::mapMap::K1, fun::mapMap::V1) → fun::mapMap::K2 key = null, (fun::mapMap::K1, fun::mapMap::V1) → fun::mapMap::V2 value = null}) → core::Map<fun::mapMap::K2, fun::mapMap::V2> {
    key.{core::Object::==}(null) ?{(fun::mapMap::K1, fun::mapMap::V1) → fun::mapMap::K2} key = (fun::mapMap::K1 mapKey, fun::mapMap::V1 _) → fun::mapMap::K2 => mapKey as fun::mapMap::K2 : null;
    value.{core::Object::==}(null) ?{(fun::mapMap::K1, fun::mapMap::V1) → fun::mapMap::V2} value = (fun::mapMap::K1 _, fun::mapMap::V1 mapValue) → fun::mapMap::V2 => mapValue as fun::mapMap::V2 : null;
    core::Map<fun::mapMap::K2, fun::mapMap::V2> result = <fun::mapMap::K2, fun::mapMap::V2>{};
    map.{core::Map::forEach}((fun::mapMap::K1 mapKey, fun::mapMap::V1 mapValue) → core::Null {
      result.{core::Map::[]=}(key.call(mapKey, mapValue), value.call(mapKey, mapValue));
    });
    return result;
  }
  static method mergeMaps<K extends core::Object = dynamic, V extends core::Object = dynamic>(core::Map<fun::mergeMaps::K, fun::mergeMaps::V> map1, core::Map<fun::mergeMaps::K, fun::mergeMaps::V> map2, {(fun::mergeMaps::V, fun::mergeMaps::V) → fun::mergeMaps::V value = null}) → core::Map<fun::mergeMaps::K, fun::mergeMaps::V> {
    core::Map<fun::mergeMaps::K, fun::mergeMaps::V> result = col::LinkedHashMap::from<fun::mergeMaps::K, fun::mergeMaps::V>(map1);
    if(value.{core::Object::==}(null))
      return let final core::Map<fun::mergeMaps::K, fun::mergeMaps::V> #t652 = result in let final dynamic #t653 = #t652.{core::Map::addAll}(map2) in #t652;
    map2.{core::Map::forEach}((fun::mergeMaps::K key, fun::mergeMaps::V mapValue) → core::Null {
      result.{core::Map::[]=}(key, result.{core::Map::containsKey}(key) ?{fun::mergeMaps::V} value.call(result.{core::Map::[]}(key), mapValue) : mapValue);
    });
    return result;
  }
  static method groupBy<S extends core::Object = dynamic, T extends core::Object = dynamic>(core::Iterable<fun::groupBy::S> values, (fun::groupBy::S) → fun::groupBy::T key) → core::Map<fun::groupBy::T, core::List<fun::groupBy::S>> {
    core::Map<fun::groupBy::T, core::List<fun::groupBy::S>> map = <fun::groupBy::T, core::List<fun::groupBy::S>>{};
    for (fun::groupBy::S element in values) {
      core::List<fun::groupBy::S> list = map.{core::Map::putIfAbsent}(key.call(element), () → core::List<fun::groupBy::S> => <fun::groupBy::S>[]);
      list.{core::List::add}(element);
    }
    return map;
  }
  static method minBy<S extends core::Object = dynamic, T extends core::Object = dynamic>(core::Iterable<fun::minBy::S> values, (fun::minBy::S) → fun::minBy::T orderBy, {(fun::minBy::T, fun::minBy::T) → core::int compare = null}) → fun::minBy::S {
    compare.{core::Object::==}(null) ?{(fun::minBy::T, fun::minBy::T) → core::int} compare = uti5::defaultCompare<fun::minBy::T>() : null;
    fun::minBy::S minValue;
    fun::minBy::T minOrderBy;
    for (fun::minBy::S element in values) {
      fun::minBy::T elementOrderBy = orderBy.call(element);
      if(minOrderBy.{core::Object::==}(null) || compare.call(elementOrderBy, minOrderBy).{core::num::<}(0)) {
        minValue = element;
        minOrderBy = elementOrderBy;
      }
    }
    return minValue;
  }
  static method maxBy<S extends core::Object = dynamic, T extends core::Object = dynamic>(core::Iterable<fun::maxBy::S> values, (fun::maxBy::S) → fun::maxBy::T orderBy, {(fun::maxBy::T, fun::maxBy::T) → core::int compare = null}) → fun::maxBy::S {
    compare.{core::Object::==}(null) ?{(fun::maxBy::T, fun::maxBy::T) → core::int} compare = uti5::defaultCompare<fun::maxBy::T>() : null;
    fun::maxBy::S maxValue;
    fun::maxBy::T maxOrderBy;
    for (fun::maxBy::S element in values) {
      fun::maxBy::T elementOrderBy = orderBy.call(element);
      if(maxOrderBy.{core::Object::==}(null) || compare.call(elementOrderBy, maxOrderBy).{core::num::>}(0)) {
        maxValue = element;
        maxOrderBy = elementOrderBy;
      }
    }
    return maxValue;
  }
  static method transitiveClosure<T extends core::Object = dynamic>(core::Map<fun::transitiveClosure::T, core::Iterable<fun::transitiveClosure::T>> graph) → core::Map<fun::transitiveClosure::T, core::Set<fun::transitiveClosure::T>> {
    core::Map<fun::transitiveClosure::T, core::Set<fun::transitiveClosure::T>> result = <fun::transitiveClosure::T, core::Set<fun::transitiveClosure::T>>{};
    graph.{core::Map::forEach}((fun::transitiveClosure::T vertex, core::Iterable<fun::transitiveClosure::T> edges) → core::Null {
      result.{core::Map::[]=}(vertex, col::LinkedHashSet::from<fun::transitiveClosure::T>(edges));
    });
    core::List<fun::transitiveClosure::T> keys = graph.{core::Map::keys}.{core::Iterable::toList}();
    for (fun::transitiveClosure::T vertex1 in keys) {
      for (fun::transitiveClosure::T vertex2 in keys) {
        for (fun::transitiveClosure::T vertex3 in keys) {
          if(result.{core::Map::[]}(vertex2).{core::Set::contains}(vertex1) && result.{core::Map::[]}(vertex1).{core::Set::contains}(vertex3)) {
            result.{core::Map::[]}(vertex2).{core::Set::add}(vertex3);
          }
        }
      }
    }
    return result;
  }
  static method stronglyConnectedComponents<T extends core::Object = dynamic>(core::Map<fun::stronglyConnectedComponents::T, core::Iterable<fun::stronglyConnectedComponents::T>> graph) → core::List<core::Set<fun::stronglyConnectedComponents::T>> {
    core::int index = 0;
    core::List<fun::stronglyConnectedComponents::T> stack = <fun::stronglyConnectedComponents::T>[];
    core::List<core::Set<fun::stronglyConnectedComponents::T>> result = <core::Set<fun::stronglyConnectedComponents::T>>[];
    col::HashMap<fun::stronglyConnectedComponents::T, core::int> indices = col::HashMap::•<fun::stronglyConnectedComponents::T, core::int>();
    col::HashMap<fun::stronglyConnectedComponents::T, core::int> lowLinks = col::HashMap::•<fun::stronglyConnectedComponents::T, core::int>();
    col::HashSet<fun::stronglyConnectedComponents::T> onStack = col::HashSet::•<fun::stronglyConnectedComponents::T>();
    function strongConnect(fun::stronglyConnectedComponents::T vertex) → core::Null {
      indices.{core::Map::[]=}(vertex, index);
      lowLinks.{core::Map::[]=}(vertex, index);
      index = index.{core::num::+}(1);
      stack.{core::List::add}(vertex);
      onStack.{core::Set::add}(vertex);
      for (fun::stronglyConnectedComponents::T successor in graph.{core::Map::[]}(vertex)) {
        if(!indices.{core::Map::containsKey}(successor)) {
          strongConnect.call(successor);
          lowLinks.{core::Map::[]=}(vertex, math::min<core::int>(lowLinks.{core::Map::[]}(vertex), lowLinks.{core::Map::[]}(successor)));
        }
        else
          if(onStack.{core::Set::contains}(successor)) {
            lowLinks.{core::Map::[]=}(vertex, math::min<core::int>(lowLinks.{core::Map::[]}(vertex), lowLinks.{core::Map::[]}(successor)));
          }
      }
      if(lowLinks.{core::Map::[]}(vertex).{core::num::==}(indices.{core::Map::[]}(vertex))) {
        core::Set<fun::stronglyConnectedComponents::T> component = col::LinkedHashSet::•<fun::stronglyConnectedComponents::T>();
        fun::stronglyConnectedComponents::T neighbor;
        do {
          neighbor = stack.{core::List::removeLast}();
          onStack.{core::Set::remove}(neighbor);
          component.{core::Set::add}(neighbor);
        }
        while (!neighbor.{core::Object::==}(vertex))
        result.{core::List::add}(component);
      }
    }
    for (fun::stronglyConnectedComponents::T vertex in graph.{core::Map::keys}) {
      if(!indices.{core::Map::containsKey}(vertex))
        strongConnect.call(vertex);
    }
    return result.{core::List::reversed}.{core::Iterable::toList}();
  }
}
library from "package:collection/src/iterable_zip.dart" as ite {
  import "dart:collection";
  class IterableZip<T extends core::Object = dynamic> extends col::IterableBase<core::List<ite::IterableZip::T>> {
    final field core::Iterable<core::Iterable<ite::IterableZip::T>> _iterables;
    constructor •(core::Iterable<core::Iterable<ite::IterableZip::T>> iterables) → void
      : ite::IterableZip::_iterables = iterables, super col::IterableBase::•()
      ;
    get iterator() → core::Iterator<core::List<ite::IterableZip::T>> {
      core::List<core::Iterator<ite::IterableZip::T>> iterators = this.{ite::IterableZip::_iterables}.{core::Iterable::map}<core::Iterator<ite::IterableZip::T>>((core::Iterable<ite::IterableZip::T> x) → core::Iterator<ite::IterableZip::T> => x.{core::Iterable::iterator}).{core::Iterable::toList}(growable: false);
      return new ite::_IteratorZip::•<ite::IterableZip::T>(iterators);
    }
  }
  class _IteratorZip<T extends core::Object = dynamic> extends core::Object implements core::Iterator<core::List<ite::_IteratorZip::T>> {
    final field core::List<core::Iterator<ite::_IteratorZip::T>> _iterators;
    generic-covariant-impl field core::List<ite::_IteratorZip::T> _current = null;
    constructor •(core::List<core::Iterator<ite::_IteratorZip::T>> iterators) → void
      : ite::_IteratorZip::_iterators = iterators, super core::Object::•()
      ;
    method moveNext() → core::bool {
      if(this.{ite::_IteratorZip::_iterators}.{core::Iterable::isEmpty})
        return false;
      for (core::int i = 0; i.{core::num::<}(this.{ite::_IteratorZip::_iterators}.{core::List::length}); i = i.{core::num::+}(1)) {
        if(!this.{ite::_IteratorZip::_iterators}.{core::List::[]}(i).{core::Iterator::moveNext}()) {
          this.{ite::_IteratorZip::_current} = null;
          return false;
        }
      }
      this.{ite::_IteratorZip::_current} = core::List::•<ite::_IteratorZip::T>(this.{ite::_IteratorZip::_iterators}.{core::List::length});
      for (core::int i = 0; i.{core::num::<}(this.{ite::_IteratorZip::_iterators}.{core::List::length}); i = i.{core::num::+}(1)) {
        this.{ite::_IteratorZip::_current}.{core::List::[]=}(i, this.{ite::_IteratorZip::_iterators}.{core::List::[]}(i).{core::Iterator::current});
      }
      return true;
    }
    get current() → core::List<ite::_IteratorZip::T>
      return this.{ite::_IteratorZip::_current};
  }
}
library from "package:collection/src/priority_queue.dart" as pri {
  import "dart:collection";
  import "package:collection/src/utils.dart";
  abstract class PriorityQueue<E extends core::Object = dynamic> extends core::Object {
    static field dynamic _redirecting# = <dynamic>[pri::PriorityQueue::•];
    static factory •<E extends core::Object = dynamic>([(pri::PriorityQueue::•::E, pri::PriorityQueue::•::E) → core::int comparison]) → pri::PriorityQueue<pri::PriorityQueue::•::E>
      let dynamic #redirecting_factory = pri::HeapPriorityQueue::• in let pri::PriorityQueue::•::E #typeArg0 = null in invalid-expression;
    abstract get length() → core::int;
    abstract get isEmpty() → core::bool;
    abstract get isNotEmpty() → core::bool;
    abstract method contains(generic-covariant-impl pri::PriorityQueue::E object) → core::bool;
    abstract method add(generic-covariant-impl pri::PriorityQueue::E element) → void;
    abstract method addAll(generic-covariant-impl core::Iterable<pri::PriorityQueue::E> elements) → void;
    abstract get first() → pri::PriorityQueue::E;
    abstract method removeFirst() → pri::PriorityQueue::E;
    abstract method remove(generic-covariant-impl pri::PriorityQueue::E element) → core::bool;
    abstract method removeAll() → core::Iterable<pri::PriorityQueue::E>;
    abstract method clear() → void;
    abstract method toList() → core::List<pri::PriorityQueue::E>;
    abstract method toSet() → core::Set<pri::PriorityQueue::E>;
  }
  class HeapPriorityQueue<E extends core::Object = dynamic> extends core::Object implements pri::PriorityQueue<pri::HeapPriorityQueue::E> {
    static const field core::int _INITIAL_CAPACITY = 7;
    final field (pri::HeapPriorityQueue::E, pri::HeapPriorityQueue::E) → core::int comparison;
    generic-covariant-impl field core::List<pri::HeapPriorityQueue::E> _queue = core::List::•<pri::HeapPriorityQueue::E>(pri::HeapPriorityQueue::_INITIAL_CAPACITY);
    field core::int _length = 0;
    constructor •([(pri::HeapPriorityQueue::E, pri::HeapPriorityQueue::E) → core::int comparison = null]) → void
      : pri::HeapPriorityQueue::comparison = let final (pri::HeapPriorityQueue::E, pri::HeapPriorityQueue::E) → core::int #t654 = comparison in #t654.==(null) ?{(pri::HeapPriorityQueue::E, pri::HeapPriorityQueue::E) → core::int} uti5::defaultCompare<pri::HeapPriorityQueue::E>() : #t654, super core::Object::•()
      ;
    method add(generic-covariant-impl pri::HeapPriorityQueue::E element) → void {
      this.{pri::HeapPriorityQueue::_add}(element);
    }
    method addAll(generic-covariant-impl core::Iterable<pri::HeapPriorityQueue::E> elements) → void {
      for (pri::HeapPriorityQueue::E element in elements) {
        this.{pri::HeapPriorityQueue::_add}(element);
      }
    }
    method clear() → void {
      this.{pri::HeapPriorityQueue::_queue} = const <core::Null>[];
      this.{pri::HeapPriorityQueue::_length} = 0;
    }
    method contains(generic-covariant-impl pri::HeapPriorityQueue::E object) → core::bool {
      return this.{pri::HeapPriorityQueue::_locate}(object).{core::num::>=}(0);
    }
    get first() → pri::HeapPriorityQueue::E {
      if(this.{pri::HeapPriorityQueue::_length}.{core::num::==}(0))
        throw new core::StateError::•("No such element");
      return this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(0);
    }
    get isEmpty() → core::bool
      return this.{pri::HeapPriorityQueue::_length}.{core::num::==}(0);
    get isNotEmpty() → core::bool
      return !this.{pri::HeapPriorityQueue::_length}.{core::num::==}(0);
    get length() → core::int
      return this.{pri::HeapPriorityQueue::_length};
    method remove(generic-covariant-impl pri::HeapPriorityQueue::E element) → core::bool {
      core::int index = this.{pri::HeapPriorityQueue::_locate}(element);
      if(index.{core::num::<}(0))
        return false;
      pri::HeapPriorityQueue::E last = this.{pri::HeapPriorityQueue::_removeLast}();
      if(index.{core::num::<}(this.{pri::HeapPriorityQueue::_length})) {
        core::int comp = this.{pri::HeapPriorityQueue::comparison}(last, element);
        if(comp.{core::num::<=}(0)) {
          this.{pri::HeapPriorityQueue::_bubbleUp}(last, index);
        }
        else {
          this.{pri::HeapPriorityQueue::_bubbleDown}(last, index);
        }
      }
      return true;
    }
    method removeAll() → core::Iterable<pri::HeapPriorityQueue::E> {
      core::List<pri::HeapPriorityQueue::E> result = this.{pri::HeapPriorityQueue::_queue};
      core::int length = this.{pri::HeapPriorityQueue::_length};
      this.{pri::HeapPriorityQueue::_queue} = const <core::Null>[];
      this.{pri::HeapPriorityQueue::_length} = 0;
      return result.{core::Iterable::take}(length);
    }
    method removeFirst() → pri::HeapPriorityQueue::E {
      if(this.{pri::HeapPriorityQueue::_length}.{core::num::==}(0))
        throw new core::StateError::•("No such element");
      pri::HeapPriorityQueue::E result = this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(0);
      pri::HeapPriorityQueue::E last = this.{pri::HeapPriorityQueue::_removeLast}();
      if(this.{pri::HeapPriorityQueue::_length}.{core::num::>}(0)) {
        this.{pri::HeapPriorityQueue::_bubbleDown}(last, 0);
      }
      return result;
    }
    method toList() → core::List<pri::HeapPriorityQueue::E> {
      core::List<pri::HeapPriorityQueue::E> list = let final core::List<pri::HeapPriorityQueue::E> #t655 = core::List::•<pri::HeapPriorityQueue::E>() in let final dynamic #t656 = #t655.{core::List::length} = this.{pri::HeapPriorityQueue::_length} in #t655;
      list.{core::List::setRange}(0, this.{pri::HeapPriorityQueue::_length}, this.{pri::HeapPriorityQueue::_queue});
      list.{core::List::sort}(this.{pri::HeapPriorityQueue::comparison});
      return list;
    }
    method toSet() → core::Set<pri::HeapPriorityQueue::E> {
      core::Set<pri::HeapPriorityQueue::E> set = new col::SplayTreeSet::•<pri::HeapPriorityQueue::E>(this.{pri::HeapPriorityQueue::comparison});
      for (core::int i = 0; i.{core::num::<}(this.{pri::HeapPriorityQueue::_length}); i = i.{core::num::+}(1)) {
        set.{core::Set::add}(this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(i));
      }
      return set;
    }
    method toString() → core::String {
      return this.{pri::HeapPriorityQueue::_queue}.{core::Iterable::take}(this.{pri::HeapPriorityQueue::_length}).{core::Iterable::toString}();
    }
    method _add(generic-covariant-impl pri::HeapPriorityQueue::E element) → void {
      if(this.{pri::HeapPriorityQueue::_length}.{core::num::==}(this.{pri::HeapPriorityQueue::_queue}.{core::List::length}))
        this.{pri::HeapPriorityQueue::_grow}();
      this.{pri::HeapPriorityQueue::_bubbleUp}(element, let final core::int #t657 = this.{pri::HeapPriorityQueue::_length} in let final core::int #t658 = this.{pri::HeapPriorityQueue::_length} = #t657.{core::num::+}(1) in #t657);
    }
    method _locate(generic-covariant-impl pri::HeapPriorityQueue::E object) → core::int {
      if(this.{pri::HeapPriorityQueue::_length}.{core::num::==}(0))
        return 1.{core::int::unary-}();
      core::int position = 1;
      do
        #L112:
        {
          core::int index = position.{core::num::-}(1);
          pri::HeapPriorityQueue::E element = this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(index);
          core::int comp = this.{pri::HeapPriorityQueue::comparison}(element, object);
          if(comp.{core::num::==}(0))
            return index;
          if(comp.{core::num::<}(0)) {
            core::int leftChildPosition = position.{core::num::*}(2);
            if(leftChildPosition.{core::num::<=}(this.{pri::HeapPriorityQueue::_length})) {
              position = leftChildPosition;
              break #L112;
            }
          }
          do {
            while (position.{core::int::isOdd}) {
              position = position.{core::int::>>}(1);
            }
            position = position.{core::num::+}(1);
          }
          while (position.{core::num::>}(this.{pri::HeapPriorityQueue::_length}))
        }
      while (!position.{core::num::==}(1))
      return 1.{core::int::unary-}();
    }
    method _removeLast() → pri::HeapPriorityQueue::E {
      core::int newLength = this.{pri::HeapPriorityQueue::_length}.{core::num::-}(1);
      pri::HeapPriorityQueue::E last = this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(newLength);
      this.{pri::HeapPriorityQueue::_queue}.{core::List::[]=}(newLength, null);
      this.{pri::HeapPriorityQueue::_length} = newLength;
      return last;
    }
    method _bubbleUp(generic-covariant-impl pri::HeapPriorityQueue::E element, core::int index) → void {
      #L113:
      while (index.{core::num::>}(0)) {
        core::int parentIndex = index.{core::num::-}(1).{core::num::~/}(2);
        pri::HeapPriorityQueue::E parent = this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(parentIndex);
        if(this.{pri::HeapPriorityQueue::comparison}(element, parent).{core::num::>}(0))
          break #L113;
        this.{pri::HeapPriorityQueue::_queue}.{core::List::[]=}(index, parent);
        index = parentIndex;
      }
      this.{pri::HeapPriorityQueue::_queue}.{core::List::[]=}(index, element);
    }
    method _bubbleDown(generic-covariant-impl pri::HeapPriorityQueue::E element, core::int index) → void {
      core::int rightChildIndex = index.{core::num::*}(2).{core::num::+}(2);
      while (rightChildIndex.{core::num::<}(this.{pri::HeapPriorityQueue::_length})) {
        core::int leftChildIndex = rightChildIndex.{core::num::-}(1);
        pri::HeapPriorityQueue::E leftChild = this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(leftChildIndex);
        pri::HeapPriorityQueue::E rightChild = this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(rightChildIndex);
        core::int comp = this.{pri::HeapPriorityQueue::comparison}(leftChild, rightChild);
        core::int minChildIndex;
        pri::HeapPriorityQueue::E minChild;
        if(comp.{core::num::<}(0)) {
          minChild = leftChild;
          minChildIndex = leftChildIndex;
        }
        else {
          minChild = rightChild;
          minChildIndex = rightChildIndex;
        }
        comp = this.{pri::HeapPriorityQueue::comparison}(element, minChild);
        if(comp.{core::num::<=}(0)) {
          this.{pri::HeapPriorityQueue::_queue}.{core::List::[]=}(index, element);
          return;
        }
        this.{pri::HeapPriorityQueue::_queue}.{core::List::[]=}(index, minChild);
        index = minChildIndex;
        rightChildIndex = index.{core::num::*}(2).{core::num::+}(2);
      }
      core::int leftChildIndex = rightChildIndex.{core::num::-}(1);
      if(leftChildIndex.{core::num::<}(this.{pri::HeapPriorityQueue::_length})) {
        pri::HeapPriorityQueue::E child = this.{pri::HeapPriorityQueue::_queue}.{core::List::[]}(leftChildIndex);
        core::int comp = this.{pri::HeapPriorityQueue::comparison}(element, child);
        if(comp.{core::num::>}(0)) {
          this.{pri::HeapPriorityQueue::_queue}.{core::List::[]=}(index, child);
          index = leftChildIndex;
        }
      }
      this.{pri::HeapPriorityQueue::_queue}.{core::List::[]=}(index, element);
    }
    method _grow() → void {
      core::int newCapacity = this.{pri::HeapPriorityQueue::_queue}.{core::List::length}.{core::num::*}(2).{core::num::+}(1);
      if(newCapacity.{core::num::<}(pri::HeapPriorityQueue::_INITIAL_CAPACITY))
        newCapacity = pri::HeapPriorityQueue::_INITIAL_CAPACITY;
      core::List<pri::HeapPriorityQueue::E> newQueue = core::List::•<pri::HeapPriorityQueue::E>(newCapacity);
      newQueue.{core::List::setRange}(0, this.{pri::HeapPriorityQueue::_length}, this.{pri::HeapPriorityQueue::_queue});
      this.{pri::HeapPriorityQueue::_queue} = newQueue;
    }
  }
}
library from "package:collection/src/queue_list.dart" as que {
  import "dart:collection";
  abstract class _QueueList&Object&ListMixin<E extends core::Object = dynamic> = core::Object with col::ListMixin<que::_QueueList&Object&ListMixin::E> {
  }
  class QueueList<E extends core::Object = dynamic> extends que::_QueueList&Object&ListMixin<que::QueueList::E> implements col::Queue<que::QueueList::E> {
    static const field core::int _INITIAL_CAPACITY = 8;
    generic-covariant-impl field core::List<que::QueueList::E> _table = null;
    field core::int _head;
    field core::int _tail;
    constructor •([core::int initialCapacity = null]) → void
      : que::QueueList::_head = 0, que::QueueList::_tail = 0, super core::Object::•() {
      if(initialCapacity.{core::num::==}(null) || initialCapacity.{core::num::<}(que::QueueList::_INITIAL_CAPACITY)) {
        initialCapacity = que::QueueList::_INITIAL_CAPACITY;
      }
      else
        if(!que::QueueList::_isPowerOf2(initialCapacity)) {
          initialCapacity = que::QueueList::_nextPowerOf2(initialCapacity);
        }
      assert(que::QueueList::_isPowerOf2(initialCapacity));
      this.{que::QueueList::_table} = core::List::•<que::QueueList::E>(initialCapacity);
    }
    constructor _() → void
      : que::QueueList::_tail = null, que::QueueList::_head = null, super core::Object::•()
      ;
    static method _castFrom<S extends core::Object = dynamic, T extends core::Object = dynamic>(que::QueueList<que::QueueList::_castFrom::S> source) → que::QueueList<que::QueueList::_castFrom::T> {
      return new que::_CastQueueList::•<que::QueueList::_castFrom::S, que::QueueList::_castFrom::T>(source);
    }
    static factory from<E extends core::Object = dynamic>(core::Iterable<que::QueueList::from::E> source) → que::QueueList<que::QueueList::from::E> {
      if(source is core::List<dynamic>) {
        core::int length = source.{core::Iterable::length};
        que::QueueList<que::QueueList::from::E> queue = new que::QueueList::•<que::QueueList::from::E>(length.{core::num::+}(1));
        assert(queue.{que::QueueList::_table}.{core::List::length}.{core::num::>}(length));
        core::Iterable<que::QueueList::from::E> sourceList = source;
        queue.{que::QueueList::_table}.{core::List::setRange}(0, length, sourceList, 0);
        queue.{que::QueueList::_tail} = length;
        return queue;
      }
      else {
        return let final que::QueueList<que::QueueList::from::E> #t659 = new que::QueueList::•<que::QueueList::from::E>() in let final dynamic #t660 = #t659.{que::QueueList::addAll}(source) in #t659;
      }
    }
    method add(generic-covariant-impl que::QueueList::E element) → void {
      this.{que::QueueList::_add}(element);
    }
    method addAll(generic-covariant-impl core::Iterable<que::QueueList::E> iterable) → void {
      if(iterable is core::List<dynamic>) {
        core::Iterable<que::QueueList::E> list = iterable;
        core::int addCount = list.{core::Iterable::length};
        core::int length = this.{que::QueueList::length};
        if(length.{core::num::+}(addCount).{core::num::>=}(this.{que::QueueList::_table}.{core::List::length})) {
          this.{que::QueueList::_preGrow}(length.{core::num::+}(addCount));
          this.{que::QueueList::_table}.{core::List::setRange}(length, length.{core::num::+}(addCount), list, 0);
          this.{que::QueueList::_tail} = this.{que::QueueList::_tail}.{core::num::+}(addCount);
        }
        else {
          core::int endSpace = this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(this.{que::QueueList::_tail});
          if(addCount.{core::num::<}(endSpace)) {
            this.{que::QueueList::_table}.{core::List::setRange}(this.{que::QueueList::_tail}, this.{que::QueueList::_tail}.{core::num::+}(addCount), list, 0);
            this.{que::QueueList::_tail} = this.{que::QueueList::_tail}.{core::num::+}(addCount);
          }
          else {
            core::int preSpace = addCount.{core::num::-}(endSpace);
            this.{que::QueueList::_table}.{core::List::setRange}(this.{que::QueueList::_tail}, this.{que::QueueList::_tail}.{core::num::+}(endSpace), list, 0);
            this.{que::QueueList::_table}.{core::List::setRange}(0, preSpace, list, endSpace);
            this.{que::QueueList::_tail} = preSpace;
          }
        }
      }
      else {
        for (que::QueueList::E element in iterable)
          this.{que::QueueList::_add}(element);
      }
    }
    method cast<T extends core::Object = dynamic>() → que::QueueList<que::QueueList::cast::T>
      return que::QueueList::_castFrom<que::QueueList::E, que::QueueList::cast::T>(this);
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → que::QueueList<que::QueueList::retype::T>
      return this.{que::QueueList::cast}<que::QueueList::retype::T>();
    method toString() → core::String
      return col::IterableBase::iterableToFullString(this, "{", "}");
    method addLast(generic-covariant-impl que::QueueList::E element) → void {
      this.{que::QueueList::_add}(element);
    }
    method addFirst(generic-covariant-impl que::QueueList::E element) → void {
      this.{que::QueueList::_head} = this.{que::QueueList::_head}.{core::num::-}(1).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1));
      this.{que::QueueList::_table}.{core::List::[]=}(this.{que::QueueList::_head}, element);
      if(this.{que::QueueList::_head}.{core::num::==}(this.{que::QueueList::_tail}))
        this.{que::QueueList::_grow}();
    }
    method removeFirst() → que::QueueList::E {
      if(this.{que::QueueList::_head}.{core::num::==}(this.{que::QueueList::_tail}))
        throw new core::StateError::•("No element");
      que::QueueList::E result = this.{que::QueueList::_table}.{core::List::[]}(this.{que::QueueList::_head});
      this.{que::QueueList::_table}.{core::List::[]=}(this.{que::QueueList::_head}, null);
      this.{que::QueueList::_head} = this.{que::QueueList::_head}.{core::num::+}(1).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1));
      return result;
    }
    method removeLast() → que::QueueList::E {
      if(this.{que::QueueList::_head}.{core::num::==}(this.{que::QueueList::_tail}))
        throw new core::StateError::•("No element");
      this.{que::QueueList::_tail} = this.{que::QueueList::_tail}.{core::num::-}(1).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1));
      que::QueueList::E result = this.{que::QueueList::_table}.{core::List::[]}(this.{que::QueueList::_tail});
      this.{que::QueueList::_table}.{core::List::[]=}(this.{que::QueueList::_tail}, null);
      return result;
    }
    get length() → core::int
      return this.{que::QueueList::_tail}.{core::num::-}(this.{que::QueueList::_head}).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1));
    set length(core::int value) → void {
      if(value.{core::num::<}(0))
        throw new core::RangeError::•("Length ${value} may not be negative.");
      core::int delta = value.{core::num::-}(this.{que::QueueList::length});
      if(delta.{core::num::>=}(0)) {
        if(this.{que::QueueList::_table}.{core::List::length}.{core::num::<=}(value)) {
          this.{que::QueueList::_preGrow}(value);
        }
        this.{que::QueueList::_tail} = this.{que::QueueList::_tail}.{core::num::+}(delta).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1));
        return;
      }
      core::int newTail = this.{que::QueueList::_tail}.{core::num::+}(delta);
      if(newTail.{core::num::>=}(0)) {
        this.{que::QueueList::_table}.{core::List::fillRange}(newTail, this.{que::QueueList::_tail}, null);
      }
      else {
        newTail = newTail.{core::num::+}(this.{que::QueueList::_table}.{core::List::length});
        this.{que::QueueList::_table}.{core::List::fillRange}(0, this.{que::QueueList::_tail}, null);
        this.{que::QueueList::_table}.{core::List::fillRange}(newTail, this.{que::QueueList::_table}.{core::List::length}, null);
      }
      this.{que::QueueList::_tail} = newTail;
    }
    operator [](core::int index) → que::QueueList::E {
      if(index.{core::num::<}(0) || index.{core::num::>=}(this.{que::QueueList::length})) {
        throw new core::RangeError::•("Index ${index} must be in the range [0..${this.{que::QueueList::length}}).");
      }
      return this.{que::QueueList::_table}.{core::List::[]}(this.{que::QueueList::_head}.{core::num::+}(index).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1)));
    }
    operator []=(core::int index, generic-covariant-impl que::QueueList::E value) → void {
      if(index.{core::num::<}(0) || index.{core::num::>=}(this.{que::QueueList::length})) {
        throw new core::RangeError::•("Index ${index} must be in the range [0..${this.{que::QueueList::length}}).");
      }
      this.{que::QueueList::_table}.{core::List::[]=}(this.{que::QueueList::_head}.{core::num::+}(index).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1)), value);
    }
    static method _isPowerOf2(core::int number) → core::bool
      return number.{core::int::&}(number.{core::num::-}(1)).{core::num::==}(0);
    static method _nextPowerOf2(core::int number) → core::int {
      assert(number.{core::num::>}(0));
      number = number.{core::int::<<}(1).{core::num::-}(1);
      for (; ; ) {
        core::int nextNumber = number.{core::int::&}(number.{core::num::-}(1));
        if(nextNumber.{core::num::==}(0))
          return number;
        number = nextNumber;
      }
    }
    method _add(generic-covariant-impl que::QueueList::E element) → void {
      this.{que::QueueList::_table}.{core::List::[]=}(this.{que::QueueList::_tail}, element);
      this.{que::QueueList::_tail} = this.{que::QueueList::_tail}.{core::num::+}(1).{core::int::&}(this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(1));
      if(this.{que::QueueList::_head}.{core::num::==}(this.{que::QueueList::_tail}))
        this.{que::QueueList::_grow}();
    }
    method _grow() → void {
      core::List<que::QueueList::E> newTable = core::List::•<que::QueueList::E>(this.{que::QueueList::_table}.{core::List::length}.{core::num::*}(2));
      core::int split = this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(this.{que::QueueList::_head});
      newTable.{core::List::setRange}(0, split, this.{que::QueueList::_table}, this.{que::QueueList::_head});
      newTable.{core::List::setRange}(split, split.{core::num::+}(this.{que::QueueList::_head}), this.{que::QueueList::_table}, 0);
      this.{que::QueueList::_head} = 0;
      this.{que::QueueList::_tail} = this.{que::QueueList::_table}.{core::List::length};
      this.{que::QueueList::_table} = newTable;
    }
    method _writeToList(generic-covariant-impl core::List<que::QueueList::E> target) → core::int {
      assert(target.{core::List::length}.{core::num::>=}(this.{que::QueueList::length}));
      if(this.{que::QueueList::_head}.{core::num::<=}(this.{que::QueueList::_tail})) {
        core::int length = this.{que::QueueList::_tail}.{core::num::-}(this.{que::QueueList::_head});
        target.{core::List::setRange}(0, length, this.{que::QueueList::_table}, this.{que::QueueList::_head});
        return length;
      }
      else {
        core::int firstPartSize = this.{que::QueueList::_table}.{core::List::length}.{core::num::-}(this.{que::QueueList::_head});
        target.{core::List::setRange}(0, firstPartSize, this.{que::QueueList::_table}, this.{que::QueueList::_head});
        target.{core::List::setRange}(firstPartSize, firstPartSize.{core::num::+}(this.{que::QueueList::_tail}), this.{que::QueueList::_table}, 0);
        return this.{que::QueueList::_tail}.{core::num::+}(firstPartSize);
      }
    }
    method _preGrow(core::int newElementCount) → void {
      assert(newElementCount.{core::num::>=}(this.{que::QueueList::length}));
      newElementCount = newElementCount.{core::num::+}(newElementCount.{core::int::>>}(1));
      core::int newCapacity = que::QueueList::_nextPowerOf2(newElementCount);
      core::List<que::QueueList::E> newTable = core::List::•<que::QueueList::E>(newCapacity);
      this.{que::QueueList::_tail} = this.{que::QueueList::_writeToList}(newTable);
      this.{que::QueueList::_table} = newTable;
      this.{que::QueueList::_head} = 0;
    }
  }
  class _CastQueueList<S extends core::Object = dynamic, T extends core::Object = dynamic> extends que::QueueList<que::_CastQueueList::T> {
    final field que::QueueList<que::_CastQueueList::S> _delegate;
    constructor •(que::QueueList<que::_CastQueueList::S> _delegate) → void
      : que::_CastQueueList::_delegate = _delegate, super que::QueueList::_() {
      this.{que::QueueList::_table} = this.{que::_CastQueueList::_delegate}.{que::QueueList::_table}.{core::List::cast}<que::_CastQueueList::T>();
    }
    get _head() → core::int
      return this.{que::_CastQueueList::_delegate}.{que::QueueList::_head};
    set _head(core::int value) → void
      return this.{que::_CastQueueList::_delegate}.{que::QueueList::_head} = value;
    get _tail() → core::int
      return this.{que::_CastQueueList::_delegate}.{que::QueueList::_tail};
    set _tail(core::int value) → void
      return this.{que::_CastQueueList::_delegate}.{que::QueueList::_tail} = value;
  }
}
library from "package:collection/src/union_set.dart" as uni {
  import "dart:collection";
  import "package:collection/src/unmodifiable_wrappers.dart";
  abstract class _UnionSet&SetBase&UnmodifiableSetMixin<E extends core::Object = dynamic> = col::SetBase<uni::_UnionSet&SetBase&UnmodifiableSetMixin::E> with unm::UnmodifiableSetMixin<uni::_UnionSet&SetBase&UnmodifiableSetMixin::E> {
  }
  class UnionSet<E extends core::Object = dynamic> extends uni::_UnionSet&SetBase&UnmodifiableSetMixin<uni::UnionSet::E> {
    final field core::Set<core::Set<uni::UnionSet::E>> _sets;
    final field core::bool _disjoint;
    constructor •(core::Set<core::Set<uni::UnionSet::E>> _sets, {core::bool disjoint = false}) → void
      : uni::UnionSet::_sets = _sets, uni::UnionSet::_disjoint = disjoint, super col::SetBase::•()
      ;
    constructor from(core::Iterable<core::Set<uni::UnionSet::E>> sets, {core::bool disjoint = false}) → void
      : this uni::UnionSet::•(sets.{core::Iterable::toSet}(), disjoint: disjoint)
      ;
    get length() → core::int
      return this.{uni::UnionSet::_disjoint} ?{core::int} this.{uni::UnionSet::_sets}.{core::Iterable::fold}<core::int>(0, (core::int length, core::Set<uni::UnionSet::E> set) → core::int => length.{core::num::+}(set.{_in::EfficientLengthIterable::length})) : this.{uni::UnionSet::_iterable}.{core::Iterable::length};
    get iterator() → core::Iterator<uni::UnionSet::E>
      return this.{uni::UnionSet::_iterable}.{core::Iterable::iterator};
    get _iterable() → core::Iterable<uni::UnionSet::E>
      return this.{uni::UnionSet::_disjoint} ?{core::Iterable<uni::UnionSet::E>} this.{uni::UnionSet::_sets}.{core::Iterable::expand}<uni::UnionSet::E>((core::Set<uni::UnionSet::E> set) → core::Set<uni::UnionSet::E> => set) : this.{uni::UnionSet::_dedupIterable};
    get _dedupIterable() → core::Iterable<uni::UnionSet::E> {
      core::Set<uni::UnionSet::E> seen = col::LinkedHashSet::•<uni::UnionSet::E>();
      return this.{uni::UnionSet::_sets}.{core::Iterable::expand}<uni::UnionSet::E>((core::Set<uni::UnionSet::E> set) → core::Set<uni::UnionSet::E> => set).{core::Iterable::where}((uni::UnionSet::E element) → core::bool {
        if(seen.{core::Set::contains}(element))
          return false;
        seen.{core::Set::add}(element);
        return true;
      });
    }
    method contains(core::Object element) → core::bool
      return this.{uni::UnionSet::_sets}.{core::Iterable::any}((core::Set<uni::UnionSet::E> set) → core::bool => set.{core::Set::contains}(element));
    method lookup(core::Object element) → uni::UnionSet::E {
      if(element.{core::Object::==}(null))
        return null;
      return this.{uni::UnionSet::_sets}.{core::Iterable::map}<uni::UnionSet::E>((core::Set<uni::UnionSet::E> set) → uni::UnionSet::E => set.{core::Set::lookup}(element)).{core::Iterable::firstWhere}((uni::UnionSet::E result) → core::bool => !result.{core::Object::==}(null), orElse: () → core::Null => null);
    }
    method toSet() → core::Set<uni::UnionSet::E> {
      core::Set<uni::UnionSet::E> result = col::LinkedHashSet::•<uni::UnionSet::E>();
      for (core::Set<uni::UnionSet::E> set in this.{uni::UnionSet::_sets}) {
        result.{core::Set::addAll}(set);
      }
      return result;
    }
  }
}
library from "package:collection/src/union_set_controller.dart" as uni2 {
  import "package:collection/src/union_set.dart";
  class UnionSetController<E extends core::Object = dynamic> extends core::Object {
    generic-covariant-impl field uni::UnionSet<uni2::UnionSetController::E> _set = null;
    final field core::Set<core::Set<uni2::UnionSetController::E>> _sets = col::LinkedHashSet::•<core::Set<uni2::UnionSetController::E>>();
    constructor •({core::bool disjoint = false}) → void
      : super core::Object::•() {
      this.{uni2::UnionSetController::_set} = new uni::UnionSet::•<uni2::UnionSetController::E>(this.{uni2::UnionSetController::_sets}, disjoint: disjoint);
    }
    get set() → uni::UnionSet<uni2::UnionSetController::E>
      return this.{uni2::UnionSetController::_set};
    method add(generic-covariant-impl core::Set<uni2::UnionSetController::E> component) → void {
      this.{uni2::UnionSetController::_sets}.{core::Set::add}(component);
    }
    method remove(generic-covariant-impl core::Set<uni2::UnionSetController::E> component) → core::bool
      return this.{uni2::UnionSetController::_sets}.{core::Set::remove}(component);
  }
}
library from "package:collection/src/unmodifiable_wrappers.dart" as unm {
  import "package:collection/src/empty_unmodifiable_set.dart";
  import "package:collection/src/wrappers.dart";
  export "dart:collection";
  abstract class _NonGrowableListView&DelegatingList&NonGrowableListMixin<E extends core::Object = dynamic> = wra::DelegatingList<unm::_NonGrowableListView&DelegatingList&NonGrowableListMixin::E> with unm::NonGrowableListMixin<unm::_NonGrowableListView&DelegatingList&NonGrowableListMixin::E> {
  }
  class NonGrowableListView<E extends core::Object = dynamic> extends unm::_NonGrowableListView&DelegatingList&NonGrowableListMixin<unm::NonGrowableListView::E> {
    constructor •(core::List<unm::NonGrowableListView::E> listBase) → void
      : super wra::DelegatingList::•(listBase)
      ;
  }
  abstract class NonGrowableListMixin<E extends core::Object = dynamic> extends core::Object implements core::List<unm::NonGrowableListMixin::E> {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    static method _throw<T extends core::Object = dynamic>() → unm::NonGrowableListMixin::_throw::T {
      throw new core::UnsupportedError::•("Cannot change the length of a fixed-length list");
    }
    set length(core::int newLength) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method add(generic-covariant-impl unm::NonGrowableListMixin::E value) → core::bool
      return unm::NonGrowableListMixin::_throw<core::bool>();
    method addAll(generic-covariant-impl core::Iterable<unm::NonGrowableListMixin::E> iterable) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method insert(core::int index, generic-covariant-impl unm::NonGrowableListMixin::E element) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method insertAll(core::int index, generic-covariant-impl core::Iterable<unm::NonGrowableListMixin::E> iterable) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method remove(core::Object value) → core::bool
      return unm::NonGrowableListMixin::_throw<core::bool>();
    method removeAt(core::int index) → unm::NonGrowableListMixin::E
      return unm::NonGrowableListMixin::_throw<unm::NonGrowableListMixin::E>();
    method removeLast() → unm::NonGrowableListMixin::E
      return unm::NonGrowableListMixin::_throw<unm::NonGrowableListMixin::E>();
    method removeWhere((unm::NonGrowableListMixin::E) → core::bool test) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method retainWhere((unm::NonGrowableListMixin::E) → core::bool test) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method removeRange(core::int start, core::int end) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method replaceRange(core::int start, core::int end, generic-covariant-impl core::Iterable<unm::NonGrowableListMixin::E> iterable) → void
      return unm::NonGrowableListMixin::_throw<void>();
    method clear() → void
      return unm::NonGrowableListMixin::_throw<void>();
  }
  abstract class _UnmodifiableSetView&DelegatingSet&UnmodifiableSetMixin<E extends core::Object = dynamic> = wra::DelegatingSet<unm::_UnmodifiableSetView&DelegatingSet&UnmodifiableSetMixin::E> with unm::UnmodifiableSetMixin<unm::_UnmodifiableSetView&DelegatingSet&UnmodifiableSetMixin::E> {
  }
  class UnmodifiableSetView<E extends core::Object = dynamic> extends unm::_UnmodifiableSetView&DelegatingSet&UnmodifiableSetMixin<unm::UnmodifiableSetView::E> {
    static field dynamic _redirecting# = <dynamic>[unm::UnmodifiableSetView::empty];
    constructor •(core::Set<unm::UnmodifiableSetView::E> setBase) → void
      : super wra::DelegatingSet::•(setBase)
      ;
    static factory empty<E extends core::Object = dynamic>() → unm::UnmodifiableSetView<unm::UnmodifiableSetView::empty::E>
      let dynamic #redirecting_factory = emp2::EmptyUnmodifiableSet::• in let unm::UnmodifiableSetView::empty::E #typeArg0 = null in invalid-expression;
  }
  abstract class UnmodifiableSetMixin<E extends core::Object = dynamic> extends core::Object implements core::Set<unm::UnmodifiableSetMixin::E> {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    static method _throw<T extends core::Object = dynamic>() → unm::UnmodifiableSetMixin::_throw::T {
      throw new core::UnsupportedError::•("Cannot modify an unmodifiable Set");
    }
    method add(generic-covariant-impl unm::UnmodifiableSetMixin::E value) → core::bool
      return unm::UnmodifiableSetMixin::_throw<core::bool>();
    method addAll(generic-covariant-impl core::Iterable<unm::UnmodifiableSetMixin::E> elements) → void
      return unm::UnmodifiableSetMixin::_throw<void>();
    method remove(core::Object value) → core::bool
      return unm::UnmodifiableSetMixin::_throw<core::bool>();
    method removeAll(core::Iterable<dynamic> elements) → void
      return unm::UnmodifiableSetMixin::_throw<void>();
    method retainAll(core::Iterable<dynamic> elements) → void
      return unm::UnmodifiableSetMixin::_throw<void>();
    method removeWhere((unm::UnmodifiableSetMixin::E) → core::bool test) → void
      return unm::UnmodifiableSetMixin::_throw<void>();
    method retainWhere((unm::UnmodifiableSetMixin::E) → core::bool test) → void
      return unm::UnmodifiableSetMixin::_throw<void>();
    method clear() → void
      return unm::UnmodifiableSetMixin::_throw<void>();
  }
  abstract class UnmodifiableMapMixin<K extends core::Object = dynamic, V extends core::Object = dynamic> extends core::Object implements core::Map<unm::UnmodifiableMapMixin::K, unm::UnmodifiableMapMixin::V> {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    static method _throw<T extends core::Object = dynamic>() → unm::UnmodifiableMapMixin::_throw::T {
      throw new core::UnsupportedError::•("Cannot modify an unmodifiable Map");
    }
    operator []=(generic-covariant-impl unm::UnmodifiableMapMixin::K key, generic-covariant-impl unm::UnmodifiableMapMixin::V value) → void
      return unm::UnmodifiableMapMixin::_throw<void>();
    method putIfAbsent(generic-covariant-impl unm::UnmodifiableMapMixin::K key, generic-covariant-impl () → unm::UnmodifiableMapMixin::V ifAbsent) → unm::UnmodifiableMapMixin::V
      return unm::UnmodifiableMapMixin::_throw<unm::UnmodifiableMapMixin::V>();
    method addAll(generic-covariant-impl core::Map<unm::UnmodifiableMapMixin::K, unm::UnmodifiableMapMixin::V> other) → void
      return unm::UnmodifiableMapMixin::_throw<void>();
    method remove(core::Object key) → unm::UnmodifiableMapMixin::V
      return unm::UnmodifiableMapMixin::_throw<unm::UnmodifiableMapMixin::V>();
    method clear() → void
      return unm::UnmodifiableMapMixin::_throw<void>();
    set first(dynamic _) → void
      return unm::UnmodifiableMapMixin::_throw<void>();
    set last(dynamic _) → void
      return unm::UnmodifiableMapMixin::_throw<void>();
  }
}
library from "package:collection/src/wrappers.dart" as wra {
  import "dart:collection";
  import "dart:math" as math;
  import "package:collection/src/unmodifiable_wrappers.dart";
  typedef _KeyForValue<K extends core::Object = dynamic, V extends core::Object = dynamic> = (V) → K;
  abstract class _DelegatingIterableBase<E extends core::Object = dynamic> extends core::Object implements core::Iterable<wra::_DelegatingIterableBase::E> {
    const constructor •() → void
      : super core::Object::•()
      ;
    abstract get _base() → core::Iterable<wra::_DelegatingIterableBase::E>;
    method any((wra::_DelegatingIterableBase::E) → core::bool test) → core::bool
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::any}(test);
    method cast<T extends core::Object = dynamic>() → core::Iterable<wra::_DelegatingIterableBase::cast::T>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::cast}<wra::_DelegatingIterableBase::cast::T>();
    method contains(core::Object element) → core::bool
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::contains}(element);
    method elementAt(core::int index) → wra::_DelegatingIterableBase::E
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::elementAt}(index);
    method every((wra::_DelegatingIterableBase::E) → core::bool test) → core::bool
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::every}(test);
    method expand<T extends core::Object = dynamic>((wra::_DelegatingIterableBase::E) → core::Iterable<wra::_DelegatingIterableBase::expand::T> f) → core::Iterable<wra::_DelegatingIterableBase::expand::T>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::expand}<wra::_DelegatingIterableBase::expand::T>(f);
    get first() → wra::_DelegatingIterableBase::E
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::first};
    method firstWhere((wra::_DelegatingIterableBase::E) → core::bool test, {generic-covariant-impl () → wra::_DelegatingIterableBase::E orElse = null}) → wra::_DelegatingIterableBase::E
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::firstWhere}(test, orElse: orElse);
    method fold<T extends core::Object = dynamic>(wra::_DelegatingIterableBase::fold::T initialValue, (wra::_DelegatingIterableBase::fold::T, wra::_DelegatingIterableBase::E) → wra::_DelegatingIterableBase::fold::T combine) → wra::_DelegatingIterableBase::fold::T
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::fold}<wra::_DelegatingIterableBase::fold::T>(initialValue, combine);
    method followedBy(generic-covariant-impl core::Iterable<wra::_DelegatingIterableBase::E> other) → core::Iterable<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::followedBy}(other);
    method forEach((wra::_DelegatingIterableBase::E) → void f) → void
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::forEach}(f);
    get isEmpty() → core::bool
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::isEmpty};
    get isNotEmpty() → core::bool
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::isNotEmpty};
    get iterator() → core::Iterator<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::iterator};
    method join([core::String separator = ""]) → core::String
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::join}(separator);
    get last() → wra::_DelegatingIterableBase::E
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::last};
    method lastWhere((wra::_DelegatingIterableBase::E) → core::bool test, {generic-covariant-impl () → wra::_DelegatingIterableBase::E orElse = null}) → wra::_DelegatingIterableBase::E
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::lastWhere}(test, orElse: orElse);
    get length() → core::int
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::length};
    method map<T extends core::Object = dynamic>((wra::_DelegatingIterableBase::E) → wra::_DelegatingIterableBase::map::T f) → core::Iterable<wra::_DelegatingIterableBase::map::T>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::map}<wra::_DelegatingIterableBase::map::T>(f);
    method reduce(generic-covariant-impl (wra::_DelegatingIterableBase::E, wra::_DelegatingIterableBase::E) → wra::_DelegatingIterableBase::E combine) → wra::_DelegatingIterableBase::E
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::reduce}(combine);
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → core::Iterable<wra::_DelegatingIterableBase::retype::T>
      return this.{wra::_DelegatingIterableBase::cast}<wra::_DelegatingIterableBase::retype::T>();
    get single() → wra::_DelegatingIterableBase::E
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::single};
    method singleWhere((wra::_DelegatingIterableBase::E) → core::bool test, {generic-covariant-impl () → wra::_DelegatingIterableBase::E orElse = null}) → wra::_DelegatingIterableBase::E {
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::singleWhere}(test, orElse: orElse);
    }
    method skip(core::int n) → core::Iterable<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::skip}(n);
    method skipWhile((wra::_DelegatingIterableBase::E) → core::bool test) → core::Iterable<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::skipWhile}(test);
    method take(core::int n) → core::Iterable<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::take}(n);
    method takeWhile((wra::_DelegatingIterableBase::E) → core::bool test) → core::Iterable<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::takeWhile}(test);
    method toList({core::bool growable = true}) → core::List<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::toList}(growable: growable);
    method toSet() → core::Set<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::toSet}();
    method where((wra::_DelegatingIterableBase::E) → core::bool test) → core::Iterable<wra::_DelegatingIterableBase::E>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::where}(test);
    method whereType<T extends core::Object = dynamic>() → core::Iterable<wra::_DelegatingIterableBase::whereType::T>
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::whereType}<wra::_DelegatingIterableBase::whereType::T>();
    method toString() → core::String
      return this.{wra::_DelegatingIterableBase::_base}.{core::Iterable::toString}();
  }
  class DelegatingIterable<E extends core::Object = dynamic> extends wra::_DelegatingIterableBase<wra::DelegatingIterable::E> {
    final field core::Iterable<wra::DelegatingIterable::E> _base;
    const constructor •(core::Iterable<wra::DelegatingIterable::E> base) → void
      : wra::DelegatingIterable::_base = base, super wra::_DelegatingIterableBase::•()
      ;
    @core::Deprecated::•("Use iterable.cast<E> instead.")
    static method typed<E extends core::Object = dynamic>(core::Iterable<dynamic> base) → core::Iterable<wra::DelegatingIterable::typed::E>
      return base.{core::Iterable::cast}<wra::DelegatingIterable::typed::E>();
  }
  class DelegatingList<E extends core::Object = dynamic> extends wra::DelegatingIterable<wra::DelegatingList::E> implements core::List<wra::DelegatingList::E> {
    const constructor •(core::List<wra::DelegatingList::E> base) → void
      : super wra::DelegatingIterable::•(base)
      ;
    @core::Deprecated::•("Use list.cast<E> instead.")
    static method typed<E extends core::Object = dynamic>(core::List<dynamic> base) → core::List<wra::DelegatingList::typed::E>
      return base.{core::List::cast}<wra::DelegatingList::typed::E>();
    get _listBase() → core::List<wra::DelegatingList::E>
      return this.{wra::DelegatingIterable::_base} as{TypeError} core::List<wra::DelegatingList::E>;
    operator [](core::int index) → wra::DelegatingList::E
      return this.{wra::DelegatingList::_listBase}.{core::List::[]}(index);
    operator []=(core::int index, generic-covariant-impl wra::DelegatingList::E value) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::[]=}(index, value);
    }
    operator +(generic-covariant-impl core::List<wra::DelegatingList::E> other) → core::List<wra::DelegatingList::E>
      return this.{wra::DelegatingList::_listBase}.{core::List::+}(other);
    method add(generic-covariant-impl wra::DelegatingList::E value) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::add}(value);
    }
    method addAll(generic-covariant-impl core::Iterable<wra::DelegatingList::E> iterable) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::addAll}(iterable);
    }
    method asMap() → core::Map<core::int, wra::DelegatingList::E>
      return this.{wra::DelegatingList::_listBase}.{core::List::asMap}();
    method cast<T extends core::Object = dynamic>() → core::List<wra::DelegatingList::cast::T>
      return this.{wra::DelegatingList::_listBase}.{core::List::cast}<wra::DelegatingList::cast::T>();
    method clear() → void {
      this.{wra::DelegatingList::_listBase}.{core::List::clear}();
    }
    method fillRange(core::int start, core::int end, [generic-covariant-impl wra::DelegatingList::E fillValue = null]) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::fillRange}(start, end, fillValue);
    }
    set first(generic-covariant-impl wra::DelegatingList::E value) → void {
      if(this.{wra::_DelegatingIterableBase::isEmpty})
        throw new core::IndexError::•(0, this);
      this.{wra::DelegatingList::[]=}(0, value);
    }
    method getRange(core::int start, core::int end) → core::Iterable<wra::DelegatingList::E>
      return this.{wra::DelegatingList::_listBase}.{core::List::getRange}(start, end);
    method indexOf(generic-covariant-impl wra::DelegatingList::E element, [core::int start = 0]) → core::int
      return this.{wra::DelegatingList::_listBase}.{core::List::indexOf}(element, start);
    method indexWhere((wra::DelegatingList::E) → core::bool test, [core::int start = 0]) → core::int
      return this.{wra::DelegatingList::_listBase}.{core::List::indexWhere}(test, start);
    method insert(core::int index, generic-covariant-impl wra::DelegatingList::E element) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::insert}(index, element);
    }
    method insertAll(core::int index, generic-covariant-impl core::Iterable<wra::DelegatingList::E> iterable) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::insertAll}(index, iterable);
    }
    set last(generic-covariant-impl wra::DelegatingList::E value) → void {
      if(this.{wra::_DelegatingIterableBase::isEmpty})
        throw new core::IndexError::•(0, this);
      this.{wra::DelegatingList::[]=}(this.{wra::_DelegatingIterableBase::length}.{core::num::-}(1), value);
    }
    method lastIndexOf(generic-covariant-impl wra::DelegatingList::E element, [core::int start = null]) → core::int
      return this.{wra::DelegatingList::_listBase}.{core::List::lastIndexOf}(element, start);
    method lastIndexWhere((wra::DelegatingList::E) → core::bool test, [core::int start = null]) → core::int
      return this.{wra::DelegatingList::_listBase}.{core::List::lastIndexWhere}(test, start);
    set length(core::int newLength) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::length} = newLength;
    }
    method remove(core::Object value) → core::bool
      return this.{wra::DelegatingList::_listBase}.{core::List::remove}(value);
    method removeAt(core::int index) → wra::DelegatingList::E
      return this.{wra::DelegatingList::_listBase}.{core::List::removeAt}(index);
    method removeLast() → wra::DelegatingList::E
      return this.{wra::DelegatingList::_listBase}.{core::List::removeLast}();
    method removeRange(core::int start, core::int end) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::removeRange}(start, end);
    }
    method removeWhere((wra::DelegatingList::E) → core::bool test) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::removeWhere}(test);
    }
    method replaceRange(core::int start, core::int end, generic-covariant-impl core::Iterable<wra::DelegatingList::E> iterable) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::replaceRange}(start, end, iterable);
    }
    method retainWhere((wra::DelegatingList::E) → core::bool test) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::retainWhere}(test);
    }
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → core::List<wra::DelegatingList::retype::T>
      return this.{wra::DelegatingList::cast}<wra::DelegatingList::retype::T>();
    get reversed() → core::Iterable<wra::DelegatingList::E>
      return this.{wra::DelegatingList::_listBase}.{core::List::reversed};
    method setAll(core::int index, generic-covariant-impl core::Iterable<wra::DelegatingList::E> iterable) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::setAll}(index, iterable);
    }
    method setRange(core::int start, core::int end, generic-covariant-impl core::Iterable<wra::DelegatingList::E> iterable, [core::int skipCount = 0]) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::setRange}(start, end, iterable, skipCount);
    }
    method shuffle([math::Random random = null]) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::shuffle}(random);
    }
    method sort([(wra::DelegatingList::E, wra::DelegatingList::E) → core::int compare = null]) → void {
      this.{wra::DelegatingList::_listBase}.{core::List::sort}(compare);
    }
    method sublist(core::int start, [core::int end = null]) → core::List<wra::DelegatingList::E>
      return this.{wra::DelegatingList::_listBase}.{core::List::sublist}(start, end);
  }
  class DelegatingSet<E extends core::Object = dynamic> extends wra::DelegatingIterable<wra::DelegatingSet::E> implements core::Set<wra::DelegatingSet::E> {
    const constructor •(core::Set<wra::DelegatingSet::E> base) → void
      : super wra::DelegatingIterable::•(base)
      ;
    @core::Deprecated::•("Use set.cast<E> instead.")
    static method typed<E extends core::Object = dynamic>(core::Set<dynamic> base) → core::Set<wra::DelegatingSet::typed::E>
      return base.{core::Set::cast}<wra::DelegatingSet::typed::E>();
    get _setBase() → core::Set<wra::DelegatingSet::E>
      return this.{wra::DelegatingIterable::_base} as{TypeError} core::Set<wra::DelegatingSet::E>;
    method add(generic-covariant-impl wra::DelegatingSet::E value) → core::bool
      return this.{wra::DelegatingSet::_setBase}.{core::Set::add}(value);
    method addAll(generic-covariant-impl core::Iterable<wra::DelegatingSet::E> elements) → void {
      this.{wra::DelegatingSet::_setBase}.{core::Set::addAll}(elements);
    }
    method cast<T extends core::Object = dynamic>() → core::Set<wra::DelegatingSet::cast::T>
      return this.{wra::DelegatingSet::_setBase}.{core::Set::cast}<wra::DelegatingSet::cast::T>();
    method clear() → void {
      this.{wra::DelegatingSet::_setBase}.{core::Set::clear}();
    }
    method containsAll(core::Iterable<core::Object> other) → core::bool
      return this.{wra::DelegatingSet::_setBase}.{core::Set::containsAll}(other);
    method difference(core::Set<core::Object> other) → core::Set<wra::DelegatingSet::E>
      return this.{wra::DelegatingSet::_setBase}.{core::Set::difference}(other);
    method intersection(core::Set<core::Object> other) → core::Set<wra::DelegatingSet::E>
      return this.{wra::DelegatingSet::_setBase}.{core::Set::intersection}(other);
    method lookup(core::Object element) → wra::DelegatingSet::E
      return this.{wra::DelegatingSet::_setBase}.{core::Set::lookup}(element);
    method remove(core::Object value) → core::bool
      return this.{wra::DelegatingSet::_setBase}.{core::Set::remove}(value);
    method removeAll(core::Iterable<core::Object> elements) → void {
      this.{wra::DelegatingSet::_setBase}.{core::Set::removeAll}(elements);
    }
    method removeWhere((wra::DelegatingSet::E) → core::bool test) → void {
      this.{wra::DelegatingSet::_setBase}.{core::Set::removeWhere}(test);
    }
    method retainAll(core::Iterable<core::Object> elements) → void {
      this.{wra::DelegatingSet::_setBase}.{core::Set::retainAll}(elements);
    }
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → core::Set<wra::DelegatingSet::retype::T>
      return this.{wra::DelegatingSet::cast}<wra::DelegatingSet::retype::T>();
    method retainWhere((wra::DelegatingSet::E) → core::bool test) → void {
      this.{wra::DelegatingSet::_setBase}.{core::Set::retainWhere}(test);
    }
    method union(generic-covariant-impl core::Set<wra::DelegatingSet::E> other) → core::Set<wra::DelegatingSet::E>
      return this.{wra::DelegatingSet::_setBase}.{core::Set::union}(other);
    method toSet() → core::Set<wra::DelegatingSet::E>
      return new wra::DelegatingSet::•<wra::DelegatingSet::E>(this.{wra::DelegatingSet::_setBase}.{core::Set::toSet}());
  }
  class DelegatingQueue<E extends core::Object = dynamic> extends wra::DelegatingIterable<wra::DelegatingQueue::E> implements col::Queue<wra::DelegatingQueue::E> {
    const constructor •(col::Queue<wra::DelegatingQueue::E> queue) → void
      : super wra::DelegatingIterable::•(queue)
      ;
    @core::Deprecated::•("Use queue.cast<E> instead.")
    static method typed<E extends core::Object = dynamic>(col::Queue<dynamic> base) → col::Queue<wra::DelegatingQueue::typed::E>
      return base.{col::Queue::cast}<wra::DelegatingQueue::typed::E>();
    get _baseQueue() → col::Queue<wra::DelegatingQueue::E>
      return this.{wra::DelegatingIterable::_base} as{TypeError} col::Queue<wra::DelegatingQueue::E>;
    method add(generic-covariant-impl wra::DelegatingQueue::E value) → void {
      this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::add}(value);
    }
    method addAll(generic-covariant-impl core::Iterable<wra::DelegatingQueue::E> iterable) → void {
      this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::addAll}(iterable);
    }
    method addFirst(generic-covariant-impl wra::DelegatingQueue::E value) → void {
      this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::addFirst}(value);
    }
    method addLast(generic-covariant-impl wra::DelegatingQueue::E value) → void {
      this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::addLast}(value);
    }
    method cast<T extends core::Object = dynamic>() → col::Queue<wra::DelegatingQueue::cast::T>
      return this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::cast}<wra::DelegatingQueue::cast::T>();
    method clear() → void {
      this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::clear}();
    }
    method remove(core::Object object) → core::bool
      return this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::remove}(object);
    method removeWhere((wra::DelegatingQueue::E) → core::bool test) → void {
      this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::removeWhere}(test);
    }
    method retainWhere((wra::DelegatingQueue::E) → core::bool test) → void {
      this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::retainWhere}(test);
    }
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → col::Queue<wra::DelegatingQueue::retype::T>
      return this.{wra::DelegatingQueue::cast}<wra::DelegatingQueue::retype::T>();
    method removeFirst() → wra::DelegatingQueue::E
      return this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::removeFirst}();
    method removeLast() → wra::DelegatingQueue::E
      return this.{wra::DelegatingQueue::_baseQueue}.{col::Queue::removeLast}();
  }
  class DelegatingMap<K extends core::Object = dynamic, V extends core::Object = dynamic> extends core::Object implements core::Map<wra::DelegatingMap::K, wra::DelegatingMap::V> {
    final field core::Map<wra::DelegatingMap::K, wra::DelegatingMap::V> _base;
    const constructor •(core::Map<wra::DelegatingMap::K, wra::DelegatingMap::V> base) → void
      : wra::DelegatingMap::_base = base, super core::Object::•()
      ;
    @core::Deprecated::•("Use map.cast<K, V> instead.")
    static method typed<K extends core::Object = dynamic, V extends core::Object = dynamic>(core::Map<dynamic, dynamic> base) → core::Map<wra::DelegatingMap::typed::K, wra::DelegatingMap::typed::V>
      return base.{core::Map::cast}<wra::DelegatingMap::typed::K, wra::DelegatingMap::typed::V>();
    operator [](core::Object key) → wra::DelegatingMap::V
      return this.{wra::DelegatingMap::_base}.{core::Map::[]}(key);
    operator []=(generic-covariant-impl wra::DelegatingMap::K key, generic-covariant-impl wra::DelegatingMap::V value) → void {
      this.{wra::DelegatingMap::_base}.{core::Map::[]=}(key, value);
    }
    method addAll(generic-covariant-impl core::Map<wra::DelegatingMap::K, wra::DelegatingMap::V> other) → void {
      this.{wra::DelegatingMap::_base}.{core::Map::addAll}(other);
    }
    method addEntries(generic-covariant-impl core::Iterable<core::MapEntry<wra::DelegatingMap::K, wra::DelegatingMap::V>> entries) → void {
      this.{wra::DelegatingMap::_base}.{core::Map::addEntries}(entries);
    }
    method clear() → void {
      this.{wra::DelegatingMap::_base}.{core::Map::clear}();
    }
    method cast<K2 extends core::Object = dynamic, V2 extends core::Object = dynamic>() → core::Map<wra::DelegatingMap::cast::K2, wra::DelegatingMap::cast::V2>
      return this.{wra::DelegatingMap::_base}.{core::Map::cast}<wra::DelegatingMap::cast::K2, wra::DelegatingMap::cast::V2>();
    method containsKey(core::Object key) → core::bool
      return this.{wra::DelegatingMap::_base}.{core::Map::containsKey}(key);
    method containsValue(core::Object value) → core::bool
      return this.{wra::DelegatingMap::_base}.{core::Map::containsValue}(value);
    get entries() → core::Iterable<core::MapEntry<wra::DelegatingMap::K, wra::DelegatingMap::V>>
      return this.{wra::DelegatingMap::_base}.{core::Map::entries};
    method forEach((wra::DelegatingMap::K, wra::DelegatingMap::V) → void f) → void {
      this.{wra::DelegatingMap::_base}.{core::Map::forEach}(f);
    }
    get isEmpty() → core::bool
      return this.{wra::DelegatingMap::_base}.{core::Map::isEmpty};
    get isNotEmpty() → core::bool
      return this.{wra::DelegatingMap::_base}.{core::Map::isNotEmpty};
    get keys() → core::Iterable<wra::DelegatingMap::K>
      return this.{wra::DelegatingMap::_base}.{core::Map::keys};
    get length() → core::int
      return this.{wra::DelegatingMap::_base}.{core::Map::length};
    method map<K2 extends core::Object = dynamic, V2 extends core::Object = dynamic>((wra::DelegatingMap::K, wra::DelegatingMap::V) → core::MapEntry<wra::DelegatingMap::map::K2, wra::DelegatingMap::map::V2> transform) → core::Map<wra::DelegatingMap::map::K2, wra::DelegatingMap::map::V2>
      return this.{wra::DelegatingMap::_base}.{core::Map::map}<wra::DelegatingMap::map::K2, wra::DelegatingMap::map::V2>(transform);
    method putIfAbsent(generic-covariant-impl wra::DelegatingMap::K key, generic-covariant-impl () → wra::DelegatingMap::V ifAbsent) → wra::DelegatingMap::V
      return this.{wra::DelegatingMap::_base}.{core::Map::putIfAbsent}(key, ifAbsent);
    method remove(core::Object key) → wra::DelegatingMap::V
      return this.{wra::DelegatingMap::_base}.{core::Map::remove}(key);
    method removeWhere((wra::DelegatingMap::K, wra::DelegatingMap::V) → core::bool test) → void
      return this.{wra::DelegatingMap::_base}.{core::Map::removeWhere}(test);
    @core::deprecated
    method retype<K2 extends core::Object = dynamic, V2 extends core::Object = dynamic>() → core::Map<wra::DelegatingMap::retype::K2, wra::DelegatingMap::retype::V2>
      return this.{wra::DelegatingMap::cast}<wra::DelegatingMap::retype::K2, wra::DelegatingMap::retype::V2>();
    get values() → core::Iterable<wra::DelegatingMap::V>
      return this.{wra::DelegatingMap::_base}.{core::Map::values};
    method toString() → core::String
      return this.{wra::DelegatingMap::_base}.{core::Object::toString}();
    method update(generic-covariant-impl wra::DelegatingMap::K key, generic-covariant-impl (wra::DelegatingMap::V) → wra::DelegatingMap::V update, {generic-covariant-impl () → wra::DelegatingMap::V ifAbsent = null}) → wra::DelegatingMap::V
      return this.{wra::DelegatingMap::_base}.{core::Map::update}(key, update, ifAbsent: ifAbsent);
    method updateAll(generic-covariant-impl (wra::DelegatingMap::K, wra::DelegatingMap::V) → wra::DelegatingMap::V update) → void
      return this.{wra::DelegatingMap::_base}.{core::Map::updateAll}(update);
  }
  abstract class _MapKeySet&_DelegatingIterableBase&UnmodifiableSetMixin<E extends core::Object = dynamic> = wra::_DelegatingIterableBase<wra::_MapKeySet&_DelegatingIterableBase&UnmodifiableSetMixin::E> with unm::UnmodifiableSetMixin<wra::_MapKeySet&_DelegatingIterableBase&UnmodifiableSetMixin::E> {
  }
  class MapKeySet<E extends core::Object = dynamic> extends wra::_MapKeySet&_DelegatingIterableBase&UnmodifiableSetMixin<wra::MapKeySet::E> {
    final field core::Map<wra::MapKeySet::E, dynamic> _baseMap;
    constructor •(core::Map<wra::MapKeySet::E, dynamic> base) → void
      : wra::MapKeySet::_baseMap = base, super wra::_DelegatingIterableBase::•()
      ;
    get _base() → core::Iterable<wra::MapKeySet::E>
      return this.{wra::MapKeySet::_baseMap}.{core::Map::keys};
    method cast<T extends core::Object = dynamic>() → core::Set<wra::MapKeySet::cast::T> {
      if(this is wra::MapKeySet<wra::MapKeySet::cast::T>) {
        return this as wra::MapKeySet<wra::MapKeySet::cast::T>;
      }
      return core::Set::castFrom<wra::MapKeySet::E, wra::MapKeySet::cast::T>(this);
    }
    method contains(core::Object element) → core::bool
      return this.{wra::MapKeySet::_baseMap}.{core::Map::containsKey}(element);
    get isEmpty() → core::bool
      return this.{wra::MapKeySet::_baseMap}.{core::Map::isEmpty};
    get isNotEmpty() → core::bool
      return this.{wra::MapKeySet::_baseMap}.{core::Map::isNotEmpty};
    get length() → core::int
      return this.{wra::MapKeySet::_baseMap}.{core::Map::length};
    method toString() → core::String
      return "{${this.{wra::MapKeySet::_base}.{core::Iterable::join}(", ")}}";
    method containsAll(core::Iterable<core::Object> other) → core::bool
      return other.{core::Iterable::every}(this.{wra::MapKeySet::contains});
    method difference(core::Set<core::Object> other) → core::Set<wra::MapKeySet::E>
      return this.{wra::_DelegatingIterableBase::where}((wra::MapKeySet::E element) → core::bool => !other.{core::Set::contains}(element)).{core::Iterable::toSet}();
    method intersection(core::Set<core::Object> other) → core::Set<wra::MapKeySet::E>
      return this.{wra::_DelegatingIterableBase::where}(other.{core::Set::contains}).{core::Iterable::toSet}();
    method lookup(core::Object element) → wra::MapKeySet::E
      return throw new core::UnsupportedError::•("MapKeySet doesn't support lookup().");
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → core::Set<wra::MapKeySet::retype::T>
      return core::Set::castFrom<wra::MapKeySet::E, wra::MapKeySet::retype::T>(this);
    method union(generic-covariant-impl core::Set<wra::MapKeySet::E> other) → core::Set<wra::MapKeySet::E>
      return let final core::Set<wra::MapKeySet::E> #t661 = this.{wra::_DelegatingIterableBase::toSet}() in let final dynamic #t662 = #t661.{core::Set::addAll}(other) in #t661;
  }
  class MapValueSet<K extends core::Object = dynamic, V extends core::Object = dynamic> extends wra::_DelegatingIterableBase<wra::MapValueSet::V> implements core::Set<wra::MapValueSet::V> {
    final field core::Map<wra::MapValueSet::K, wra::MapValueSet::V> _baseMap;
    final field (wra::MapValueSet::V) → wra::MapValueSet::K _keyForValue;
    constructor •(core::Map<wra::MapValueSet::K, wra::MapValueSet::V> base, (wra::MapValueSet::V) → wra::MapValueSet::K keyForValue) → void
      : wra::MapValueSet::_baseMap = base, wra::MapValueSet::_keyForValue = keyForValue, super wra::_DelegatingIterableBase::•()
      ;
    get _base() → core::Iterable<wra::MapValueSet::V>
      return this.{wra::MapValueSet::_baseMap}.{core::Map::values};
    method cast<T extends core::Object = dynamic>() → core::Set<wra::MapValueSet::cast::T> {
      if(this is core::Set<wra::MapValueSet::cast::T>) {
        return this as core::Set<wra::MapValueSet::cast::T>;
      }
      return core::Set::castFrom<wra::MapValueSet::V, wra::MapValueSet::cast::T>(this);
    }
    method contains(core::Object element) → core::bool {
      if(!element.{core::Object::==}(null) && !(element is wra::MapValueSet::V))
        return false;
      wra::MapValueSet::K key = this.{wra::MapValueSet::_keyForValue}(element as wra::MapValueSet::V);
      return this.{wra::MapValueSet::_baseMap}.{core::Map::containsKey}(key);
    }
    get isEmpty() → core::bool
      return this.{wra::MapValueSet::_baseMap}.{core::Map::isEmpty};
    get isNotEmpty() → core::bool
      return this.{wra::MapValueSet::_baseMap}.{core::Map::isNotEmpty};
    get length() → core::int
      return this.{wra::MapValueSet::_baseMap}.{core::Map::length};
    method toString() → core::String
      return this.{wra::_DelegatingIterableBase::toSet}().{core::Iterable::toString}();
    method add(generic-covariant-impl wra::MapValueSet::V value) → core::bool {
      wra::MapValueSet::K key = this.{wra::MapValueSet::_keyForValue}(value);
      core::bool result = false;
      this.{wra::MapValueSet::_baseMap}.{core::Map::putIfAbsent}(key, () → wra::MapValueSet::V {
        result = true;
        return value;
      });
      return result;
    }
    method addAll(generic-covariant-impl core::Iterable<wra::MapValueSet::V> elements) → void
      return elements.{core::Iterable::forEach}(this.{wra::MapValueSet::add});
    method clear() → void
      return this.{wra::MapValueSet::_baseMap}.{core::Map::clear}();
    method containsAll(core::Iterable<core::Object> other) → core::bool
      return other.{core::Iterable::every}(this.{wra::MapValueSet::contains});
    method difference(core::Set<core::Object> other) → core::Set<wra::MapValueSet::V>
      return this.{wra::_DelegatingIterableBase::where}((wra::MapValueSet::V element) → core::bool => !other.{core::Set::contains}(element)).{core::Iterable::toSet}();
    method intersection(core::Set<core::Object> other) → core::Set<wra::MapValueSet::V>
      return this.{wra::_DelegatingIterableBase::where}(other.{core::Set::contains}).{core::Iterable::toSet}();
    method lookup(core::Object element) → wra::MapValueSet::V {
      if(!element.{core::Object::==}(null) && !(element is wra::MapValueSet::V))
        return null;
      wra::MapValueSet::K key = this.{wra::MapValueSet::_keyForValue}(element as wra::MapValueSet::V);
      return this.{wra::MapValueSet::_baseMap}.{core::Map::[]}(key);
    }
    method remove(core::Object element) → core::bool {
      if(!element.{core::Object::==}(null) && !(element is wra::MapValueSet::V))
        return false;
      wra::MapValueSet::K key = this.{wra::MapValueSet::_keyForValue}(element as wra::MapValueSet::V);
      if(!this.{wra::MapValueSet::_baseMap}.{core::Map::containsKey}(key))
        return false;
      this.{wra::MapValueSet::_baseMap}.{core::Map::remove}(key);
      return true;
    }
    method removeAll(core::Iterable<core::Object> elements) → void
      return elements.{core::Iterable::forEach}(this.{wra::MapValueSet::remove});
    method removeWhere((wra::MapValueSet::V) → core::bool test) → void {
      core::List<dynamic> toRemove = <dynamic>[];
      this.{wra::MapValueSet::_baseMap}.{core::Map::forEach}((wra::MapValueSet::K key, wra::MapValueSet::V value) → core::Null {
        if(test.call(value))
          toRemove.{core::List::add}(key);
      });
      toRemove.{core::Iterable::forEach}(this.{wra::MapValueSet::_baseMap}.{core::Map::remove});
    }
    method retainAll(core::Iterable<core::Object> elements) → void {
      core::Set<wra::MapValueSet::V> valuesToRetain = new col::_IdentityHashSet::•<wra::MapValueSet::V>();
      for (core::Object element in elements)
        #L114:
        {
          if(!element.{core::Object::==}(null) && !(element is wra::MapValueSet::V))
            break #L114;
          wra::MapValueSet::K key = this.{wra::MapValueSet::_keyForValue}(element as wra::MapValueSet::V);
          if(!this.{wra::MapValueSet::_baseMap}.{core::Map::containsKey}(key))
            break #L114;
          valuesToRetain.{core::Set::add}(this.{wra::MapValueSet::_baseMap}.{core::Map::[]}(key));
        }
      core::List<dynamic> keysToRemove = <dynamic>[];
      this.{wra::MapValueSet::_baseMap}.{core::Map::forEach}((wra::MapValueSet::K k, wra::MapValueSet::V v) → core::Null {
        if(!valuesToRetain.{core::Set::contains}(v))
          keysToRemove.{core::List::add}(k);
      });
      keysToRemove.{core::Iterable::forEach}(this.{wra::MapValueSet::_baseMap}.{core::Map::remove});
    }
    method retainWhere((wra::MapValueSet::V) → core::bool test) → void
      return this.{wra::MapValueSet::removeWhere}((wra::MapValueSet::V element) → core::bool => !test.call(element));
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → core::Set<wra::MapValueSet::retype::T>
      return core::Set::castFrom<wra::MapValueSet::V, wra::MapValueSet::retype::T>(this);
    method union(generic-covariant-impl core::Set<wra::MapValueSet::V> other) → core::Set<wra::MapValueSet::V>
      return let final core::Set<wra::MapValueSet::V> #t663 = this.{wra::_DelegatingIterableBase::toSet}() in let final dynamic #t664 = #t663.{core::Set::addAll}(other) in #t663;
  }
}
library charcode.ascii.dollar_lowercase from "package:charcode/ascii.dart" as dol {
  static const field core::int $nul = 0;
  static const field core::int $soh = 1;
  static const field core::int $stx = 2;
  static const field core::int $etx = 3;
  static const field core::int $eot = 4;
  static const field core::int $enq = 5;
  static const field core::int $ack = 6;
  static const field core::int $bel = 7;
  static const field core::int $bs = 8;
  static const field core::int $ht = 9;
  static const field core::int $tab = 9;
  static const field core::int $lf = 10;
  static const field core::int $vt = 11;
  static const field core::int $ff = 12;
  static const field core::int $cr = 13;
  static const field core::int $so = 14;
  static const field core::int $si = 15;
  static const field core::int $dle = 16;
  static const field core::int $dc1 = 17;
  static const field core::int $dc2 = 18;
  static const field core::int $dc3 = 19;
  static const field core::int $dc4 = 20;
  static const field core::int $nak = 21;
  static const field core::int $syn = 22;
  static const field core::int $etb = 23;
  static const field core::int $can = 24;
  static const field core::int $em = 25;
  static const field core::int $sub = 26;
  static const field core::int $esc = 27;
  static const field core::int $fs = 28;
  static const field core::int $gs = 29;
  static const field core::int $rs = 30;
  static const field core::int $us = 31;
  static const field core::int $del = 127;
  static const field core::int $space = 32;
  static const field core::int $exclamation = 33;
  static const field core::int $quot = 34;
  static const field core::int $quote = 34;
  static const field core::int $double_quote = 34;
  static const field core::int $quotation = 34;
  static const field core::int $hash = 35;
  static const field core::int $$ = 36;
  static const field core::int $dollar = 36;
  static const field core::int $percent = 37;
  static const field core::int $amp = 38;
  static const field core::int $ampersand = 38;
  static const field core::int $apos = 39;
  static const field core::int $apostrophe = 39;
  static const field core::int $single_quote = 39;
  static const field core::int $lparen = 40;
  static const field core::int $open_paren = 40;
  static const field core::int $open_parenthesis = 40;
  static const field core::int $rparen = 41;
  static const field core::int $close_paren = 41;
  static const field core::int $close_parenthesis = 41;
  static const field core::int $asterisk = 42;
  static const field core::int $plus = 43;
  static const field core::int $comma = 44;
  static const field core::int $minus = 45;
  static const field core::int $dash = 45;
  static const field core::int $dot = 46;
  static const field core::int $fullstop = 46;
  static const field core::int $slash = 47;
  static const field core::int $solidus = 47;
  static const field core::int $division = 47;
  static const field core::int $0 = 48;
  static const field core::int $1 = 49;
  static const field core::int $2 = 50;
  static const field core::int $3 = 51;
  static const field core::int $4 = 52;
  static const field core::int $5 = 53;
  static const field core::int $6 = 54;
  static const field core::int $7 = 55;
  static const field core::int $8 = 56;
  static const field core::int $9 = 57;
  static const field core::int $colon = 58;
  static const field core::int $semicolon = 59;
  static const field core::int $lt = 60;
  static const field core::int $less_than = 60;
  static const field core::int $langle = 60;
  static const field core::int $open_angle = 60;
  static const field core::int $equal = 61;
  static const field core::int $gt = 62;
  static const field core::int $greater_than = 62;
  static const field core::int $rangle = 62;
  static const field core::int $close_angle = 62;
  static const field core::int $question = 63;
  static const field core::int $at = 64;
  static const field core::int $A = 65;
  static const field core::int $B = 66;
  static const field core::int $C = 67;
  static const field core::int $D = 68;
  static const field core::int $E = 69;
  static const field core::int $F = 70;
  static const field core::int $G = 71;
  static const field core::int $H = 72;
  static const field core::int $I = 73;
  static const field core::int $J = 74;
  static const field core::int $K = 75;
  static const field core::int $L = 76;
  static const field core::int $M = 77;
  static const field core::int $N = 78;
  static const field core::int $O = 79;
  static const field core::int $P = 80;
  static const field core::int $Q = 81;
  static const field core::int $R = 82;
  static const field core::int $S = 83;
  static const field core::int $T = 84;
  static const field core::int $U = 85;
  static const field core::int $V = 86;
  static const field core::int $W = 87;
  static const field core::int $X = 88;
  static const field core::int $Y = 89;
  static const field core::int $Z = 90;
  static const field core::int $lbracket = 91;
  static const field core::int $open_bracket = 91;
  static const field core::int $backslash = 92;
  static const field core::int $rbracket = 93;
  static const field core::int $close_bracket = 93;
  static const field core::int $circumflex = 94;
  static const field core::int $caret = 94;
  static const field core::int $hat = 94;
  static const field core::int $_ = 95;
  static const field core::int $underscore = 95;
  static const field core::int $underline = 95;
  static const field core::int $backquote = 96;
  static const field core::int $grave = 96;
  static const field core::int $a = 97;
  static const field core::int $b = 98;
  static const field core::int $c = 99;
  static const field core::int $d = 100;
  static const field core::int $e = 101;
  static const field core::int $f = 102;
  static const field core::int $g = 103;
  static const field core::int $h = 104;
  static const field core::int $i = 105;
  static const field core::int $j = 106;
  static const field core::int $k = 107;
  static const field core::int $l = 108;
  static const field core::int $m = 109;
  static const field core::int $n = 110;
  static const field core::int $o = 111;
  static const field core::int $p = 112;
  static const field core::int $q = 113;
  static const field core::int $r = 114;
  static const field core::int $s = 115;
  static const field core::int $t = 116;
  static const field core::int $u = 117;
  static const field core::int $v = 118;
  static const field core::int $w = 119;
  static const field core::int $x = 120;
  static const field core::int $y = 121;
  static const field core::int $z = 122;
  static const field core::int $lbrace = 123;
  static const field core::int $open_brace = 123;
  static const field core::int $pipe = 124;
  static const field core::int $bar = 124;
  static const field core::int $rbrace = 125;
  static const field core::int $close_brace = 125;
  static const field core::int $tilde = 126;
}
library charcode.htmlentity.dollar_lowercase from "package:charcode/html_entity.dart" as dol2 {
  export "package:charcode/ascii.dart";
  static const field core::int $nbsp = 160;
  static const field core::int $iexcl = 161;
  static const field core::int $cent = 162;
  static const field core::int $pound = 163;
  static const field core::int $curren = 164;
  static const field core::int $yen = 165;
  static const field core::int $brvbar = 166;
  static const field core::int $sect = 167;
  static const field core::int $uml = 168;
  static const field core::int $copy = 169;
  static const field core::int $ordf = 170;
  static const field core::int $laquo = 171;
  static const field core::int $not = 172;
  static const field core::int $shy = 173;
  static const field core::int $reg = 174;
  static const field core::int $macr = 175;
  static const field core::int $deg = 176;
  static const field core::int $plusmn = 177;
  static const field core::int $sup2 = 178;
  static const field core::int $sup3 = 179;
  static const field core::int $acute = 180;
  static const field core::int $micro = 181;
  static const field core::int $para = 182;
  static const field core::int $middot = 183;
  static const field core::int $cedil = 184;
  static const field core::int $sup1 = 185;
  static const field core::int $ordm = 186;
  static const field core::int $raquo = 187;
  static const field core::int $frac14 = 188;
  static const field core::int $frac12 = 189;
  static const field core::int $frac34 = 190;
  static const field core::int $iquest = 191;
  static const field core::int $Agrave = 192;
  static const field core::int $Aacute = 193;
  static const field core::int $Acirc = 194;
  static const field core::int $Atilde = 195;
  static const field core::int $Auml = 196;
  static const field core::int $Aring = 197;
  static const field core::int $AElig = 198;
  static const field core::int $Ccedil = 199;
  static const field core::int $Egrave = 200;
  static const field core::int $Eacute = 201;
  static const field core::int $Ecirc = 202;
  static const field core::int $Euml = 203;
  static const field core::int $Igrave = 204;
  static const field core::int $Iacute = 205;
  static const field core::int $Icirc = 206;
  static const field core::int $Iuml = 207;
  static const field core::int $ETH = 208;
  static const field core::int $Ntilde = 209;
  static const field core::int $Ograve = 210;
  static const field core::int $Oacute = 211;
  static const field core::int $Ocirc = 212;
  static const field core::int $Otilde = 213;
  static const field core::int $Ouml = 214;
  static const field core::int $times = 215;
  static const field core::int $Oslash = 216;
  static const field core::int $Ugrave = 217;
  static const field core::int $Uacute = 218;
  static const field core::int $Ucirc = 219;
  static const field core::int $Uuml = 220;
  static const field core::int $Yacute = 221;
  static const field core::int $THORN = 222;
  static const field core::int $szlig = 223;
  static const field core::int $agrave = 224;
  static const field core::int $aacute = 225;
  static const field core::int $acirc = 226;
  static const field core::int $atilde = 227;
  static const field core::int $auml = 228;
  static const field core::int $aring = 229;
  static const field core::int $aelig = 230;
  static const field core::int $ccedil = 231;
  static const field core::int $egrave = 232;
  static const field core::int $eacute = 233;
  static const field core::int $ecirc = 234;
  static const field core::int $euml = 235;
  static const field core::int $igrave = 236;
  static const field core::int $iacute = 237;
  static const field core::int $icirc = 238;
  static const field core::int $iuml = 239;
  static const field core::int $eth = 240;
  static const field core::int $ntilde = 241;
  static const field core::int $ograve = 242;
  static const field core::int $oacute = 243;
  static const field core::int $ocirc = 244;
  static const field core::int $otilde = 245;
  static const field core::int $ouml = 246;
  static const field core::int $divide = 247;
  static const field core::int $oslash = 248;
  static const field core::int $ugrave = 249;
  static const field core::int $uacute = 250;
  static const field core::int $ucirc = 251;
  static const field core::int $uuml = 252;
  static const field core::int $yacute = 253;
  static const field core::int $thorn = 254;
  static const field core::int $yuml = 255;
  static const field core::int $OElig = 338;
  static const field core::int $oelig = 339;
  static const field core::int $Scaron = 352;
  static const field core::int $scaron = 353;
  static const field core::int $Yuml = 376;
  static const field core::int $fnof = 402;
  static const field core::int $circ = 710;
  static const field core::int $tilde = 732;
  static const field core::int $Alpha = 913;
  static const field core::int $Beta = 914;
  static const field core::int $Gamma = 915;
  static const field core::int $Delta = 916;
  static const field core::int $Epsilon = 917;
  static const field core::int $Zeta = 918;
  static const field core::int $Eta = 919;
  static const field core::int $Theta = 920;
  static const field core::int $Iota = 921;
  static const field core::int $Kappa = 922;
  static const field core::int $Lambda = 923;
  static const field core::int $Mu = 924;
  static const field core::int $Nu = 925;
  static const field core::int $Xi = 926;
  static const field core::int $Omicron = 927;
  static const field core::int $Pi = 928;
  static const field core::int $Rho = 929;
  static const field core::int $Sigma = 931;
  static const field core::int $Tau = 932;
  static const field core::int $Upsilon = 933;
  static const field core::int $Phi = 934;
  static const field core::int $Chi = 935;
  static const field core::int $Psi = 936;
  static const field core::int $Omega = 937;
  static const field core::int $alpha = 945;
  static const field core::int $beta = 946;
  static const field core::int $gamma = 947;
  static const field core::int $delta = 948;
  static const field core::int $epsilon = 949;
  static const field core::int $zeta = 950;
  static const field core::int $eta = 951;
  static const field core::int $theta = 952;
  static const field core::int $iota = 953;
  static const field core::int $kappa = 954;
  static const field core::int $lambda = 955;
  static const field core::int $mu = 956;
  static const field core::int $nu = 957;
  static const field core::int $xi = 958;
  static const field core::int $omicron = 959;
  static const field core::int $pi = 960;
  static const field core::int $rho = 961;
  static const field core::int $sigmaf = 962;
  static const field core::int $sigma = 963;
  static const field core::int $tau = 964;
  static const field core::int $upsilon = 965;
  static const field core::int $phi = 966;
  static const field core::int $chi = 967;
  static const field core::int $psi = 968;
  static const field core::int $omega = 969;
  static const field core::int $thetasym = 977;
  static const field core::int $upsih = 978;
  static const field core::int $piv = 982;
  static const field core::int $ensp = 8194;
  static const field core::int $emsp = 8195;
  static const field core::int $thinsp = 8201;
  static const field core::int $zwnj = 8204;
  static const field core::int $zwj = 8205;
  static const field core::int $lrm = 8206;
  static const field core::int $rlm = 8207;
  static const field core::int $ndash = 8211;
  static const field core::int $mdash = 8212;
  static const field core::int $lsquo = 8216;
  static const field core::int $rsquo = 8217;
  static const field core::int $sbquo = 8218;
  static const field core::int $ldquo = 8220;
  static const field core::int $rdquo = 8221;
  static const field core::int $bdquo = 8222;
  static const field core::int $dagger = 8224;
  static const field core::int $Dagger = 8225;
  static const field core::int $bull = 8226;
  static const field core::int $hellip = 8230;
  static const field core::int $permil = 8240;
  static const field core::int $prime = 8242;
  static const field core::int $Prime = 8243;
  static const field core::int $lsaquo = 8249;
  static const field core::int $rsaquo = 8250;
  static const field core::int $oline = 8254;
  static const field core::int $frasl = 8260;
  static const field core::int $euro = 8364;
  static const field core::int $image = 8465;
  static const field core::int $weierp = 8472;
  static const field core::int $real = 8476;
  static const field core::int $trade = 8482;
  static const field core::int $alefsym = 8501;
  static const field core::int $larr = 8592;
  static const field core::int $uarr = 8593;
  static const field core::int $rarr = 8594;
  static const field core::int $darr = 8595;
  static const field core::int $harr = 8596;
  static const field core::int $crarr = 8629;
  static const field core::int $lArr = 8656;
  static const field core::int $uArr = 8657;
  static const field core::int $rArr = 8658;
  static const field core::int $dArr = 8659;
  static const field core::int $hArr = 8660;
  static const field core::int $forall = 8704;
  static const field core::int $part = 8706;
  static const field core::int $exist = 8707;
  static const field core::int $empty = 8709;
  static const field core::int $nabla = 8711;
  static const field core::int $isin = 8712;
  static const field core::int $notin = 8713;
  static const field core::int $ni = 8715;
  static const field core::int $prod = 8719;
  static const field core::int $sum = 8721;
  static const field core::int $minus = 8722;
  static const field core::int $lowast = 8727;
  static const field core::int $radic = 8730;
  static const field core::int $prop = 8733;
  static const field core::int $infin = 8734;
  static const field core::int $ang = 8736;
  static const field core::int $and = 8743;
  static const field core::int $or = 8744;
  static const field core::int $cap = 8745;
  static const field core::int $cup = 8746;
  static const field core::int $int = 8747;
  static const field core::int $there4 = 8756;
  static const field core::int $sim = 8764;
  static const field core::int $cong = 8773;
  static const field core::int $asymp = 8776;
  static const field core::int $ne = 8800;
  static const field core::int $equiv = 8801;
  static const field core::int $le = 8804;
  static const field core::int $ge = 8805;
  static const field core::int $sub = 8834;
  static const field core::int $sup = 8835;
  static const field core::int $nsub = 8836;
  static const field core::int $sube = 8838;
  static const field core::int $supe = 8839;
  static const field core::int $oplus = 8853;
  static const field core::int $otimes = 8855;
  static const field core::int $perp = 8869;
  static const field core::int $sdot = 8901;
  static const field core::int $vellip = 8942;
  static const field core::int $lceil = 8968;
  static const field core::int $rceil = 8969;
  static const field core::int $lfloor = 8970;
  static const field core::int $rfloor = 8971;
  static const field core::int $lang = 9001;
  static const field core::int $rang = 9002;
  static const field core::int $loz = 9674;
  static const field core::int $spades = 9824;
  static const field core::int $clubs = 9827;
  static const field core::int $hearts = 9829;
  static const field core::int $diams = 9830;
}
library UuidUtil from "package:uuid/uuid_util.dart" as Uui {
  import "dart:math";
  import "package:crypto/crypto.dart";
  import "package:uuid/aes.dart";
  class UuidUtil extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    static method mathRNG({core::int seed = null}) → core::List<core::int> {
      dynamic rand;
      core::List<core::int> b = core::List::•<core::int>(16);
      math::Random _rand = seed.{core::num::==}(null) ?{math::Random} math::Random::•() : math::Random::•(seed);
      for (core::int i = 0; i.{core::num::<}(16); i = i.{core::num::+}(1)) {
        if(i.{core::int::&}(3).{core::num::==}(0)) {
          rand = _rand.{math::Random::nextDouble}().{core::double::*}(4294967296).{core::double::floor}().{core::num::toInt}();
        }
        b.{core::List::[]=}(i, rand.>>(i.{core::int::&}(3).{core::int::<<}(3)).&(255) as{TypeError} core::int);
      }
      return b;
    }
    static method cryptoRNG() → core::List<dynamic> {
      core::int nBytes = 32;
      core::List<dynamic> pwBytes = core::List::•<dynamic>(nBytes);
      core::List<core::int> bytes = Uui::UuidUtil::mathRNG();
      pwBytes = sha3::sha256.{hash::Hash::convert}(bytes).{dig::Digest::bytes}.{core::List::sublist}(0, nBytes);
      return AES::AES::cipher(pwBytes, AES::AES::keyExpansion(pwBytes));
    }
  }
}
library from "package:crypto/crypto.dart" as cry {
  export "package:crypto/src/digest.dart";
  export "package:crypto/src/hash.dart";
  export "package:crypto/src/hmac.dart";
  export "package:crypto/src/md5.dart";
  export "package:crypto/src/sha1.dart";
  export "package:crypto/src/sha256.dart";
}
library convert from "package:convert/convert.dart" as con6 {
  export "package:convert/src/accumulator_sink.dart";
  export "package:convert/src/byte_accumulator_sink.dart";
  export "package:convert/src/hex.dart";
  export "package:convert/src/percent.dart";
  export "package:convert/src/string_accumulator_sink.dart";
}
library typed_data from "package:typed_data/typed_data.dart" as typ4 {
  export "package:typed_data/typed_buffers.dart";
}
library from "package:path/src/utils.dart" as uti3 {
  import "package:path/src/characters.dart" as chars;
  static method isAlphabetic(core::int char) → core::bool
    return char.{core::num::>=}(cha::UPPER_A) && char.{core::num::<=}(cha::UPPER_Z) || char.{core::num::>=}(cha::LOWER_A) && char.{core::num::<=}(cha::LOWER_Z);
  static method isNumeric(core::int char) → core::bool
    return char.{core::num::>=}(cha::ZERO) && char.{core::num::<=}(cha::NINE);
  static method isDriveLetter(core::String path, core::int index) → core::bool {
    if(path.{core::String::length}.{core::num::<}(index.{core::num::+}(2)))
      return false;
    if(!uti3::isAlphabetic(path.{core::String::codeUnitAt}(index)))
      return false;
    if(!path.{core::String::codeUnitAt}(index.{core::num::+}(1)).{core::num::==}(cha::COLON))
      return false;
    if(path.{core::String::length}.{core::num::==}(index.{core::num::+}(2)))
      return true;
    return path.{core::String::codeUnitAt}(index.{core::num::+}(2)).{core::num::==}(cha::SLASH);
  }
}
library from "package:file/src/interface/error_codes_dart_io.dart" as err3 {
  import "dart:io";
  static final field core::String operatingSystem = io::Platform::operatingSystem;
}
library from "package:matcher/src/core_matchers.dart" as cor {
  import "package:matcher/src/feature_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/type_matcher.dart";
  import "package:matcher/src/util.dart";
  typedef _PredicateFunction<T extends core::Object = dynamic> = (T) → core::bool;
  class _Empty extends int3::Matcher {
    const constructor •() → void
      : super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.isEmpty as{TypeError} core::bool;
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("empty");
  }
  class _NotEmpty extends int3::Matcher {
    const constructor •() → void
      : super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.isNotEmpty as{TypeError} core::bool;
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("non-empty");
  }
  class _IsNull extends int3::Matcher {
    const constructor •() → void
      : super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.{core::Object::==}(null);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("null");
  }
  class _IsNotNull extends int3::Matcher {
    const constructor •() → void
      : super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return !item.{core::Object::==}(null);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("not null");
  }
  class _IsTrue extends int3::Matcher {
    const constructor •() → void
      : super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.{core::Object::==}(true);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("true");
  }
  class _IsFalse extends int3::Matcher {
    const constructor •() → void
      : super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.{core::Object::==}(false);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("false");
  }
  class _IsNaN extends fea::FeatureMatcher<core::num> {
    const constructor •() → void
      : super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::num item, core::Map<dynamic, dynamic> matchState) → core::bool
      return core::double::nan.{core::num::compareTo}(item).{core::num::==}(0);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("NaN");
  }
  class _IsNotNaN extends fea::FeatureMatcher<core::num> {
    const constructor •() → void
      : super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::num item, core::Map<dynamic, dynamic> matchState) → core::bool
      return !core::double::nan.{core::num::compareTo}(item).{core::num::==}(0);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("not NaN");
  }
  class _IsSameAs extends int3::Matcher {
    final field core::Object _expected;
    const constructor •(core::Object _expected) → void
      : cor::_IsSameAs::_expected = _expected, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return core::identical(item, this.{cor::_IsSameAs::_expected});
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("same instance as ").{int3::Description::addDescriptionOf}(this.{cor::_IsSameAs::_expected});
  }
  class _IsAnything extends int3::Matcher {
    const constructor •() → void
      : super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return true;
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("anything");
  }
  @core::Deprecated::•("Use `const TypeMatcher<MyType>()` instead.")
  class isInstanceOf<T extends core::Object = dynamic> extends typ5::TypeMatcher<cor::isInstanceOf::T> {
    const constructor •() → void
      : super typ5::TypeMatcher::•()
      ;
  }
  class _ReturnsNormally extends fea::FeatureMatcher<core::Function> {
    const constructor •() → void
      : super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::Function f, core::Map<dynamic, dynamic> matchState) → core::bool {
      try {
        f.call();
        return true;
      }
      on dynamic catch(final dynamic e, final core::StackTrace s) {
        util2::addStateInfo(matchState, <dynamic, dynamic>{"exception": e, "stack": s});
        return false;
      }
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("return normally");
    method describeTypedMismatch(generic-covariant-impl core::Function item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      mismatchDescription.{int3::Description::add}("threw ").{int3::Description::addDescriptionOf}(matchState.{core::Map::[]}("exception"));
      if(verbose) {
        mismatchDescription.{int3::Description::add}(" at ").{int3::Description::add}(matchState.{core::Map::[]}("stack").{core::Object::toString}());
      }
      return mismatchDescription;
    }
  }
  class _HasLength extends int3::Matcher {
    final field int3::Matcher _matcher;
    const constructor •([int3::Matcher matcher = null]) → void
      : cor::_HasLength::_matcher = matcher, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool {
      try {
        if(item.length.*(item.length).>=(0) as{TypeError} core::bool) {
          return this.{cor::_HasLength::_matcher}.{int3::Matcher::matches}(item.length, matchState);
        }
      }
      on dynamic catch(final dynamic e) {
        return false;
      }
      throw new core::UnsupportedError::•("Should never get here");
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("an object with length of ").{int3::Description::addDescriptionOf}(this.{cor::_HasLength::_matcher});
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      try {
        if(item.length.*(item.length).>=(0) as{TypeError} core::bool) {
          return mismatchDescription.{int3::Description::add}("has length of ").{int3::Description::addDescriptionOf}(item.length);
        }
      }
      on dynamic catch(final dynamic e) {
        return mismatchDescription.{int3::Description::add}("has no length property");
      }
      throw new core::UnsupportedError::•("Should never get here");
    }
  }
  class _Contains extends int3::Matcher {
    final field core::Object _expected;
    const constructor •(core::Object _expected) → void
      : cor::_Contains::_expected = _expected, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool {
      core::Object expected = this.{cor::_Contains::_expected};
      if(item is core::String) {
        return expected is core::Pattern && item{core::String}.{core::String::contains}(expected{core::Pattern});
      }
      else
        if(item is core::Iterable<dynamic>) {
          if(expected is int3::Matcher) {
            return item{core::Iterable<dynamic>}.{core::Iterable::any}((dynamic e) → core::bool => expected{int3::Matcher}.{int3::Matcher::matches}(e, matchState));
          }
          else {
            return item{core::Iterable<dynamic>}.{core::Iterable::contains}(this.{cor::_Contains::_expected});
          }
        }
        else
          if(item is core::Map<dynamic, dynamic>) {
            return item{core::Map<dynamic, dynamic>}.{core::Map::containsKey}(this.{cor::_Contains::_expected});
          }
      return false;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("contains ").{int3::Description::addDescriptionOf}(this.{cor::_Contains::_expected});
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      if(item is core::String || item is core::Iterable<dynamic> || item is core::Map<dynamic, dynamic>) {
        return super.{int3::Matcher::describeMismatch}(item, mismatchDescription, matchState, verbose);
      }
      else {
        return mismatchDescription.{int3::Description::add}("is not a string, map or iterable");
      }
    }
  }
  class _In<T extends core::Object = dynamic> extends fea::FeatureMatcher<cor::_In::T> {
    final field core::Object _source;
    final field (cor::_In::T) → core::bool _containsFunction;
    const constructor •(core::Object _source, (cor::_In::T) → core::bool _containsFunction) → void
      : cor::_In::_source = _source, cor::_In::_containsFunction = _containsFunction, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl cor::_In::T item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{cor::_In::_containsFunction}(item);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("is in ").{int3::Description::addDescriptionOf}(this.{cor::_In::_source});
  }
  class _Predicate<T extends core::Object = dynamic> extends fea::FeatureMatcher<cor::_Predicate::T> {
    final field (cor::_Predicate::T) → core::bool _matcher;
    final field core::String _description;
    constructor •((cor::_Predicate::T) → core::bool _matcher, core::String _description) → void
      : cor::_Predicate::_matcher = _matcher, cor::_Predicate::_description = _description, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl cor::_Predicate::T item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{cor::_Predicate::_matcher}(item);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}(this.{cor::_Predicate::_description});
  }
  static const field int3::Matcher isEmpty = const cor::_Empty::•();
  static const field int3::Matcher isNotEmpty = const cor::_NotEmpty::•();
  static const field int3::Matcher isNull = const cor::_IsNull::•();
  static const field int3::Matcher isNotNull = const cor::_IsNotNull::•();
  static const field int3::Matcher isTrue = const cor::_IsTrue::•();
  static const field int3::Matcher isFalse = const cor::_IsFalse::•();
  static const field int3::Matcher isNaN = const cor::_IsNaN::•();
  static const field int3::Matcher isNotNaN = const cor::_IsNotNaN::•();
  static const field int3::Matcher anything = const cor::_IsAnything::•();
  static const field int3::Matcher returnsNormally = const cor::_ReturnsNormally::•();
  static const field typ5::TypeMatcher<core::Map<dynamic, dynamic>> isMap = const typ5::TypeMatcher::•<core::Map<dynamic, dynamic>>();
  static const field typ5::TypeMatcher<core::List<dynamic>> isList = const typ5::TypeMatcher::•<core::List<dynamic>>();
  static method same(dynamic expected) → int3::Matcher
    return new cor::_IsSameAs::•(expected);
  static method hasLength(dynamic matcher) → int3::Matcher
    return new cor::_HasLength::•(util2::wrapMatcher(matcher));
  static method contains(dynamic expected) → int3::Matcher
    return new cor::_Contains::•(expected);
  static method isIn(dynamic expected) → int3::Matcher {
    if(expected is core::Iterable<dynamic>) {
      return new cor::_In::•<core::Object>(expected{core::Iterable<dynamic>}, expected{core::Iterable<dynamic>}.{core::Iterable::contains});
    }
    else
      if(expected is core::String) {
        return new cor::_In::•<core::Pattern>(expected{core::String}, expected{core::String}.{core::String::contains});
      }
      else
        if(expected is core::Map<dynamic, dynamic>) {
          return new cor::_In::•<core::Object>(expected{core::Map<dynamic, dynamic>}, expected{core::Map<dynamic, dynamic>}.{core::Map::containsKey});
        }
    throw new core::ArgumentError::value(expected, "expected", "Only Iterable, Map, and String are supported.");
  }
  static method predicate<T extends core::Object = dynamic>((cor::predicate::T) → core::bool f, [core::String description = "satisfies function"]) → int3::Matcher
    return new cor::_Predicate::•<cor::predicate::T>(f, description);
}
library from "package:matcher/src/custom_matcher.dart" as cus {
  import "package:stack_trace/stack_trace.dart";
  import "package:matcher/src/description.dart";
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/util.dart";
  class CustomMatcher extends int3::Matcher {
    final field core::String _featureDescription;
    final field core::String _featureName;
    final field int3::Matcher _matcher;
    constructor •(core::String _featureDescription, core::String _featureName, dynamic matcher) → void
      : cus::CustomMatcher::_featureDescription = _featureDescription, cus::CustomMatcher::_featureName = _featureName, cus::CustomMatcher::_matcher = util2::wrapMatcher(matcher), super int3::Matcher::•()
      ;
    method featureValueOf(dynamic actual) → core::Object
      return actual;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool {
      try {
        core::Object f = this.{cus::CustomMatcher::featureValueOf}(item);
        if(this.{cus::CustomMatcher::_matcher}.{int3::Matcher::matches}(f, matchState))
          return true;
        util2::addStateInfo(matchState, <dynamic, dynamic>{"custom.feature": f});
      }
      on dynamic catch(final dynamic exception, final core::StackTrace stack) {
        util2::addStateInfo(matchState, <dynamic, dynamic>{"custom.exception": exception.{core::Object::toString}(), "custom.stack": cha3::Chain::forTrace(stack).{cha3::Chain::foldFrames}((fra::Frame frame) → core::bool => frame.{fra::Frame::package}.{core::String::==}("test") || frame.{fra::Frame::package}.{core::String::==}("stream_channel") || frame.{fra::Frame::package}.{core::String::==}("matcher"), terse: true).{cha3::Chain::toString}()});
      }
      return false;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}(this.{cus::CustomMatcher::_featureDescription}).{int3::Description::add}(" ").{int3::Description::addDescriptionOf}(this.{cus::CustomMatcher::_matcher});
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      if(!matchState.{core::Map::[]}("custom.exception").{core::Object::==}(null)) {
        mismatchDescription.{int3::Description::add}("threw ").{int3::Description::addDescriptionOf}(matchState.{core::Map::[]}("custom.exception")).{int3::Description::add}("\n").{int3::Description::add}(matchState.{core::Map::[]}("custom.stack").{core::Object::toString}());
        return mismatchDescription;
      }
      mismatchDescription.{int3::Description::add}("has ").{int3::Description::add}(this.{cus::CustomMatcher::_featureName}).{int3::Description::add}(" with value ").{int3::Description::addDescriptionOf}(matchState.{core::Map::[]}("custom.feature"));
      des::StringDescription innerDescription = new des::StringDescription::•();
      this.{cus::CustomMatcher::_matcher}.{int3::Matcher::describeMismatch}(matchState.{core::Map::[]}("custom.feature"), innerDescription, matchState.{core::Map::[]}("state") as core::Map<dynamic, dynamic>, verbose);
      if(innerDescription.{des::StringDescription::length}.{core::num::>}(0)) {
        mismatchDescription.{int3::Description::add}(" which ").{int3::Description::add}(innerDescription.{des::StringDescription::toString}());
      }
      return mismatchDescription;
    }
  }
}
library from "package:matcher/src/description.dart" as des {
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/pretty_print.dart";
  class StringDescription extends core::Object implements int3::Description {
    final field core::StringBuffer _out = new core::StringBuffer::•();
    constructor •([core::String init = ""]) → void
      : super core::Object::•() {
      this.{des::StringDescription::_out}.{core::StringBuffer::write}(init);
    }
    get length() → core::int
      return this.{des::StringDescription::_out}.{core::StringBuffer::length};
    method toString() → core::String
      return this.{des::StringDescription::_out}.{core::StringBuffer::toString}();
    method add(core::String text) → int3::Description {
      this.{des::StringDescription::_out}.{core::StringBuffer::write}(text);
      return this;
    }
    method replace(core::String text) → int3::Description {
      this.{des::StringDescription::_out}.{core::StringBuffer::clear}();
      return this.{des::StringDescription::add}(text);
    }
    method addDescriptionOf(dynamic value) → int3::Description {
      if(value is int3::Matcher) {
        value{int3::Matcher}.{int3::Matcher::describe}(this);
      }
      else {
        this.{des::StringDescription::add}(pre::prettyPrint(value, maxLineLength: 80, maxItems: 25));
      }
      return this;
    }
    method addAll(core::String start, core::String separator, core::String end, core::Iterable<dynamic> list) → int3::Description {
      core::bool separate = false;
      this.{des::StringDescription::add}(start);
      for (dynamic item in list) {
        if(separate) {
          this.{des::StringDescription::add}(separator);
        }
        this.{des::StringDescription::addDescriptionOf}(item);
        separate = true;
      }
      this.{des::StringDescription::add}(end);
      return this;
    }
  }
}
library from "package:matcher/src/equals_matcher.dart" as equ4 {
  import "package:matcher/src/description.dart";
  import "package:matcher/src/feature_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/util.dart";
  typedef _RecursiveMatcher = (dynamic, dynamic, core::String, core::int) → core::List<core::String>;
  class _StringEqualsMatcher extends fea::FeatureMatcher<core::String> {
    final field core::String _value;
    constructor •(core::String _value) → void
      : equ4::_StringEqualsMatcher::_value = _value, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::String item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{equ4::_StringEqualsMatcher::_value}.{core::String::==}(item);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::addDescriptionOf}(this.{equ4::_StringEqualsMatcher::_value});
    method describeTypedMismatch(generic-covariant-impl core::String item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      core::StringBuffer buff = new core::StringBuffer::•();
      buff.{core::StringBuffer::write}("is different.");
      core::String escapedItem = util2::escape(item);
      core::String escapedValue = util2::escape(this.{equ4::_StringEqualsMatcher::_value});
      core::int minLength = escapedItem.{core::String::length}.{core::num::<}(escapedValue.{core::String::length}) ?{core::int} escapedItem.{core::String::length} : escapedValue.{core::String::length};
      core::int start = 0;
      #L115:
      for (; start.{core::num::<}(minLength); start = start.{core::num::+}(1)) {
        if(!escapedValue.{core::String::codeUnitAt}(start).{core::num::==}(escapedItem.{core::String::codeUnitAt}(start))) {
          break #L115;
        }
      }
      if(start.{core::num::==}(minLength)) {
        if(escapedValue.{core::String::length}.{core::num::<}(escapedItem.{core::String::length})) {
          buff.{core::StringBuffer::write}(" Both strings start the same, but the actual value also has the following trailing characters: ");
          equ4::_StringEqualsMatcher::_writeTrailing(buff, escapedItem, escapedValue.{core::String::length});
        }
        else {
          buff.{core::StringBuffer::write}(" Both strings start the same, but the actual value is missing the following trailing characters: ");
          equ4::_StringEqualsMatcher::_writeTrailing(buff, escapedValue, escapedItem.{core::String::length});
        }
      }
      else {
        buff.{core::StringBuffer::write}("\nExpected: ");
        equ4::_StringEqualsMatcher::_writeLeading(buff, escapedValue, start);
        equ4::_StringEqualsMatcher::_writeTrailing(buff, escapedValue, start);
        buff.{core::StringBuffer::write}("\n  Actual: ");
        equ4::_StringEqualsMatcher::_writeLeading(buff, escapedItem, start);
        equ4::_StringEqualsMatcher::_writeTrailing(buff, escapedItem, start);
        buff.{core::StringBuffer::write}("\n          ");
        for (core::int i = start.{core::num::>}(10) ?{core::int} 14 : start; i.{core::num::>}(0); i = i.{core::num::-}(1))
          buff.{core::StringBuffer::write}(" ");
        buff.{core::StringBuffer::write}("^\n Differ at offset ${start}");
      }
      return mismatchDescription.{int3::Description::add}(buff.{core::StringBuffer::toString}());
    }
    static method _writeLeading(core::StringBuffer buff, core::String s, core::int start) → void {
      if(start.{core::num::>}(10)) {
        buff.{core::StringBuffer::write}("... ");
        buff.{core::StringBuffer::write}(s.{core::String::substring}(start.{core::num::-}(10), start));
      }
      else {
        buff.{core::StringBuffer::write}(s.{core::String::substring}(0, start));
      }
    }
    static method _writeTrailing(core::StringBuffer buff, core::String s, core::int start) → void {
      if(start.{core::num::+}(10).{core::num::>}(s.{core::String::length})) {
        buff.{core::StringBuffer::write}(s.{core::String::substring}(start));
      }
      else {
        buff.{core::StringBuffer::write}(s.{core::String::substring}(start, start.{core::num::+}(10)));
        buff.{core::StringBuffer::write}(" ...");
      }
    }
  }
  class _DeepMatcher extends int3::Matcher {
    final field core::Object _expected;
    final field core::int _limit;
    constructor •(core::Object _expected, [core::int limit = 1000]) → void
      : equ4::_DeepMatcher::_expected = _expected, equ4::_DeepMatcher::_limit = limit, super int3::Matcher::•()
      ;
    method _compareIterables(core::Iterable<dynamic> expected, core::Object actual, (dynamic, dynamic, core::String, core::int) → core::List<core::String> matcher, core::int depth, core::String location) → core::List<core::String> {
      if(actual is core::Iterable<dynamic>) {
        core::Iterator<dynamic> expectedIterator = expected.{core::Iterable::iterator};
        core::Iterator<dynamic> actualIterator = actual{core::Iterable<dynamic>}.{core::Iterable::iterator};
        for (core::int index = 0; ; index = index.{core::num::+}(1)) {
          core::bool expectedNext = expectedIterator.{core::Iterator::moveNext}();
          core::bool actualNext = actualIterator.{core::Iterator::moveNext}();
          if(!expectedNext && !actualNext)
            return null;
          core::String newLocation = "${location}[${index}]";
          if(!expectedNext)
            return <core::String>["longer than expected", newLocation];
          if(!actualNext)
            return <core::String>["shorter than expected", newLocation];
          core::List<core::String> rp = matcher.call(expectedIterator.{core::Iterator::current}, actualIterator.{core::Iterator::current}, newLocation, depth);
          if(!rp.{core::Object::==}(null))
            return rp;
        }
      }
      else {
        return <core::String>["is not Iterable", location];
      }
    }
    method _compareSets(core::Set<dynamic> expected, core::Object actual, (dynamic, dynamic, core::String, core::int) → core::List<core::String> matcher, core::int depth, core::String location) → core::List<core::String> {
      if(actual is core::Iterable<dynamic>) {
        core::Set<dynamic> other = actual{core::Iterable<dynamic>}.{core::Iterable::toSet}();
        for (dynamic expectedElement in expected) {
          if(other.{core::Iterable::every}((dynamic actualElement) → core::bool => !matcher.call(expectedElement, actualElement, location, depth).{core::Object::==}(null))) {
            return <core::String>["does not contain ${expectedElement}", location];
          }
        }
        if(other.{_in::EfficientLengthIterable::length}.{core::num::>}(expected.{_in::EfficientLengthIterable::length})) {
          return <core::String>["larger than expected", location];
        }
        else
          if(other.{_in::EfficientLengthIterable::length}.{core::num::<}(expected.{_in::EfficientLengthIterable::length})) {
            return <core::String>["smaller than expected", location];
          }
          else {
            return null;
          }
      }
      else {
        return <core::String>["is not Iterable", location];
      }
    }
    method _recursiveMatch(core::Object expected, core::Object actual, core::String location, core::int depth) → core::List<core::String> {
      if(expected is int3::Matcher) {
        core::Map<dynamic, dynamic> matchState = <dynamic, dynamic>{};
        if(expected{int3::Matcher}.{int3::Matcher::matches}(actual, matchState))
          return null;
        des::StringDescription description = new des::StringDescription::•();
        expected{int3::Matcher}.{int3::Matcher::describe}(description);
        return <core::String>["does not match ${description}", location];
      }
      else {
        try {
          if(expected.{core::Object::==}(actual))
            return null;
        }
        on dynamic catch(final dynamic e) {
          return <core::String>["== threw \"${e}\"", location];
        }
      }
      if(depth.{core::num::>}(this.{equ4::_DeepMatcher::_limit}))
        return <core::String>["recursion depth limit exceeded", location];
      if(depth.{core::num::==}(0) || this.{equ4::_DeepMatcher::_limit}.{core::num::>}(1)) {
        if(expected is core::Set<dynamic>) {
          return this.{equ4::_DeepMatcher::_compareSets}(expected{core::Set<dynamic>}, actual, this.{equ4::_DeepMatcher::_recursiveMatch}, depth.{core::num::+}(1), location);
        }
        else
          if(expected is core::Iterable<dynamic>) {
            return this.{equ4::_DeepMatcher::_compareIterables}(expected{core::Iterable<dynamic>}, actual, this.{equ4::_DeepMatcher::_recursiveMatch}, depth.{core::num::+}(1), location);
          }
          else
            if(expected is core::Map<dynamic, dynamic>) {
              if(!(actual is core::Map<dynamic, dynamic>))
                return <core::String>["expected a map", location];
              core::Map<dynamic, dynamic> map = actual as core::Map<dynamic, dynamic>;
              core::String err = expected{core::Map<dynamic, dynamic>}.{core::Map::length}.{core::num::==}(map.{core::Map::length}) ?{core::String} "" : "has different length and ";
              for (dynamic key in expected{core::Map<dynamic, dynamic>}.{core::Map::keys}) {
                if(!map.{core::Map::containsKey}(key)) {
                  return <core::String>["${err}is missing map key '${key}'", location];
                }
              }
              for (dynamic key in map.{core::Map::keys}) {
                if(!expected{core::Map<dynamic, dynamic>}.{core::Map::containsKey}(key)) {
                  return <core::String>["${err}has extra map key '${key}'", location];
                }
              }
              for (dynamic key in expected{core::Map<dynamic, dynamic>}.{core::Map::keys}) {
                core::List<core::String> rp = this.{equ4::_DeepMatcher::_recursiveMatch}(expected{core::Map<dynamic, dynamic>}.{core::Map::[]}(key), map.{core::Map::[]}(key), "${location}['${key}']", depth.{core::num::+}(1));
                if(!rp.{core::Object::==}(null))
                  return rp;
              }
              return null;
            }
      }
      des::StringDescription description = new des::StringDescription::•();
      if(depth.{core::num::>}(0)) {
        description.{des::StringDescription::add}("was ").{int3::Description::addDescriptionOf}(actual).{int3::Description::add}(" instead of ").{int3::Description::addDescriptionOf}(expected);
        return <core::String>[description.{des::StringDescription::toString}(), location];
      }
      return <core::String>["", location];
    }
    method _match(dynamic expected, dynamic actual, core::Map<dynamic, dynamic> matchState) → core::String {
      core::List<core::String> rp = this.{equ4::_DeepMatcher::_recursiveMatch}(expected, actual, "", 0);
      if(rp.{core::Object::==}(null))
        return null;
      core::String reason;
      if(rp.{core::List::[]}(0).{core::String::isNotEmpty}) {
        if(rp.{core::List::[]}(1).{core::String::isNotEmpty}) {
          reason = "${rp.{core::List::[]}(0)} at location ${rp.{core::List::[]}(1)}";
        }
        else {
          reason = rp.{core::List::[]}(0);
        }
      }
      else {
        reason = "";
      }
      util2::addStateInfo(matchState, <dynamic, dynamic>{"reason": reason});
      return reason;
    }
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{equ4::_DeepMatcher::_match}(this.{equ4::_DeepMatcher::_expected}, item, matchState).{core::String::==}(null);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::addDescriptionOf}(this.{equ4::_DeepMatcher::_expected});
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      core::String reason = let final core::String #t665 = matchState.{core::Map::[]}("reason") as core::String in #t665.==(null) ?{core::String} "" : #t665;
      if(reason.{core::String::isEmpty} && mismatchDescription.{int3::Description::length}.{core::num::>}(0)) {
        mismatchDescription.{int3::Description::add}("is ").{int3::Description::addDescriptionOf}(item);
      }
      else {
        mismatchDescription.{int3::Description::add}(reason);
      }
      return mismatchDescription;
    }
  }
  static method equals(dynamic expected, [core::int limit = 100]) → int3::Matcher
    return expected is core::String ?{int3::Matcher} new equ4::_StringEqualsMatcher::•(expected{core::String}) : new equ4::_DeepMatcher::•(expected, limit);
}
library from "package:matcher/src/error_matchers.dart" as err4 {
  import "package:matcher/src/type_matcher.dart";
  static const field typ5::TypeMatcher<core::ArgumentError> isArgumentError = const typ5::TypeMatcher::•<core::ArgumentError>();
  static const field typ5::TypeMatcher<core::CastError> isCastError = const typ5::TypeMatcher::•<core::CastError>();
  static const field typ5::TypeMatcher<core::ConcurrentModificationError> isConcurrentModificationError = const typ5::TypeMatcher::•<core::ConcurrentModificationError>();
  static const field typ5::TypeMatcher<core::CyclicInitializationError> isCyclicInitializationError = const typ5::TypeMatcher::•<core::CyclicInitializationError>();
  static const field typ5::TypeMatcher<core::Exception> isException = const typ5::TypeMatcher::•<core::Exception>();
  static const field typ5::TypeMatcher<core::FormatException> isFormatException = const typ5::TypeMatcher::•<core::FormatException>();
  static const field typ5::TypeMatcher<core::NoSuchMethodError> isNoSuchMethodError = const typ5::TypeMatcher::•<core::NoSuchMethodError>();
  static const field typ5::TypeMatcher<core::NullThrownError> isNullThrownError = const typ5::TypeMatcher::•<core::NullThrownError>();
  static const field typ5::TypeMatcher<core::RangeError> isRangeError = const typ5::TypeMatcher::•<core::RangeError>();
  static const field typ5::TypeMatcher<core::StateError> isStateError = const typ5::TypeMatcher::•<core::StateError>();
  static const field typ5::TypeMatcher<core::UnimplementedError> isUnimplementedError = const typ5::TypeMatcher::•<core::UnimplementedError>();
  static const field typ5::TypeMatcher<core::UnsupportedError> isUnsupportedError = const typ5::TypeMatcher::•<core::UnsupportedError>();
}
library from "package:matcher/src/interfaces.dart" as int3 {
  abstract class Description extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get length() → core::int;
    abstract method replace(core::String text) → int3::Description;
    abstract method add(core::String text) → int3::Description;
    abstract method addDescriptionOf(dynamic value) → int3::Description;
    abstract method addAll(core::String start, core::String separator, core::String end, core::Iterable<dynamic> list) → int3::Description;
  }
  abstract class Matcher extends core::Object {
    const constructor •() → void
      : super core::Object::•()
      ;
    abstract method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool;
    abstract method describe(int3::Description description) → int3::Description;
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description
      return mismatchDescription;
  }
}
library from "package:matcher/src/iterable_matchers.dart" as ite2 {
  import "package:matcher/src/description.dart";
  import "package:matcher/src/equals_matcher.dart";
  import "package:matcher/src/feature_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/util.dart";
  typedef _Comparator<S extends core::Object = dynamic, T extends core::Object = dynamic> = (S, T) → core::bool;
  class _EveryElement extends ite2::_IterableMatcher {
    final field int3::Matcher _matcher;
    constructor •(int3::Matcher _matcher) → void
      : ite2::_EveryElement::_matcher = _matcher, super ite2::_IterableMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::Iterable<dynamic> item, core::Map<dynamic, dynamic> matchState) → core::bool {
      core::int i = 0;
      for (dynamic element in item) {
        if(!this.{ite2::_EveryElement::_matcher}.{int3::Matcher::matches}(element, matchState)) {
          util2::addStateInfo(matchState, <dynamic, dynamic>{"index": i, "element": element});
          return false;
        }
        i = i.{core::num::+}(1);
      }
      return true;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("every element(").{int3::Description::addDescriptionOf}(this.{ite2::_EveryElement::_matcher}).{int3::Description::add}(")");
    method describeTypedMismatch(generic-covariant-impl core::Iterable<dynamic> item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      if(!matchState.{core::Map::[]}("index").{core::Object::==}(null)) {
        dynamic index = matchState.{core::Map::[]}("index");
        dynamic element = matchState.{core::Map::[]}("element");
        mismatchDescription.{int3::Description::add}("has value ").{int3::Description::addDescriptionOf}(element).{int3::Description::add}(" which ");
        des::StringDescription subDescription = new des::StringDescription::•();
        this.{ite2::_EveryElement::_matcher}.{int3::Matcher::describeMismatch}(element, subDescription, matchState.{core::Map::[]}("state") as core::Map<dynamic, dynamic>, verbose);
        if(subDescription.{des::StringDescription::length}.{core::num::>}(0)) {
          mismatchDescription.{int3::Description::add}(subDescription.{des::StringDescription::toString}());
        }
        else {
          mismatchDescription.{int3::Description::add}("doesn't match ");
          this.{ite2::_EveryElement::_matcher}.{int3::Matcher::describe}(mismatchDescription);
        }
        mismatchDescription.{int3::Description::add}(" at index ${index}");
        return mismatchDescription;
      }
      return super.{fea::FeatureMatcher::describeMismatch}(item, mismatchDescription, matchState, verbose);
    }
  }
  class _AnyElement extends ite2::_IterableMatcher {
    final field int3::Matcher _matcher;
    constructor •(int3::Matcher _matcher) → void
      : ite2::_AnyElement::_matcher = _matcher, super ite2::_IterableMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::Iterable<dynamic> item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.{core::Iterable::any}((dynamic e) → core::bool => this.{ite2::_AnyElement::_matcher}.{int3::Matcher::matches}(e, matchState));
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("some element ").{int3::Description::addDescriptionOf}(this.{ite2::_AnyElement::_matcher});
  }
  class _OrderedEquals extends ite2::_IterableMatcher {
    final field core::Iterable<dynamic> _expected;
    final field int3::Matcher _matcher;
    constructor •(core::Iterable<dynamic> _expected) → void
      : ite2::_OrderedEquals::_expected = _expected, ite2::_OrderedEquals::_matcher = equ4::equals(_expected, 1), super ite2::_IterableMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::Iterable<dynamic> item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{ite2::_OrderedEquals::_matcher}.{int3::Matcher::matches}(item, matchState);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("equals ").{int3::Description::addDescriptionOf}(this.{ite2::_OrderedEquals::_expected}).{int3::Description::add}(" ordered");
    method describeTypedMismatch(generic-covariant-impl core::Iterable<dynamic> item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      return this.{ite2::_OrderedEquals::_matcher}.{int3::Matcher::describeMismatch}(item, mismatchDescription, matchState, verbose);
    }
  }
  class _UnorderedEquals extends ite2::_UnorderedMatches {
    final field core::List<dynamic> _expectedValues;
    constructor •(core::Iterable<dynamic> expected) → void
      : ite2::_UnorderedEquals::_expectedValues = expected.{core::Iterable::toList}(), super ite2::_UnorderedMatches::•(expected.{core::Iterable::map}<dynamic>(equ4::equals))
      ;
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("equals ").{int3::Description::addDescriptionOf}(this.{ite2::_UnorderedEquals::_expectedValues}).{int3::Description::add}(" unordered");
  }
  abstract class _IterableMatcher extends fea::FeatureMatcher<core::Iterable<dynamic>> {
    const constructor •() → void
      : super fea::FeatureMatcher::•()
      ;
  }
  class _UnorderedMatches extends ite2::_IterableMatcher {
    final field core::List<int3::Matcher> _expected;
    final field core::bool _allowUnmatchedValues;
    constructor •(core::Iterable<dynamic> expected, {core::bool allowUnmatchedValues = null}) → void
      : ite2::_UnorderedMatches::_expected = expected.{core::Iterable::map}<int3::Matcher>(util2::wrapMatcher).{core::Iterable::toList}(), ite2::_UnorderedMatches::_allowUnmatchedValues = let final core::bool #t666 = allowUnmatchedValues in #t666.==(null) ?{core::bool} false : #t666, super ite2::_IterableMatcher::•()
      ;
    method _test(core::List<dynamic> values) → core::String {
      if(this.{ite2::_UnorderedMatches::_expected}.{core::List::length}.{core::num::>}(values.{core::List::length})) {
        return "has too few elements (${values.{core::List::length}} < ${this.{ite2::_UnorderedMatches::_expected}.{core::List::length}})";
      }
      else
        if(!this.{ite2::_UnorderedMatches::_allowUnmatchedValues} && this.{ite2::_UnorderedMatches::_expected}.{core::List::length}.{core::num::<}(values.{core::List::length})) {
          return "has too many elements (${values.{core::List::length}} > ${this.{ite2::_UnorderedMatches::_expected}.{core::List::length}})";
        }
      core::List<core::List<core::int>> edges = core::List::generate<core::List<core::int>>(values.{core::List::length}, (core::int _) → core::List<core::int> => <core::int>[], growable: false);
      for (core::int v = 0; v.{core::num::<}(values.{core::List::length}); v = v.{core::num::+}(1)) {
        for (core::int m = 0; m.{core::num::<}(this.{ite2::_UnorderedMatches::_expected}.{core::List::length}); m = m.{core::num::+}(1)) {
          if(this.{ite2::_UnorderedMatches::_expected}.{core::List::[]}(m).{int3::Matcher::matches}(values.{core::List::[]}(v), <dynamic, dynamic>{})) {
            edges.{core::List::[]}(v).{core::List::add}(m);
          }
        }
      }
      core::List<core::int> matched = core::List::•<core::int>(this.{ite2::_UnorderedMatches::_expected}.{core::List::length});
      for (core::int valueIndex = 0; valueIndex.{core::num::<}(values.{core::List::length}); valueIndex = valueIndex.{core::num::+}(1)) {
        this.{ite2::_UnorderedMatches::_findPairing}(edges, valueIndex, matched);
      }
      for (core::int matcherIndex = 0; matcherIndex.{core::num::<}(this.{ite2::_UnorderedMatches::_expected}.{core::List::length}); matcherIndex = matcherIndex.{core::num::+}(1)) {
        if(matched.{core::List::[]}(matcherIndex).{core::num::==}(null)) {
          final int3::Description description = new des::StringDescription::•().{des::StringDescription::add}("has no match for ").{int3::Description::addDescriptionOf}(this.{ite2::_UnorderedMatches::_expected}.{core::List::[]}(matcherIndex)).{int3::Description::add}(" at index ${matcherIndex}");
          final core::int remainingUnmatched = matched.{core::List::sublist}(matcherIndex.{core::num::+}(1)).{core::Iterable::where}((core::int m) → core::bool => m.{core::num::==}(null)).{core::Iterable::length};
          return remainingUnmatched.{core::num::==}(0) ?{core::String} description.{core::Object::toString}() : description.{int3::Description::add}(" along with ${remainingUnmatched} other unmatched").{core::Object::toString}();
        }
      }
      return null;
    }
    method typedMatches(generic-covariant-impl core::Iterable<dynamic> item, core::Map<dynamic, dynamic> mismatchState) → core::bool
      return this.{ite2::_UnorderedMatches::_test}(item.{core::Iterable::toList}()).{core::String::==}(null);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("matches ").{int3::Description::addAll}("[", ", ", "]", this.{ite2::_UnorderedMatches::_expected}).{int3::Description::add}(" unordered");
    method describeTypedMismatch(generic-covariant-impl core::Iterable<dynamic> item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description
      return mismatchDescription.{int3::Description::add}(this.{ite2::_UnorderedMatches::_test}(item.{core::Iterable::toList}()));
    method _findPairing(core::List<core::List<core::int>> edges, core::int valueIndex, core::List<core::int> matched, [core::Set<core::int> reserved = null]) → core::bool {
      reserved.{core::Object::==}(null) ?{core::Set<core::int>} reserved = col::LinkedHashSet::•<core::int>() : null;
      final core::Iterable<core::int> possiblePairings = edges.{core::List::[]}(valueIndex).{core::Iterable::where}((core::int m) → core::bool => !reserved.{core::Set::contains}(m));
      for (final core::int matcherIndex in possiblePairings) {
        reserved.{core::Set::add}(matcherIndex);
        final core::int previouslyMatched = matched.{core::List::[]}(matcherIndex);
        if(previouslyMatched.{core::num::==}(null) || this.{ite2::_UnorderedMatches::_findPairing}(edges, matched.{core::List::[]}(matcherIndex), matched, reserved)) {
          matched.{core::List::[]=}(matcherIndex, valueIndex);
          return true;
        }
      }
      return false;
    }
  }
  class _PairwiseCompare<S extends core::Object = dynamic, T extends core::Object = dynamic> extends ite2::_IterableMatcher {
    final field core::Iterable<ite2::_PairwiseCompare::S> _expected;
    final field (ite2::_PairwiseCompare::S, ite2::_PairwiseCompare::T) → core::bool _comparator;
    final field core::String _description;
    constructor •(core::Iterable<ite2::_PairwiseCompare::S> _expected, (ite2::_PairwiseCompare::S, ite2::_PairwiseCompare::T) → core::bool _comparator, core::String _description) → void
      : ite2::_PairwiseCompare::_expected = _expected, ite2::_PairwiseCompare::_comparator = _comparator, ite2::_PairwiseCompare::_description = _description, super ite2::_IterableMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::Iterable<dynamic> item, core::Map<dynamic, dynamic> matchState) → core::bool {
      if(!item.{core::Iterable::length}.{core::num::==}(this.{ite2::_PairwiseCompare::_expected}.{core::Iterable::length}))
        return false;
      core::Iterator<dynamic> iterator = item.{core::Iterable::iterator};
      core::int i = 0;
      for (ite2::_PairwiseCompare::S e in this.{ite2::_PairwiseCompare::_expected}) {
        iterator.{core::Iterator::moveNext}();
        if(!this.{ite2::_PairwiseCompare::_comparator}(e, iterator.{core::Iterator::current} as ite2::_PairwiseCompare::T)) {
          util2::addStateInfo(matchState, <dynamic, dynamic>{"index": i, "expected": e, "actual": iterator.{core::Iterator::current}});
          return false;
        }
        i = i.{core::num::+}(1);
      }
      return true;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("pairwise ${this.{ite2::_PairwiseCompare::_description}} ").{int3::Description::addDescriptionOf}(this.{ite2::_PairwiseCompare::_expected});
    method describeTypedMismatch(generic-covariant-impl core::Iterable<dynamic> item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      if(!item.{core::Iterable::length}.{core::num::==}(this.{ite2::_PairwiseCompare::_expected}.{core::Iterable::length})) {
        return mismatchDescription.{int3::Description::add}("has length ${item.{core::Iterable::length}} instead of ${this.{ite2::_PairwiseCompare::_expected}.{core::Iterable::length}}");
      }
      else {
        return mismatchDescription.{int3::Description::add}("has ").{int3::Description::addDescriptionOf}(matchState.{core::Map::[]}("actual")).{int3::Description::add}(" which is not ${this.{ite2::_PairwiseCompare::_description}} ").{int3::Description::addDescriptionOf}(matchState.{core::Map::[]}("expected")).{int3::Description::add}(" at index ${matchState.{core::Map::[]}("index")}");
      }
    }
  }
  class _ContainsAll extends ite2::_UnorderedMatches {
    final field core::Iterable<dynamic> _unwrappedExpected;
    constructor •(core::Iterable<dynamic> expected) → void
      : ite2::_ContainsAll::_unwrappedExpected = expected, super ite2::_UnorderedMatches::•(expected.{core::Iterable::map}<dynamic>(util2::wrapMatcher), allowUnmatchedValues: true)
      ;
    @core::override
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("contains all of ").{int3::Description::addDescriptionOf}(this.{ite2::_ContainsAll::_unwrappedExpected});
  }
  class _ContainsAllInOrder extends ite2::_IterableMatcher {
    final field core::Iterable<dynamic> _expected;
    constructor •(core::Iterable<dynamic> _expected) → void
      : ite2::_ContainsAllInOrder::_expected = _expected, super ite2::_IterableMatcher::•()
      ;
    method _test(core::Iterable<dynamic> item, core::Map<dynamic, dynamic> matchState) → core::String {
      core::List<int3::Matcher> matchers = this.{ite2::_ContainsAllInOrder::_expected}.{core::Iterable::map}<int3::Matcher>(util2::wrapMatcher).{core::Iterable::toList}();
      core::int matcherIndex = 0;
      for (dynamic value in item) {
        if(matchers.{core::List::[]}(matcherIndex).{int3::Matcher::matches}(value, matchState))
          matcherIndex = matcherIndex.{core::num::+}(1);
        if(matcherIndex.{core::num::==}(matchers.{core::List::length}))
          return null;
      }
      return new des::StringDescription::•().{des::StringDescription::add}("did not find a value matching ").{int3::Description::addDescriptionOf}(matchers.{core::List::[]}(matcherIndex)).{int3::Description::add}(" following expected prior values").{core::Object::toString}();
    }
    @core::override
    method typedMatches(generic-covariant-impl core::Iterable<dynamic> item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{ite2::_ContainsAllInOrder::_test}(item, matchState).{core::String::==}(null);
    @core::override
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("contains in order(").{int3::Description::addDescriptionOf}(this.{ite2::_ContainsAllInOrder::_expected}).{int3::Description::add}(")");
    @core::override
    method describeTypedMismatch(generic-covariant-impl core::Iterable<dynamic> item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description
      return mismatchDescription.{int3::Description::add}(this.{ite2::_ContainsAllInOrder::_test}(item, matchState));
  }
  static method everyElement(dynamic matcher) → int3::Matcher
    return new ite2::_EveryElement::•(util2::wrapMatcher(matcher));
  static method anyElement(dynamic matcher) → int3::Matcher
    return new ite2::_AnyElement::•(util2::wrapMatcher(matcher));
  static method orderedEquals(core::Iterable<dynamic> expected) → int3::Matcher
    return new ite2::_OrderedEquals::•(expected);
  static method unorderedEquals(core::Iterable<dynamic> expected) → int3::Matcher
    return new ite2::_UnorderedEquals::•(expected);
  static method unorderedMatches(core::Iterable<dynamic> expected) → int3::Matcher
    return new ite2::_UnorderedMatches::•(expected);
  static method pairwiseCompare<S extends core::Object = dynamic, T extends core::Object = dynamic>(core::Iterable<ite2::pairwiseCompare::S> expected, (ite2::pairwiseCompare::S, ite2::pairwiseCompare::T) → core::bool comparator, core::String description) → int3::Matcher
    return new ite2::_PairwiseCompare::•<ite2::pairwiseCompare::S, ite2::pairwiseCompare::T>(expected, comparator, description);
  static method containsAll(core::Iterable<dynamic> expected) → int3::Matcher
    return new ite2::_ContainsAll::•(expected);
  static method containsAllInOrder(core::Iterable<dynamic> expected) → int3::Matcher
    return new ite2::_ContainsAllInOrder::•(expected);
}
library from "package:matcher/src/map_matchers.dart" as map3 {
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/util.dart";
  class _ContainsValue extends int3::Matcher {
    final field core::Object _value;
    const constructor •(core::Object _value) → void
      : map3::_ContainsValue::_value = _value, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.containsValue(this.{map3::_ContainsValue::_value}) as{TypeError} core::bool;
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("contains value ").{int3::Description::addDescriptionOf}(this.{map3::_ContainsValue::_value});
  }
  class _ContainsMapping extends int3::Matcher {
    final field core::Object _key;
    final field int3::Matcher _valueMatcher;
    const constructor •(core::Object _key, int3::Matcher _valueMatcher) → void
      : map3::_ContainsMapping::_key = _key, map3::_ContainsMapping::_valueMatcher = _valueMatcher, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.containsKey(this.{map3::_ContainsMapping::_key}) as{TypeError} core::bool && this.{map3::_ContainsMapping::_valueMatcher}.{int3::Matcher::matches}(item.[](this.{map3::_ContainsMapping::_key}), matchState);
    method describe(int3::Description description) → int3::Description {
      return description.{int3::Description::add}("contains pair ").{int3::Description::addDescriptionOf}(this.{map3::_ContainsMapping::_key}).{int3::Description::add}(" => ").{int3::Description::addDescriptionOf}(this.{map3::_ContainsMapping::_valueMatcher});
    }
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      if(!(item.containsKey(this.{map3::_ContainsMapping::_key}) as{TypeError} core::bool)) {
        return mismatchDescription.{int3::Description::add}(" doesn't contain key ").{int3::Description::addDescriptionOf}(this.{map3::_ContainsMapping::_key});
      }
      else {
        mismatchDescription.{int3::Description::add}(" contains key ").{int3::Description::addDescriptionOf}(this.{map3::_ContainsMapping::_key}).{int3::Description::add}(" but with value ");
        this.{map3::_ContainsMapping::_valueMatcher}.{int3::Matcher::describeMismatch}(item.[](this.{map3::_ContainsMapping::_key}), mismatchDescription, matchState, verbose);
        return mismatchDescription;
      }
    }
  }
  static method containsValue(dynamic value) → int3::Matcher
    return new map3::_ContainsValue::•(value);
  static method containsPair(dynamic key, dynamic value) → int3::Matcher
    return new map3::_ContainsMapping::•(key, util2::wrapMatcher(value));
}
library from "package:matcher/src/numeric_matchers.dart" as num {
  import "package:matcher/src/feature_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  class _IsCloseTo extends fea::FeatureMatcher<core::num> {
    final field core::num _value;
    final field core::num _delta;
    const constructor •(core::num _value, core::num _delta) → void
      : num::_IsCloseTo::_value = _value, num::_IsCloseTo::_delta = _delta, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::num item, core::Map<dynamic, dynamic> matchState) → core::bool {
      core::num diff = item.{core::num::-}(this.{num::_IsCloseTo::_value});
      if(diff.{core::num::<}(0))
        diff = diff.{core::num::unary-}();
      return diff.{core::num::<=}(this.{num::_IsCloseTo::_delta});
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("a numeric value within ").{int3::Description::addDescriptionOf}(this.{num::_IsCloseTo::_delta}).{int3::Description::add}(" of ").{int3::Description::addDescriptionOf}(this.{num::_IsCloseTo::_value});
    method describeTypedMismatch(generic-covariant-impl core::num item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      core::num diff = item.{core::num::-}(this.{num::_IsCloseTo::_value});
      if(diff.{core::num::<}(0))
        diff = diff.{core::num::unary-}();
      return mismatchDescription.{int3::Description::add}(" differs by ").{int3::Description::addDescriptionOf}(diff);
    }
  }
  class _InRange extends fea::FeatureMatcher<core::num> {
    final field core::num _low;
    final field core::num _high;
    final field core::bool _lowMatchValue;
    final field core::bool _highMatchValue;
    const constructor •(core::num _low, core::num _high, core::bool _lowMatchValue, core::bool _highMatchValue) → void
      : num::_InRange::_low = _low, num::_InRange::_high = _high, num::_InRange::_lowMatchValue = _lowMatchValue, num::_InRange::_highMatchValue = _highMatchValue, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::num value, core::Map<dynamic, dynamic> matchState) → core::bool {
      if(value.{core::num::<}(this.{num::_InRange::_low}) || value.{core::num::>}(this.{num::_InRange::_high})) {
        return false;
      }
      if(value.{core::num::==}(this.{num::_InRange::_low})) {
        return this.{num::_InRange::_lowMatchValue};
      }
      if(value.{core::num::==}(this.{num::_InRange::_high})) {
        return this.{num::_InRange::_highMatchValue};
      }
      return true;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("be in range from ${this.{num::_InRange::_low}} (${this.{num::_InRange::_lowMatchValue} ?{core::String} "inclusive" : "exclusive"}) to ${this.{num::_InRange::_high}} (${this.{num::_InRange::_highMatchValue} ?{core::String} "inclusive" : "exclusive"})");
  }
  static method closeTo(core::num value, core::num delta) → int3::Matcher
    return new num::_IsCloseTo::•(value, delta);
  static method inInclusiveRange(core::num low, core::num high) → int3::Matcher
    return new num::_InRange::•(low, high, true, true);
  static method inExclusiveRange(core::num low, core::num high) → int3::Matcher
    return new num::_InRange::•(low, high, false, false);
  static method inOpenClosedRange(core::num low, core::num high) → int3::Matcher
    return new num::_InRange::•(low, high, false, true);
  static method inClosedOpenRange(core::num low, core::num high) → int3::Matcher
    return new num::_InRange::•(low, high, true, false);
}
library from "package:matcher/src/operator_matchers.dart" as ope {
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/util.dart";
  class _IsNot extends int3::Matcher {
    final field int3::Matcher _matcher;
    const constructor •(int3::Matcher _matcher) → void
      : ope::_IsNot::_matcher = _matcher, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool
      return !this.{ope::_IsNot::_matcher}.{int3::Matcher::matches}(item, matchState);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("not ").{int3::Description::addDescriptionOf}(this.{ope::_IsNot::_matcher});
  }
  class _AllOf extends int3::Matcher {
    final field core::List<int3::Matcher> _matchers;
    const constructor •(core::List<int3::Matcher> _matchers) → void
      : ope::_AllOf::_matchers = _matchers, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool {
      for (int3::Matcher matcher in this.{ope::_AllOf::_matchers}) {
        if(!matcher.{int3::Matcher::matches}(item, matchState)) {
          util2::addStateInfo(matchState, <dynamic, dynamic>{"matcher": matcher});
          return false;
        }
      }
      return true;
    }
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      dynamic matcher = matchState.{core::Map::[]}("matcher");
      matcher.describeMismatch(item, mismatchDescription, matchState.{core::Map::[]}("state"), verbose);
      return mismatchDescription;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::addAll}("(", " and ", ")", this.{ope::_AllOf::_matchers});
  }
  class _AnyOf extends int3::Matcher {
    final field core::List<int3::Matcher> _matchers;
    const constructor •(core::List<int3::Matcher> _matchers) → void
      : ope::_AnyOf::_matchers = _matchers, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool {
      for (int3::Matcher matcher in this.{ope::_AnyOf::_matchers}) {
        if(matcher.{int3::Matcher::matches}(item, matchState)) {
          return true;
        }
      }
      return false;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::addAll}("(", " or ", ")", this.{ope::_AnyOf::_matchers});
  }
  static method isNot(dynamic matcher) → int3::Matcher
    return new ope::_IsNot::•(util2::wrapMatcher(matcher));
  static method allOf(dynamic arg0, [dynamic arg1 = null, dynamic arg2 = null, dynamic arg3 = null, dynamic arg4 = null, dynamic arg5 = null, dynamic arg6 = null]) → int3::Matcher {
    return new ope::_AllOf::•(ope::_wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
  static method anyOf(dynamic arg0, [dynamic arg1 = null, dynamic arg2 = null, dynamic arg3 = null, dynamic arg4 = null, dynamic arg5 = null, dynamic arg6 = null]) → int3::Matcher {
    return new ope::_AnyOf::•(ope::_wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
  static method _wrapArgs(dynamic arg0, dynamic arg1, dynamic arg2, dynamic arg3, dynamic arg4, dynamic arg5, dynamic arg6) → core::List<int3::Matcher> {
    core::Iterable<dynamic> args;
    if(arg0 is core::List<dynamic>) {
      if(!arg1.{core::Object::==}(null) || !arg2.{core::Object::==}(null) || !arg3.{core::Object::==}(null) || !arg4.{core::Object::==}(null) || !arg5.{core::Object::==}(null) || !arg6.{core::Object::==}(null)) {
        throw new core::ArgumentError::•("If arg0 is a List, all other arguments must be null.");
      }
      args = arg0{core::List<dynamic>};
    }
    else {
      args = <dynamic>[arg0, arg1, arg2, arg3, arg4, arg5, arg6].{core::Iterable::where}((dynamic e) → core::bool => !e.{core::Object::==}(null));
    }
    return args.{core::Iterable::map}<int3::Matcher>(util2::wrapMatcher).{core::Iterable::toList}();
  }
}
library from "package:matcher/src/order_matchers.dart" as ord {
  import "package:matcher/src/interfaces.dart";
  class _OrderingMatcher extends int3::Matcher {
    final field core::Object _value;
    final field core::bool _equalValue;
    final field core::bool _lessThanValue;
    final field core::bool _greaterThanValue;
    final field core::String _comparisonDescription;
    final field core::bool _valueInDescription;
    const constructor •(core::Object _value, core::bool _equalValue, core::bool _lessThanValue, core::bool _greaterThanValue, core::String _comparisonDescription, [core::bool valueInDescription = true]) → void
      : ord::_OrderingMatcher::_value = _value, ord::_OrderingMatcher::_equalValue = _equalValue, ord::_OrderingMatcher::_lessThanValue = _lessThanValue, ord::_OrderingMatcher::_greaterThanValue = _greaterThanValue, ord::_OrderingMatcher::_comparisonDescription = _comparisonDescription, ord::_OrderingMatcher::_valueInDescription = valueInDescription, super int3::Matcher::•()
      ;
    method matches(dynamic item, core::Map<dynamic, dynamic> matchState) → core::bool {
      if(item.{core::Object::==}(this.{ord::_OrderingMatcher::_value})) {
        return this.{ord::_OrderingMatcher::_equalValue};
      }
      else
        if(item.<(this.{ord::_OrderingMatcher::_value}) as{TypeError} core::bool) {
          return this.{ord::_OrderingMatcher::_lessThanValue};
        }
        else {
          return this.{ord::_OrderingMatcher::_greaterThanValue};
        }
    }
    method describe(int3::Description description) → int3::Description {
      if(this.{ord::_OrderingMatcher::_valueInDescription}) {
        return description.{int3::Description::add}(this.{ord::_OrderingMatcher::_comparisonDescription}).{int3::Description::add}(" ").{int3::Description::addDescriptionOf}(this.{ord::_OrderingMatcher::_value});
      }
      else {
        return description.{int3::Description::add}(this.{ord::_OrderingMatcher::_comparisonDescription});
      }
    }
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      mismatchDescription.{int3::Description::add}("is not ");
      return this.{ord::_OrderingMatcher::describe}(mismatchDescription);
    }
  }
  static const field int3::Matcher isZero = const ord::_OrderingMatcher::•(0, true, false, false, "a value equal to");
  static const field int3::Matcher isNonZero = const ord::_OrderingMatcher::•(0, false, true, true, "a value not equal to");
  static const field int3::Matcher isPositive = const ord::_OrderingMatcher::•(0, false, false, true, "a positive value", false);
  static const field int3::Matcher isNonPositive = const ord::_OrderingMatcher::•(0, true, true, false, "a non-positive value", false);
  static const field int3::Matcher isNegative = const ord::_OrderingMatcher::•(0, false, true, false, "a negative value", false);
  static const field int3::Matcher isNonNegative = const ord::_OrderingMatcher::•(0, true, false, true, "a non-negative value", false);
  static method greaterThan(dynamic value) → int3::Matcher
    return new ord::_OrderingMatcher::•(value, false, false, true, "a value greater than");
  static method greaterThanOrEqualTo(dynamic value) → int3::Matcher
    return new ord::_OrderingMatcher::•(value, true, false, true, "a value greater than or equal to");
  static method lessThan(dynamic value) → int3::Matcher
    return new ord::_OrderingMatcher::•(value, false, true, false, "a value less than");
  static method lessThanOrEqualTo(dynamic value) → int3::Matcher
    return new ord::_OrderingMatcher::•(value, true, true, false, "a value less than or equal to");
}
library from "package:matcher/src/string_matchers.dart" as str4 {
  import "package:matcher/src/feature_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  class _IsEqualIgnoringCase extends fea::FeatureMatcher<core::String> {
    final field core::String _value;
    final field core::String _matchValue;
    constructor •(core::String value) → void
      : str4::_IsEqualIgnoringCase::_value = value, str4::_IsEqualIgnoringCase::_matchValue = value.{core::String::toLowerCase}(), super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::String item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{str4::_IsEqualIgnoringCase::_matchValue}.{core::String::==}(item.{core::String::toLowerCase}());
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::addDescriptionOf}(this.{str4::_IsEqualIgnoringCase::_value}).{int3::Description::add}(" ignoring case");
  }
  class _IsEqualIgnoringWhitespace extends fea::FeatureMatcher<core::String> {
    final field core::String _value;
    final field core::String _matchValue;
    constructor •(core::String value) → void
      : str4::_IsEqualIgnoringWhitespace::_value = value, str4::_IsEqualIgnoringWhitespace::_matchValue = str4::collapseWhitespace(value), super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::String item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{str4::_IsEqualIgnoringWhitespace::_matchValue}.{core::String::==}(str4::collapseWhitespace(item));
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::addDescriptionOf}(this.{str4::_IsEqualIgnoringWhitespace::_matchValue}).{int3::Description::add}(" ignoring whitespace");
    method describeTypedMismatch(generic-covariant-impl core::String item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      return mismatchDescription.{int3::Description::add}("is ").{int3::Description::addDescriptionOf}(str4::collapseWhitespace(item)).{int3::Description::add}(" with whitespace compressed");
    }
  }
  class _StringStartsWith extends fea::FeatureMatcher<core::String> {
    final field core::String _prefix;
    const constructor •(core::String _prefix) → void
      : str4::_StringStartsWith::_prefix = _prefix, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::String item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.{core::String::startsWith}(this.{str4::_StringStartsWith::_prefix});
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("a string starting with ").{int3::Description::addDescriptionOf}(this.{str4::_StringStartsWith::_prefix});
  }
  class _StringEndsWith extends fea::FeatureMatcher<core::String> {
    final field core::String _suffix;
    const constructor •(core::String _suffix) → void
      : str4::_StringEndsWith::_suffix = _suffix, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::String item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item.{core::String::endsWith}(this.{str4::_StringEndsWith::_suffix});
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("a string ending with ").{int3::Description::addDescriptionOf}(this.{str4::_StringEndsWith::_suffix});
  }
  class _StringContainsInOrder extends fea::FeatureMatcher<core::String> {
    final field core::List<core::String> _substrings;
    const constructor •(core::List<core::String> _substrings) → void
      : str4::_StringContainsInOrder::_substrings = _substrings, super fea::FeatureMatcher::•()
      ;
    method typedMatches(generic-covariant-impl core::String item, core::Map<dynamic, dynamic> matchState) → core::bool {
      core::int fromIndex = 0;
      for (core::String s in this.{str4::_StringContainsInOrder::_substrings}) {
        fromIndex = item.{core::String::indexOf}(s, fromIndex);
        if(fromIndex.{core::num::<}(0))
          return false;
      }
      return true;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::addAll}("a string containing ", ", ", " in order", this.{str4::_StringContainsInOrder::_substrings});
  }
  class _MatchesRegExp extends fea::FeatureMatcher<core::String> {
    field core::RegExp _regexp = null;
    constructor •(dynamic re) → void
      : super fea::FeatureMatcher::•() {
      if(re is core::String) {
        this.{str4::_MatchesRegExp::_regexp} = core::RegExp::•(re{core::String});
      }
      else
        if(re is core::RegExp) {
          this.{str4::_MatchesRegExp::_regexp} = re{core::RegExp};
        }
        else {
          throw new core::ArgumentError::•("matches requires a regexp or string");
        }
    }
    method typedMatches(generic-covariant-impl core::String item, core::Map<dynamic, dynamic> matchState) → core::bool
      return this.{str4::_MatchesRegExp::_regexp}.{core::RegExp::hasMatch}(item);
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("match '${this.{str4::_MatchesRegExp::_regexp}.{core::RegExp::pattern}}'");
  }
  static method equalsIgnoringCase(core::String value) → int3::Matcher
    return new str4::_IsEqualIgnoringCase::•(value);
  static method equalsIgnoringWhitespace(core::String value) → int3::Matcher
    return new str4::_IsEqualIgnoringWhitespace::•(value);
  static method startsWith(core::String prefixString) → int3::Matcher
    return new str4::_StringStartsWith::•(prefixString);
  static method endsWith(core::String suffixString) → int3::Matcher
    return new str4::_StringEndsWith::•(suffixString);
  static method stringContainsInOrder(core::List<core::String> substrings) → int3::Matcher
    return new str4::_StringContainsInOrder::•(substrings);
  static method matches(dynamic re) → int3::Matcher
    return new str4::_MatchesRegExp::•(re);
  static method collapseWhitespace(core::String string) → core::String {
    core::StringBuffer result = new core::StringBuffer::•();
    core::bool skipSpace = true;
    for (core::int i = 0; i.{core::num::<}(string.{core::String::length}); i = i.{core::num::+}(1)) {
      core::String character = string.{core::String::[]}(i);
      if(str4::_isWhitespace(character)) {
        if(!skipSpace) {
          result.{core::StringBuffer::write}(" ");
          skipSpace = true;
        }
      }
      else {
        result.{core::StringBuffer::write}(character);
        skipSpace = false;
      }
    }
    return result.{core::StringBuffer::toString}().{core::String::trim}();
  }
  static method _isWhitespace(core::String ch) → core::bool
    return ch.{core::String::==}(" ") || ch.{core::String::==}("\n") || ch.{core::String::==}("\r") || ch.{core::String::==}("\t");
}
library from "package:matcher/src/type_matcher.dart" as typ5 {
  import "package:matcher/src/having_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  class TypeMatcher<T extends core::Object = dynamic> extends int3::Matcher {
    final field core::String _name;
    const constructor •([@core::Deprecated::•("Provide a type argument to TypeMatcher and omit the name. This argument will be removed in the next release.") core::String name = null]) → void
      : typ5::TypeMatcher::_name = name, super int3::Matcher::•()
      ;
    method having((typ5::TypeMatcher::T) → core::Object feature, core::String description, core::Object matcher) → typ5::TypeMatcher<typ5::TypeMatcher::T>
      return new hav::HavingMatcher::•<typ5::TypeMatcher::T>(this, description, feature, matcher);
    method describe(int3::Description description) → int3::Description {
      core::String name = let final core::String #t667 = this.{typ5::TypeMatcher::_name} in #t667.==(null) ?{core::String} typ5::_stripDynamic(typ5::TypeMatcher::T) : #t667;
      return description.{int3::Description::add}("<Instance of '${name}'>");
    }
    method matches(core::Object item, core::Map<dynamic, dynamic> matchState) → core::bool
      return item is typ5::TypeMatcher::T;
  }
  static final field core::RegExp _dart2DynamicArgs = core::RegExp::•("<dynamic(, dynamic)*>");
  static method _stripDynamic(core::Type type) → core::String
    return type.{core::Object::toString}().{core::String::replaceAll}(typ5::_dart2DynamicArgs, "");
}
library from "package:matcher/src/util.dart" as util2 {
  import "package:matcher/src/core_matchers.dart";
  import "package:matcher/src/equals_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  typedef _Predicate<T extends core::Object = dynamic> = (T) → core::bool;
  static const field core::Map<core::String, core::String> _escapeMap = const <core::String, core::String>{"\n": "\\n", "\r": "\\r", "\f": "\\f", "\u0008": "\\b", "\t": "\\t", "\v": "\\v", "\u0127": "\\x7F"};
  static final field core::RegExp _escapeRegExp = core::RegExp::•("[\\x00-\\x07\\x0E-\\x1F${util2::_escapeMap.{core::Map::keys}.{core::Iterable::map}<core::String>(util2::_getHexLiteral).{core::Iterable::join}()}]");
  static method addStateInfo(core::Map<dynamic, dynamic> matchState, core::Map<dynamic, dynamic> values) → void {
    core::Map<dynamic, dynamic> innerState = col::LinkedHashMap::from<dynamic, dynamic>(matchState);
    matchState.{core::Map::clear}();
    matchState.{core::Map::[]=}("state", innerState);
    matchState.{core::Map::addAll}(values);
  }
  static method wrapMatcher(dynamic x) → int3::Matcher {
    if(x is int3::Matcher) {
      return x{int3::Matcher};
    }
    else
      if(x is (core::Object) → core::bool) {
        return cor::predicate<core::Object>(x{(core::Object) → core::bool});
      }
      else
        if(x is (core::Null) → core::bool) {
          return cor::predicate<dynamic>((dynamic a) → core::bool => (x{(core::Null) → core::bool} as dynamic).call(a) as{TypeError} core::bool);
        }
        else {
          return equ4::equals(x);
        }
  }
  static method escape(core::String str) → core::String {
    str = str.{core::String::replaceAll}("\\", "\\\\");
    return str.{core::String::replaceAllMapped}(util2::_escapeRegExp, (core::Match match) → core::String {
      core::String mapped = util2::_escapeMap.{core::Map::[]}(match.{core::Match::[]}(0));
      if(!mapped.{core::String::==}(null))
        return mapped;
      return util2::_getHexLiteral(match.{core::Match::[]}(0));
    });
  }
  static method _getHexLiteral(core::String input) → core::String {
    core::int rune = input.{core::String::runes}.{core::Iterable::single};
    return "\\x".{core::String::+}(rune.{core::int::toRadixString}(16).{core::String::toUpperCase}().{core::String::padLeft}(2, "0"));
  }
}
library from "package:source_span/src/file.dart" as file3 {
  import "dart:math" as math;
  import "dart:typed_data";
  import "package:source_span/src/location.dart";
  import "package:source_span/src/location_mixin.dart";
  import "package:source_span/src/span.dart";
  import "package:source_span/src/span_mixin.dart";
  import "package:source_span/src/span_with_context.dart";
  class SourceFile extends core::Object {
    final field core::Uri url;
    final field core::List<core::int> _lineStarts = <core::int>[0];
    final field typ2::Uint32List _decodedChars;
    field core::int _cachedLine = null;
    @core::Deprecated::•("Will be removed in 2.0.0")
    constructor •(core::String text, {dynamic url = null}) → void
      : this file3::SourceFile::decoded(text.{core::String::runes}, url: url)
      ;
    constructor fromString(core::String text, {dynamic url = null}) → void
      : this file3::SourceFile::decoded(text.{core::String::codeUnits}, url: url)
      ;
    constructor decoded(core::Iterable<core::int> decodedChars, {dynamic url = null}) → void
      : file3::SourceFile::url = (url is core::String ?{dynamic} core::Uri::parse(url{core::String}) : url) as{TypeError} core::Uri, file3::SourceFile::_decodedChars = imp::NativeUint32List::fromList(decodedChars.{core::Iterable::toList}()), super core::Object::•() {
      for (core::int i = 0; i.{core::num::<}(this.{file3::SourceFile::_decodedChars}.{core::List::length}); i = i.{core::num::+}(1)) {
        core::int c = this.{file3::SourceFile::_decodedChars}.{core::List::[]}(i);
        if(c.{core::num::==}(file3::_CR)) {
          core::int j = i.{core::num::+}(1);
          if(j.{core::num::>=}(this.{file3::SourceFile::_decodedChars}.{core::List::length}) || !this.{file3::SourceFile::_decodedChars}.{core::List::[]}(j).{core::num::==}(file3::_LF))
            c = file3::_LF;
        }
        if(c.{core::num::==}(file3::_LF))
          this.{file3::SourceFile::_lineStarts}.{core::List::add}(i.{core::num::+}(1));
      }
    }
    get length() → core::int
      return this.{file3::SourceFile::_decodedChars}.{core::List::length};
    get lines() → core::int
      return this.{file3::SourceFile::_lineStarts}.{core::List::length};
    method span(core::int start, [core::int end = null]) → file3::FileSpan {
      if(end.{core::num::==}(null))
        end = this.{file3::SourceFile::length}.{core::num::-}(1);
      return new file3::_FileSpan::•(this, start, end);
    }
    method location(core::int offset) → file3::FileLocation
      return new file3::FileLocation::_(this, offset);
    method getLine(core::int offset) → core::int {
      if(offset.{core::num::<}(0)) {
        throw new core::RangeError::•("Offset may not be negative, was ${offset}.");
      }
      else
        if(offset.{core::num::>}(this.{file3::SourceFile::length})) {
          throw new core::RangeError::•("Offset ${offset} must not be greater than the number of characters in the file, ${this.{file3::SourceFile::length}}.");
        }
      if(offset.{core::num::<}(this.{file3::SourceFile::_lineStarts}.{core::Iterable::first}))
        return 1.{core::int::unary-}();
      if(offset.{core::num::>=}(this.{file3::SourceFile::_lineStarts}.{core::Iterable::last}))
        return this.{file3::SourceFile::_lineStarts}.{core::List::length}.{core::num::-}(1);
      if(this.{file3::SourceFile::_isNearCachedLine}(offset))
        return this.{file3::SourceFile::_cachedLine};
      this.{file3::SourceFile::_cachedLine} = this.{file3::SourceFile::_binarySearch}(offset).{core::num::-}(1);
      return this.{file3::SourceFile::_cachedLine};
    }
    method _isNearCachedLine(core::int offset) → core::bool {
      if(this.{file3::SourceFile::_cachedLine}.{core::num::==}(null))
        return false;
      if(offset.{core::num::<}(this.{file3::SourceFile::_lineStarts}.{core::List::[]}(this.{file3::SourceFile::_cachedLine})))
        return false;
      if(this.{file3::SourceFile::_cachedLine}.{core::num::>=}(this.{file3::SourceFile::_lineStarts}.{core::List::length}.{core::num::-}(1)) || offset.{core::num::<}(this.{file3::SourceFile::_lineStarts}.{core::List::[]}(this.{file3::SourceFile::_cachedLine}.{core::num::+}(1)))) {
        return true;
      }
      if(this.{file3::SourceFile::_cachedLine}.{core::num::>=}(this.{file3::SourceFile::_lineStarts}.{core::List::length}.{core::num::-}(2)) || offset.{core::num::<}(this.{file3::SourceFile::_lineStarts}.{core::List::[]}(this.{file3::SourceFile::_cachedLine}.{core::num::+}(2)))) {
        this.{file3::SourceFile::_cachedLine} = this.{file3::SourceFile::_cachedLine}.{core::num::+}(1);
        return true;
      }
      return false;
    }
    method _binarySearch(core::int offset) → core::int {
      core::int min = 0;
      core::int max = this.{file3::SourceFile::_lineStarts}.{core::List::length}.{core::num::-}(1);
      while (min.{core::num::<}(max)) {
        core::int half = min.{core::num::+}(max.{core::num::-}(min).{core::num::~/}(2));
        if(this.{file3::SourceFile::_lineStarts}.{core::List::[]}(half).{core::num::>}(offset)) {
          max = half;
        }
        else {
          min = half.{core::num::+}(1);
        }
      }
      return max;
    }
    method getColumn(core::int offset, {core::int line = null}) → core::int {
      if(offset.{core::num::<}(0)) {
        throw new core::RangeError::•("Offset may not be negative, was ${offset}.");
      }
      else
        if(offset.{core::num::>}(this.{file3::SourceFile::length})) {
          throw new core::RangeError::•("Offset ${offset} must be not be greater than the number of characters in the file, ${this.{file3::SourceFile::length}}.");
        }
      if(line.{core::num::==}(null)) {
        line = this.{file3::SourceFile::getLine}(offset);
      }
      else
        if(line.{core::num::<}(0)) {
          throw new core::RangeError::•("Line may not be negative, was ${line}.");
        }
        else
          if(line.{core::num::>=}(this.{file3::SourceFile::lines})) {
            throw new core::RangeError::•("Line ${line} must be less than the number of lines in the file, ${this.{file3::SourceFile::lines}}.");
          }
      core::int lineStart = this.{file3::SourceFile::_lineStarts}.{core::List::[]}(line);
      if(lineStart.{core::num::>}(offset)) {
        throw new core::RangeError::•("Line ${line} comes after offset ${offset}.");
      }
      return offset.{core::num::-}(lineStart);
    }
    method getOffset(core::int line, [core::int column = null]) → core::int {
      if(column.{core::num::==}(null))
        column = 0;
      if(line.{core::num::<}(0)) {
        throw new core::RangeError::•("Line may not be negative, was ${line}.");
      }
      else
        if(line.{core::num::>=}(this.{file3::SourceFile::lines})) {
          throw new core::RangeError::•("Line ${line} must be less than the number of lines in the file, ${this.{file3::SourceFile::lines}}.");
        }
        else
          if(column.{core::num::<}(0)) {
            throw new core::RangeError::•("Column may not be negative, was ${column}.");
          }
      core::int result = this.{file3::SourceFile::_lineStarts}.{core::List::[]}(line).{core::num::+}(column);
      if(result.{core::num::>}(this.{file3::SourceFile::length}) || line.{core::num::+}(1).{core::num::<}(this.{file3::SourceFile::lines}) && result.{core::num::>=}(this.{file3::SourceFile::_lineStarts}.{core::List::[]}(line.{core::num::+}(1)))) {
        throw new core::RangeError::•("Line ${line} doesn't have ${column} columns.");
      }
      return result;
    }
    method getText(core::int start, [core::int end = null]) → core::String
      return core::String::fromCharCodes(this.{file3::SourceFile::_decodedChars}.{core::List::sublist}(start, end));
  }
  class FileLocation extends loc::SourceLocationMixin implements loc2::SourceLocation {
    final field file3::SourceFile file;
    final field core::int offset;
    constructor _(file3::SourceFile file, core::int offset) → void
      : file3::FileLocation::file = file, file3::FileLocation::offset = offset, super loc::SourceLocationMixin::•() {
      if(this.{file3::FileLocation::offset}.{core::num::<}(0)) {
        throw new core::RangeError::•("Offset may not be negative, was ${this.{file3::FileLocation::offset}}.");
      }
      else
        if(this.{file3::FileLocation::offset}.{core::num::>}(this.{file3::FileLocation::file}.{file3::SourceFile::length})) {
          throw new core::RangeError::•("Offset ${this.{file3::FileLocation::offset}} must not be greater than the number of characters in the file, ${this.{file3::FileLocation::file}.{file3::SourceFile::length}}.");
        }
    }
    get sourceUrl() → core::Uri
      return this.{file3::FileLocation::file}.{file3::SourceFile::url};
    get line() → core::int
      return this.{file3::FileLocation::file}.{file3::SourceFile::getLine}(this.{file3::FileLocation::offset});
    get column() → core::int
      return this.{file3::FileLocation::file}.{file3::SourceFile::getColumn}(this.{file3::FileLocation::offset});
    method pointSpan() → file3::FileSpan
      return new file3::_FileSpan::•(this.{file3::FileLocation::file}, this.{file3::FileLocation::offset}, this.{file3::FileLocation::offset});
  }
  abstract class FileSpan extends core::Object implements spa4::SourceSpanWithContext {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    abstract get file() → file3::SourceFile;
    abstract get start() → file3::FileLocation;
    abstract get end() → file3::FileLocation;
    abstract method expand(file3::FileSpan other) → file3::FileSpan;
  }
  class _FileSpan extends spa2::SourceSpanMixin implements file3::FileSpan {
    final field file3::SourceFile file;
    final field core::int _start;
    final field core::int _end;
    constructor •(file3::SourceFile file, core::int _start, core::int _end) → void
      : file3::_FileSpan::file = file, file3::_FileSpan::_start = _start, file3::_FileSpan::_end = _end, super spa2::SourceSpanMixin::•() {
      if(this.{file3::_FileSpan::_end}.{core::num::<}(this.{file3::_FileSpan::_start})) {
        throw new core::ArgumentError::•("End ${this.{file3::_FileSpan::_end}} must come after start ${this.{file3::_FileSpan::_start}}.");
      }
      else
        if(this.{file3::_FileSpan::_end}.{core::num::>}(this.{file3::_FileSpan::file}.{file3::SourceFile::length})) {
          throw new core::RangeError::•("End ${this.{file3::_FileSpan::_end}} must not be greater than the number of characters in the file, ${this.{file3::_FileSpan::file}.{file3::SourceFile::length}}.");
        }
        else
          if(this.{file3::_FileSpan::_start}.{core::num::<}(0)) {
            throw new core::RangeError::•("Start may not be negative, was ${this.{file3::_FileSpan::_start}}.");
          }
    }
    get sourceUrl() → core::Uri
      return this.{file3::_FileSpan::file}.{file3::SourceFile::url};
    get length() → core::int
      return this.{file3::_FileSpan::_end}.{core::num::-}(this.{file3::_FileSpan::_start});
    get start() → file3::FileLocation
      return new file3::FileLocation::_(this.{file3::_FileSpan::file}, this.{file3::_FileSpan::_start});
    get end() → file3::FileLocation
      return new file3::FileLocation::_(this.{file3::_FileSpan::file}, this.{file3::_FileSpan::_end});
    get text() → core::String
      return this.{file3::_FileSpan::file}.{file3::SourceFile::getText}(this.{file3::_FileSpan::_start}, this.{file3::_FileSpan::_end});
    get context() → core::String
      return this.{file3::_FileSpan::file}.{file3::SourceFile::getText}(this.{file3::_FileSpan::file}.{file3::SourceFile::getOffset}(this.{file3::_FileSpan::start}.{file3::FileLocation::line}), this.{file3::_FileSpan::end}.{file3::FileLocation::line}.{core::num::==}(this.{file3::_FileSpan::file}.{file3::SourceFile::lines}.{core::num::-}(1)) ?{core::int} null : this.{file3::_FileSpan::file}.{file3::SourceFile::getOffset}(this.{file3::_FileSpan::end}.{file3::FileLocation::line}.{core::num::+}(1)));
    method compareTo(generic-covariant-impl span::SourceSpan other) → core::int {
      if(!(other is file3::_FileSpan))
        return super.{spa2::SourceSpanMixin::compareTo}(other);
      file3::_FileSpan otherFile = other as{TypeError} file3::_FileSpan;
      core::int result = this.{file3::_FileSpan::_start}.{core::num::compareTo}(otherFile.{file3::_FileSpan::_start});
      return result.{core::num::==}(0) ?{core::int} this.{file3::_FileSpan::_end}.{core::num::compareTo}(otherFile.{file3::_FileSpan::_end}) : result;
    }
    method union(span::SourceSpan other) → span::SourceSpan {
      if(!(other is file3::FileSpan))
        return super.{spa2::SourceSpanMixin::union}(other);
      file3::_FileSpan span = this.{file3::_FileSpan::expand}(other as{TypeError} file3::FileSpan) as{TypeError} file3::_FileSpan;
      if(other is file3::_FileSpan) {
        if(this.{file3::_FileSpan::_start}.{core::num::>}(other{file3::_FileSpan}.{file3::_FileSpan::_end}) || other{file3::_FileSpan}.{file3::_FileSpan::_start}.{core::num::>}(this.{file3::_FileSpan::_end})) {
          throw new core::ArgumentError::•("Spans ${this} and ${other{file3::_FileSpan}} are disjoint.");
        }
      }
      else {
        if(this.{file3::_FileSpan::_start}.{core::num::>}(other.{span::SourceSpan::end}.{loc2::SourceLocation::offset}) || other.{span::SourceSpan::start}.{loc2::SourceLocation::offset}.{core::num::>}(this.{file3::_FileSpan::_end})) {
          throw new core::ArgumentError::•("Spans ${this} and ${other} are disjoint.");
        }
      }
      return span;
    }
    operator ==(dynamic other) → core::bool {
      if(!(other is file3::FileSpan))
        return super.{spa2::SourceSpanMixin::==}(other);
      if(!(other is file3::_FileSpan)) {
        return super.{spa2::SourceSpanMixin::==}(other) && this.{file3::_FileSpan::sourceUrl}.{core::Uri::==}(other.sourceUrl);
      }
      return this.{file3::_FileSpan::_start}.{core::num::==}(other._start) && this.{file3::_FileSpan::_end}.{core::num::==}(other._end) && this.{file3::_FileSpan::sourceUrl}.{core::Uri::==}(other.sourceUrl);
    }
    get hashCode() → core::int
      return super.{spa2::SourceSpanMixin::hashCode};
    method expand(file3::FileSpan other) → file3::FileSpan {
      if(!this.{file3::_FileSpan::sourceUrl}.{core::Uri::==}(other.{spa2::SourceSpanMixin::sourceUrl})) {
        throw new core::ArgumentError::•("Source URLs \"${this.{file3::_FileSpan::sourceUrl}}\" and  \"${other.{spa2::SourceSpanMixin::sourceUrl}}\" don't match.");
      }
      if(other is file3::_FileSpan) {
        core::int start = math::min<core::int>(this.{file3::_FileSpan::_start}, other{file3::_FileSpan}.{file3::_FileSpan::_start});
        core::int end = math::max<core::int>(this.{file3::_FileSpan::_end}, other{file3::_FileSpan}.{file3::_FileSpan::_end});
        return new file3::_FileSpan::•(this.{file3::_FileSpan::file}, start, end);
      }
      else {
        core::int start = math::min<core::int>(this.{file3::_FileSpan::_start}, other.{file3::FileSpan::start}.{file3::FileLocation::offset});
        core::int end = math::max<core::int>(this.{file3::_FileSpan::_end}, other.{file3::FileSpan::end}.{file3::FileLocation::offset});
        return new file3::_FileSpan::•(this.{file3::_FileSpan::file}, start, end);
      }
    }
  }
  static const field core::int _LF = 10;
  static const field core::int _CR = 13;
}
library from "package:source_span/src/location.dart" as loc2 {
  import "package:source_span/src/span.dart";
  class SourceLocation extends core::Object implements core::Comparable<loc2::SourceLocation> {
    final field core::Uri sourceUrl;
    final field core::int offset;
    final field core::int line;
    final field core::int column;
    constructor •(core::int offset, {dynamic sourceUrl = null, core::int line = null, core::int column = null}) → void
      : loc2::SourceLocation::sourceUrl = (sourceUrl is core::String ?{dynamic} core::Uri::parse(sourceUrl{core::String}) : sourceUrl) as{TypeError} core::Uri, loc2::SourceLocation::offset = offset, loc2::SourceLocation::line = line.{core::num::==}(null) ?{core::int} 0 : line, loc2::SourceLocation::column = column.{core::num::==}(null) ?{core::int} offset : column, super core::Object::•() {
      if(offset.{core::num::<}(0)) {
        throw new core::RangeError::•("Offset may not be negative, was ${offset}.");
      }
      else
        if(!line.{core::num::==}(null) && line.{core::num::<}(0)) {
          throw new core::RangeError::•("Line may not be negative, was ${line}.");
        }
        else
          if(!column.{core::num::==}(null) && column.{core::num::<}(0)) {
            throw new core::RangeError::•("Column may not be negative, was ${column}.");
          }
    }
    get toolString() → core::String {
      core::Object source = this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(null) ?{core::Object} "unknown source" : this.{loc2::SourceLocation::sourceUrl};
      return "${source}:${this.{loc2::SourceLocation::line}.{core::num::+}(1)}:${this.{loc2::SourceLocation::column}.{core::num::+}(1)}";
    }
    method distance(loc2::SourceLocation other) → core::int {
      if(!this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(other.{loc2::SourceLocation::sourceUrl})) {
        throw new core::ArgumentError::•("Source URLs \"${this.{loc2::SourceLocation::sourceUrl}}\" and \"${other.{loc2::SourceLocation::sourceUrl}}\" don't match.");
      }
      return this.{loc2::SourceLocation::offset}.{core::num::-}(other.{loc2::SourceLocation::offset}).{core::int::abs}();
    }
    method pointSpan() → span::SourceSpan
      return span::SourceSpan::•(this, this, "");
    method compareTo(generic-covariant-impl loc2::SourceLocation other) → core::int {
      if(!this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(other.{loc2::SourceLocation::sourceUrl})) {
        throw new core::ArgumentError::•("Source URLs \"${this.{loc2::SourceLocation::sourceUrl}}\" and \"${other.{loc2::SourceLocation::sourceUrl}}\" don't match.");
      }
      return this.{loc2::SourceLocation::offset}.{core::num::-}(other.{loc2::SourceLocation::offset});
    }
    operator ==(dynamic other) → core::bool
      return other is loc2::SourceLocation && this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(other{loc2::SourceLocation}.{loc2::SourceLocation::sourceUrl}) && this.{loc2::SourceLocation::offset}.{core::num::==}(other{loc2::SourceLocation}.{loc2::SourceLocation::offset});
    get hashCode() → core::int
      return this.{loc2::SourceLocation::sourceUrl}.{core::Uri::hashCode}.{core::num::+}(this.{loc2::SourceLocation::offset});
    method toString() → core::String
      return "<${this.{core::Object::runtimeType}}: ${this.{loc2::SourceLocation::offset}} ${this.{loc2::SourceLocation::toolString}}>";
  }
  class SourceLocationBase extends loc2::SourceLocation {
    constructor •(core::int offset, {dynamic sourceUrl = null, core::int line = null, core::int column = null}) → void
      : super loc2::SourceLocation::•(offset, sourceUrl: sourceUrl, line: line, column: column)
      ;
  }
}
library from "package:source_span/src/location_mixin.dart" as loc {
  import "package:source_span/src/location.dart";
  import "package:source_span/src/span.dart";
  abstract class SourceLocationMixin extends core::Object implements loc2::SourceLocation {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    get toolString() → core::String {
      core::Object source = this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(null) ?{core::Object} "unknown source" : this.{loc2::SourceLocation::sourceUrl};
      return "${source}:${this.{loc2::SourceLocation::line}.{core::num::+}(1)}:${this.{loc2::SourceLocation::column}.{core::num::+}(1)}";
    }
    method distance(loc2::SourceLocation other) → core::int {
      if(!this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(other.{loc2::SourceLocation::sourceUrl})) {
        throw new core::ArgumentError::•("Source URLs \"${this.{loc2::SourceLocation::sourceUrl}}\" and \"${other.{loc2::SourceLocation::sourceUrl}}\" don't match.");
      }
      return this.{loc2::SourceLocation::offset}.{core::num::-}(other.{loc2::SourceLocation::offset}).{core::int::abs}();
    }
    method pointSpan() → span::SourceSpan
      return span::SourceSpan::•(this, this, "");
    method compareTo(generic-covariant-impl loc2::SourceLocation other) → core::int {
      if(!this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(other.{loc2::SourceLocation::sourceUrl})) {
        throw new core::ArgumentError::•("Source URLs \"${this.{loc2::SourceLocation::sourceUrl}}\" and \"${other.{loc2::SourceLocation::sourceUrl}}\" don't match.");
      }
      return this.{loc2::SourceLocation::offset}.{core::num::-}(other.{loc2::SourceLocation::offset});
    }
    operator ==(dynamic other) → core::bool
      return other is loc2::SourceLocation && this.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(other{loc2::SourceLocation}.{loc2::SourceLocation::sourceUrl}) && this.{loc2::SourceLocation::offset}.{core::num::==}(other{loc2::SourceLocation}.{loc2::SourceLocation::offset});
    get hashCode() → core::int
      return this.{loc2::SourceLocation::sourceUrl}.{core::Uri::hashCode}.{core::num::+}(this.{loc2::SourceLocation::offset});
    method toString() → core::String
      return "<${this.{core::Object::runtimeType}}: ${this.{loc2::SourceLocation::offset}} ${this.{loc::SourceLocationMixin::toolString}}>";
  }
}
library from "package:source_span/src/span.dart" as span {
  import "package:source_span/src/location.dart";
  import "package:source_span/src/span_mixin.dart";
  abstract class SourceSpan extends core::Object implements core::Comparable<span::SourceSpan> {
    abstract get start() → loc2::SourceLocation;
    abstract get end() → loc2::SourceLocation;
    abstract get text() → core::String;
    abstract get sourceUrl() → core::Uri;
    abstract get length() → core::int;
    static factory •(loc2::SourceLocation start, loc2::SourceLocation end, core::String text) → span::SourceSpan
      return new span::SourceSpanBase::•(start, end, text);
    abstract method union(span::SourceSpan other) → span::SourceSpan;
    abstract method compareTo(generic-covariant-impl span::SourceSpan other) → core::int;
    abstract method message(core::String message, {dynamic color = null}) → core::String;
    abstract method highlight({dynamic color = null}) → core::String;
  }
  class SourceSpanBase extends spa2::SourceSpanMixin {
    final field loc2::SourceLocation start;
    final field loc2::SourceLocation end;
    final field core::String text;
    constructor •(loc2::SourceLocation start, loc2::SourceLocation end, core::String text) → void
      : span::SourceSpanBase::start = start, span::SourceSpanBase::end = end, span::SourceSpanBase::text = text, super spa2::SourceSpanMixin::•() {
      if(!this.{span::SourceSpanBase::end}.{loc2::SourceLocation::sourceUrl}.{core::Uri::==}(this.{span::SourceSpanBase::start}.{loc2::SourceLocation::sourceUrl})) {
        throw new core::ArgumentError::•("Source URLs \"${this.{span::SourceSpanBase::start}.{loc2::SourceLocation::sourceUrl}}\" and  \"${this.{span::SourceSpanBase::end}.{loc2::SourceLocation::sourceUrl}}\" don't match.");
      }
      else
        if(this.{span::SourceSpanBase::end}.{loc2::SourceLocation::offset}.{core::num::<}(this.{span::SourceSpanBase::start}.{loc2::SourceLocation::offset})) {
          throw new core::ArgumentError::•("End ${this.{span::SourceSpanBase::end}} must come after start ${this.{span::SourceSpanBase::start}}.");
        }
        else
          if(!this.{span::SourceSpanBase::text}.{core::String::length}.{core::num::==}(this.{span::SourceSpanBase::start}.{loc2::SourceLocation::distance}(this.{span::SourceSpanBase::end}))) {
            throw new core::ArgumentError::•("Text \"${this.{span::SourceSpanBase::text}}\" must be ${this.{span::SourceSpanBase::start}.{loc2::SourceLocation::distance}(this.{span::SourceSpanBase::end})} characters long.");
          }
    }
  }
}
library from "package:source_span/src/span_exception.dart" as spa3 {
  import "package:source_span/src/span.dart";
  class SourceSpanException extends core::Object implements core::Exception {
    final field core::String _message;
    final field span::SourceSpan _span;
    constructor •(core::String _message, span::SourceSpan _span) → void
      : spa3::SourceSpanException::_message = _message, spa3::SourceSpanException::_span = _span, super core::Object::•()
      ;
    get message() → core::String
      return this.{spa3::SourceSpanException::_message};
    get span() → span::SourceSpan
      return this.{spa3::SourceSpanException::_span};
    method toString({dynamic color = null}) → core::String {
      if(this.{spa3::SourceSpanException::span}.{core::Object::==}(null))
        return this.{spa3::SourceSpanException::message};
      return "Error on ".{core::String::+}(this.{spa3::SourceSpanException::span}.{span::SourceSpan::message}(this.{spa3::SourceSpanException::message}, color: color));
    }
  }
  class SourceSpanFormatException extends spa3::SourceSpanException implements core::FormatException {
    final field dynamic _source;
    constructor •(core::String message, span::SourceSpan span, [dynamic _source = null]) → void
      : spa3::SourceSpanFormatException::_source = _source, super spa3::SourceSpanException::•(message, span)
      ;
    get source() → dynamic
      return this.{spa3::SourceSpanFormatException::_source};
    get offset() → core::int
      return this.{spa3::SourceSpanException::span}.{core::Object::==}(null) ?{core::int} null : this.{spa3::SourceSpanException::span}.{span::SourceSpan::start}.{loc2::SourceLocation::offset};
  }
}
library from "package:source_span/src/span_mixin.dart" as spa2 {
  import "dart:math" as math;
  import "package:charcode/charcode.dart";
  import "package:path/path.dart" as p;
  import "package:source_span/src/colors.dart" as colors;
  import "package:source_span/src/span.dart";
  import "package:source_span/src/span_with_context.dart";
  import "package:source_span/src/utils.dart";
  abstract class SourceSpanMixin extends core::Object implements span::SourceSpan {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    get sourceUrl() → core::Uri
      return this.{span::SourceSpan::start}.{loc2::SourceLocation::sourceUrl};
    get length() → core::int
      return this.{span::SourceSpan::end}.{loc2::SourceLocation::offset}.{core::num::-}(this.{span::SourceSpan::start}.{loc2::SourceLocation::offset});
    method compareTo(generic-covariant-impl span::SourceSpan other) → core::int {
      core::int result = this.{span::SourceSpan::start}.{loc2::SourceLocation::compareTo}(other.{span::SourceSpan::start});
      return result.{core::num::==}(0) ?{core::int} this.{span::SourceSpan::end}.{loc2::SourceLocation::compareTo}(other.{span::SourceSpan::end}) : result;
    }
    method union(span::SourceSpan other) → span::SourceSpan {
      if(!this.{spa2::SourceSpanMixin::sourceUrl}.{core::Uri::==}(other.{span::SourceSpan::sourceUrl})) {
        throw new core::ArgumentError::•("Source URLs \"${this.{spa2::SourceSpanMixin::sourceUrl}}\" and  \"${other.{span::SourceSpan::sourceUrl}}\" don't match.");
      }
      core::Comparable<dynamic> start = uti6::min(this.{span::SourceSpan::start}, other.{span::SourceSpan::start});
      core::Comparable<dynamic> end = uti6::max(this.{span::SourceSpan::end}, other.{span::SourceSpan::end});
      span::SourceSpan beginSpan = start.{core::Object::==}(this.{span::SourceSpan::start}) ?{span::SourceSpan} this : other;
      span::SourceSpan endSpan = end.{core::Object::==}(this.{span::SourceSpan::end}) ?{span::SourceSpan} this : other;
      if(beginSpan.{span::SourceSpan::end}.{loc2::SourceLocation::compareTo}(endSpan.{span::SourceSpan::start}).{core::num::<}(0)) {
        throw new core::ArgumentError::•("Spans ${this} and ${other} are disjoint.");
      }
      core::String text = beginSpan.{span::SourceSpan::text}.{core::String::+}(endSpan.{span::SourceSpan::text}.{core::String::substring}(beginSpan.{span::SourceSpan::end}.{loc2::SourceLocation::distance}(endSpan.{span::SourceSpan::start})));
      return span::SourceSpan::•(start as{TypeError} loc2::SourceLocation, end as{TypeError} loc2::SourceLocation, text);
    }
    method message(core::String message, {dynamic color = null}) → core::String {
      core::StringBuffer buffer = new core::StringBuffer::•();
      buffer.{core::StringBuffer::write}("line ${this.{span::SourceSpan::start}.{loc2::SourceLocation::line}.{core::num::+}(1)}, column ${this.{span::SourceSpan::start}.{loc2::SourceLocation::column}.{core::num::+}(1)}");
      if(!this.{spa2::SourceSpanMixin::sourceUrl}.{core::Uri::==}(null))
        buffer.{core::StringBuffer::write}(" of ${path::prettyUri(this.{spa2::SourceSpanMixin::sourceUrl})}");
      buffer.{core::StringBuffer::write}(": ${message}");
      core::String highlight = this.{spa2::SourceSpanMixin::highlight}(color: color);
      if(!highlight.{core::String::isEmpty}) {
        buffer.{core::StringBuffer::writeln}();
        buffer.{core::StringBuffer::write}(highlight);
      }
      return buffer.{core::StringBuffer::toString}();
    }
    method highlight({dynamic color = null}) → core::String {
      if(color.{core::Object::==}(true))
        color = col3::RED;
      if(color.{core::Object::==}(false))
        color = null;
      core::int column = this.{span::SourceSpan::start}.{loc2::SourceLocation::column};
      core::StringBuffer buffer = new core::StringBuffer::•();
      core::String textLine;
      if(this is spa4::SourceSpanWithContext) {
        core::String context = (this as spa4::SourceSpanWithContext).{spa4::SourceSpanWithContext::context};
        core::int lineStart = uti6::findLineStart(context, this.{span::SourceSpan::text}, column);
        if(!lineStart.{core::num::==}(null) && lineStart.{core::num::>}(0)) {
          buffer.{core::StringBuffer::write}(context.{core::String::substring}(0, lineStart));
          context = context.{core::String::substring}(lineStart);
        }
        core::int endIndex = context.{core::String::indexOf}("\n");
        textLine = endIndex.{core::num::==}(1.{core::int::unary-}()) ?{core::String} context : context.{core::String::substring}(0, endIndex.{core::num::+}(1));
        column = math::min<core::int>(column, textLine.{core::String::length});
      }
      else
        if(this.{spa2::SourceSpanMixin::length}.{core::num::==}(0)) {
          return "";
        }
        else {
          textLine = this.{span::SourceSpan::text}.{core::String::split}("\n").{core::Iterable::first};
          column = 0;
        }
      core::int toColumn = math::min<core::int>(column.{core::num::+}(this.{span::SourceSpan::end}.{loc2::SourceLocation::offset}).{core::num::-}(this.{span::SourceSpan::start}.{loc2::SourceLocation::offset}), textLine.{core::String::length});
      if(!color.{core::Object::==}(null)) {
        buffer.{core::StringBuffer::write}(textLine.{core::String::substring}(0, column));
        buffer.{core::StringBuffer::write}(color);
        buffer.{core::StringBuffer::write}(textLine.{core::String::substring}(column, toColumn));
        buffer.{core::StringBuffer::write}(col3::NONE);
        buffer.{core::StringBuffer::write}(textLine.{core::String::substring}(toColumn));
      }
      else {
        buffer.{core::StringBuffer::write}(textLine);
      }
      if(!textLine.{core::String::endsWith}("\n"))
        buffer.{core::StringBuffer::write}("\n");
      for (core::int i = 0; i.{core::num::<}(column); i = i.{core::num::+}(1)) {
        if(textLine.{core::String::codeUnitAt}(i).{core::num::==}(dol::$tab)) {
          buffer.{core::StringBuffer::writeCharCode}(dol::$tab);
        }
        else {
          buffer.{core::StringBuffer::writeCharCode}(dol::$space);
        }
      }
      if(!color.{core::Object::==}(null))
        buffer.{core::StringBuffer::write}(color);
      buffer.{core::StringBuffer::write}("^".{core::String::*}(math::max<core::int>(toColumn.{core::num::-}(column), 1)));
      if(!color.{core::Object::==}(null))
        buffer.{core::StringBuffer::write}(col3::NONE);
      return buffer.{core::StringBuffer::toString}();
    }
    operator ==(dynamic other) → core::bool
      return other is span::SourceSpan && this.{span::SourceSpan::start}.{loc2::SourceLocation::==}(other{span::SourceSpan}.{span::SourceSpan::start}) && this.{span::SourceSpan::end}.{loc2::SourceLocation::==}(other{span::SourceSpan}.{span::SourceSpan::end});
    get hashCode() → core::int
      return this.{span::SourceSpan::start}.{loc2::SourceLocation::hashCode}.{core::num::+}(31.{core::num::*}(this.{span::SourceSpan::end}.{loc2::SourceLocation::hashCode}));
    method toString() → core::String
      return "<${this.{core::Object::runtimeType}}: from ${this.{span::SourceSpan::start}} to ${this.{span::SourceSpan::end}} \"${this.{span::SourceSpan::text}}\">";
  }
}
library from "package:source_span/src/span_with_context.dart" as spa4 {
  import "package:source_span/src/location.dart";
  import "package:source_span/src/span.dart";
  import "package:source_span/src/utils.dart";
  class SourceSpanWithContext extends span::SourceSpanBase {
    final field core::String _context;
    constructor •(loc2::SourceLocation start, loc2::SourceLocation end, core::String text, core::String _context) → void
      : spa4::SourceSpanWithContext::_context = _context, super span::SourceSpanBase::•(start, end, text) {
      if(!this.{spa4::SourceSpanWithContext::context}.{core::String::contains}(text)) {
        throw new core::ArgumentError::•("The context line \"${this.{spa4::SourceSpanWithContext::context}}\" must contain \"${text}\".");
      }
      if(uti6::findLineStart(this.{spa4::SourceSpanWithContext::context}, text, start.{loc2::SourceLocation::column}).{core::num::==}(null)) {
        throw new core::ArgumentError::•("The span text \"${text}\" must start at column ${start.{loc2::SourceLocation::column}.{core::num::+}(1)} in a line within \"${this.{spa4::SourceSpanWithContext::context}}\".");
      }
    }
    get context() → core::String
      return this.{spa4::SourceSpanWithContext::_context};
  }
}
library from "package:string_scanner/src/eager_span_scanner.dart" as eag {
  import "package:charcode/ascii.dart";
  import "package:string_scanner/src/line_scanner.dart";
  import "package:string_scanner/src/span_scanner.dart";
  class EagerSpanScanner extends spa::SpanScanner {
    field core::int _line = 0;
    field core::int _column = 0;
    constructor •(core::String string, {dynamic sourceUrl = null, core::int position = null}) → void
      : super spa::SpanScanner::•(string, sourceUrl: sourceUrl, position: position)
      ;
    get line() → core::int
      return this.{eag::EagerSpanScanner::_line};
    get column() → core::int
      return this.{eag::EagerSpanScanner::_column};
    get state() → lin::LineScannerState
      return new eag::_EagerSpanScannerState::•(this, this.{str::StringScanner::position}, this.{eag::EagerSpanScanner::line}, this.{eag::EagerSpanScanner::column});
    get _betweenCRLF() → core::bool
      return this.{str::StringScanner::peekChar}(1.{core::int::unary-}()).{core::num::==}(dol::$cr) && this.{str::StringScanner::peekChar}().{core::num::==}(dol::$lf);
    set state(lin::LineScannerState state) → void {
      if(!(state is eag::_EagerSpanScannerState) || !core::identical((state as eag::_EagerSpanScannerState).{eag::_EagerSpanScannerState::_scanner}, this)) {
        throw new core::ArgumentError::•("The given LineScannerState was not returned by this LineScanner.");
      }
      super.{str::StringScanner::position} = state.{lin::LineScannerState::position};
      this.{eag::EagerSpanScanner::_line} = state.{lin::LineScannerState::line};
      this.{eag::EagerSpanScanner::_column} = state.{lin::LineScannerState::column};
    }
    set position(core::int newPosition) → void {
      core::int oldPosition = this.{str::StringScanner::position};
      super.{str::StringScanner::position} = newPosition;
      if(newPosition.{core::num::>}(oldPosition)) {
        core::List<core::Match> newlines = this.{eag::EagerSpanScanner::_newlinesIn}(this.{str::StringScanner::string}.{core::String::substring}(oldPosition, newPosition));
        this.{eag::EagerSpanScanner::_line} = this.{eag::EagerSpanScanner::_line}.{core::num::+}(newlines.{core::List::length});
        if(newlines.{core::Iterable::isEmpty}) {
          this.{eag::EagerSpanScanner::_column} = this.{eag::EagerSpanScanner::_column}.{core::num::+}(newPosition.{core::num::-}(oldPosition));
        }
        else {
          this.{eag::EagerSpanScanner::_column} = newPosition.{core::num::-}(newlines.{core::Iterable::last}.{core::Match::end});
        }
      }
      else {
        core::List<core::Match> newlines = this.{eag::EagerSpanScanner::_newlinesIn}(this.{str::StringScanner::string}.{core::String::substring}(newPosition, oldPosition));
        if(this.{eag::EagerSpanScanner::_betweenCRLF})
          newlines.{core::List::removeLast}();
        this.{eag::EagerSpanScanner::_line} = this.{eag::EagerSpanScanner::_line}.{core::num::-}(newlines.{core::List::length});
        if(newlines.{core::Iterable::isEmpty}) {
          this.{eag::EagerSpanScanner::_column} = this.{eag::EagerSpanScanner::_column}.{core::num::-}(oldPosition.{core::num::-}(newPosition));
        }
        else {
          this.{eag::EagerSpanScanner::_column} = newPosition.{core::num::-}(this.{str::StringScanner::string}.{core::String::lastIndexOf}(eag::_newlineRegExp, newPosition)).{core::num::-}(1);
        }
      }
    }
    method scanChar(core::int character) → core::bool {
      if(!super.{str::StringScanner::scanChar}(character))
        return false;
      this.{eag::EagerSpanScanner::_adjustLineAndColumn}(character);
      return true;
    }
    method readChar() → core::int {
      core::int character = super.{str::StringScanner::readChar}();
      this.{eag::EagerSpanScanner::_adjustLineAndColumn}(character);
      return character;
    }
    method _adjustLineAndColumn(core::int character) → void {
      if(character.{core::num::==}(dol::$lf) || character.{core::num::==}(dol::$cr) && !this.{str::StringScanner::peekChar}().{core::num::==}(dol::$lf)) {
        this.{eag::EagerSpanScanner::_line} = this.{eag::EagerSpanScanner::_line}.{core::num::+}(1);
        this.{eag::EagerSpanScanner::_column} = 0;
      }
      else {
        this.{eag::EagerSpanScanner::_column} = this.{eag::EagerSpanScanner::_column}.{core::num::+}(1);
      }
    }
    method scan(core::Pattern pattern) → core::bool {
      if(!super.{str::StringScanner::scan}(pattern))
        return false;
      core::List<core::Match> newlines = this.{eag::EagerSpanScanner::_newlinesIn}(this.{str::StringScanner::lastMatch}.{core::Match::[]}(0));
      this.{eag::EagerSpanScanner::_line} = this.{eag::EagerSpanScanner::_line}.{core::num::+}(newlines.{core::List::length});
      if(newlines.{core::Iterable::isEmpty}) {
        this.{eag::EagerSpanScanner::_column} = this.{eag::EagerSpanScanner::_column}.{core::num::+}(this.{str::StringScanner::lastMatch}.{core::Match::[]}(0).{core::String::length});
      }
      else {
        this.{eag::EagerSpanScanner::_column} = this.{str::StringScanner::lastMatch}.{core::Match::[]}(0).{core::String::length}.{core::num::-}(newlines.{core::Iterable::last}.{core::Match::end});
      }
      return true;
    }
    method _newlinesIn(core::String text) → core::List<core::Match> {
      core::List<core::Match> newlines = eag::_newlineRegExp.{core::RegExp::allMatches}(text).{core::Iterable::toList}();
      if(this.{eag::EagerSpanScanner::_betweenCRLF})
        newlines.{core::List::removeLast}();
      return newlines;
    }
  }
  class _EagerSpanScannerState extends core::Object implements lin::LineScannerState {
    final field eag::EagerSpanScanner _scanner;
    final field core::int position;
    final field core::int line;
    final field core::int column;
    constructor •(eag::EagerSpanScanner _scanner, core::int position, core::int line, core::int column) → void
      : eag::_EagerSpanScannerState::_scanner = _scanner, eag::_EagerSpanScannerState::position = position, eag::_EagerSpanScannerState::line = line, eag::_EagerSpanScannerState::column = column, super core::Object::•()
      ;
  }
  static final field core::RegExp _newlineRegExp = core::RegExp::•("\\r\\n?|\\n");
}
library from "package:string_scanner/src/relative_span_scanner.dart" as rel {
  import "package:source_span/source_span.dart";
  import "package:string_scanner/src/exception.dart";
  import "package:string_scanner/src/line_scanner.dart";
  import "package:string_scanner/src/span_scanner.dart";
  import "package:string_scanner/src/string_scanner.dart";
  import "package:string_scanner/src/utils.dart";
  class RelativeSpanScanner extends str::StringScanner implements spa::SpanScanner {
    final field file3::SourceFile _sourceFile;
    final field file3::FileLocation _startLocation;
    field file3::FileSpan _lastSpan = null;
    constructor •(file3::FileSpan span) → void
      : rel::RelativeSpanScanner::_sourceFile = span.{file3::FileSpan::file}, rel::RelativeSpanScanner::_startLocation = span.{file3::FileSpan::start}, super str::StringScanner::•(span.{span::SourceSpanBase::text}, sourceUrl: span.{spa2::SourceSpanMixin::sourceUrl})
      ;
    get line() → core::int
      return this.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::getLine}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(this.{str::StringScanner::position})).{core::num::-}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::line});
    get column() → core::int {
      core::int line = this.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::getLine}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(this.{str::StringScanner::position}));
      core::int column = this.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::getColumn}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(this.{str::StringScanner::position}), line: line);
      return line.{core::num::==}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::line}) ?{core::int} column.{core::num::-}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::column}) : column;
    }
    get state() → lin::LineScannerState
      return new rel::_SpanScannerState::•(this, this.{str::StringScanner::position});
    set state(lin::LineScannerState state) → void {
      if(!(state is rel::_SpanScannerState) || !core::identical((state as rel::_SpanScannerState).{rel::_SpanScannerState::_scanner}, this)) {
        throw new core::ArgumentError::•("The given LineScannerState was not returned by this LineScanner.");
      }
      this.{str::StringScanner::position} = state.{lin::LineScannerState::position};
    }
    get lastSpan() → file3::FileSpan
      return this.{rel::RelativeSpanScanner::_lastSpan};
    get location() → file3::FileLocation
      return this.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::location}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(this.{str::StringScanner::position}));
    get emptySpan() → file3::FileSpan
      return this.{rel::RelativeSpanScanner::location}.{file3::FileLocation::pointSpan}();
    method spanFrom(lin::LineScannerState startState, [lin::LineScannerState endState = null]) → file3::FileSpan {
      core::int endPosition = endState.{core::Object::==}(null) ?{core::int} this.{str::StringScanner::position} : endState.{lin::LineScannerState::position};
      return this.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::span}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(startState.{lin::LineScannerState::position}), this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(endPosition));
    }
    method matches(core::Pattern pattern) → core::bool {
      if(!super.{str::StringScanner::matches}(pattern)) {
        this.{rel::RelativeSpanScanner::_lastSpan} = null;
        return false;
      }
      this.{rel::RelativeSpanScanner::_lastSpan} = this.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::span}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(this.{str::StringScanner::position}), this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(this.{str::StringScanner::lastMatch}.{core::Match::end}));
      return true;
    }
    method error(core::String message, {core::Match match = null, core::int position = null, core::int length = null}) → void {
      uti4::validateErrorArgs(this.{str::StringScanner::string}, match, position, length);
      if(match.{core::Object::==}(null) && position.{core::num::==}(null) && length.{core::num::==}(null))
        match = this.{str::StringScanner::lastMatch};
      if(position.{core::num::==}(null)) {
        position = match.{core::Object::==}(null) ?{core::int} this.{str::StringScanner::position} : match.{core::Match::start};
      }
      if(length.{core::num::==}(null))
        length = match.{core::Object::==}(null) ?{core::int} 1 : match.{core::Match::end}.{core::num::-}(match.{core::Match::start});
      file3::FileSpan span = this.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::span}(this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(position), this.{rel::RelativeSpanScanner::_startLocation}.{file3::FileLocation::offset}.{core::num::+}(position).{core::num::+}(length));
      throw new exc2::StringScannerException::•(message, span, this.{str::StringScanner::string});
    }
  }
  class _SpanScannerState extends core::Object implements lin::LineScannerState {
    final field rel::RelativeSpanScanner _scanner;
    final field core::int position;
    constructor •(rel::RelativeSpanScanner _scanner, core::int position) → void
      : rel::_SpanScannerState::_scanner = _scanner, rel::_SpanScannerState::position = position, super core::Object::•()
      ;
    get line() → core::int
      return this.{rel::_SpanScannerState::_scanner}.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::getLine}(this.{rel::_SpanScannerState::position});
    get column() → core::int
      return this.{rel::_SpanScannerState::_scanner}.{rel::RelativeSpanScanner::_sourceFile}.{file3::SourceFile::getColumn}(this.{rel::_SpanScannerState::position});
  }
}
library from "package:string_scanner/src/utils.dart" as uti4 {
  static method validateErrorArgs(core::String string, core::Match match, core::int position, core::int length) → void {
    if(!match.{core::Object::==}(null) && (!position.{core::num::==}(null) || !length.{core::num::==}(null))) {
      throw new core::ArgumentError::•("Can't pass both match and position/length.");
    }
    if(!position.{core::num::==}(null)) {
      if(position.{core::num::<}(0)) {
        throw new core::RangeError::•("position must be greater than or equal to 0.");
      }
      else
        if(position.{core::num::>}(string.{core::String::length})) {
          throw new core::RangeError::•("position must be less than or equal to the string length.");
        }
    }
    if(!length.{core::num::==}(null) && length.{core::num::<}(0)) {
      throw new core::RangeError::•("length must be greater than or equal to 0.");
    }
    if(!position.{core::num::==}(null) && !length.{core::num::==}(null) && position.{core::num::+}(length).{core::num::>}(string.{core::String::length})) {
      throw new core::RangeError::•("position plus length must not go beyond the end of the string.");
    }
  }
}
library http_server.http_body_impl from "package:http_server/src/http_body_impl.dart" as htt8 {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:mime/mime.dart";
  import "package:http_server/src/http_body.dart";
  import "package:http_server/src/http_multipart_form_data.dart";
  class HttpBodyHandlerTransformer extends asy::StreamTransformerBase<_ht::HttpRequest, htt7::HttpRequestBody> {
    final field con2::Encoding _defaultEncoding;
    const constructor •(con2::Encoding _defaultEncoding) → void
      : htt8::HttpBodyHandlerTransformer::_defaultEncoding = _defaultEncoding, super asy::StreamTransformerBase::•()
      ;
    method bind(generic-covariant-impl asy::Stream<_ht::HttpRequest> stream) → asy::Stream<htt7::HttpRequestBody> {
      return asy::Stream::eventTransformed<htt7::HttpRequestBody>(stream, (asy::EventSink<htt7::HttpRequestBody> sink) → htt8::_HttpBodyHandlerTransformerSink => new htt8::_HttpBodyHandlerTransformerSink::•(this.{htt8::HttpBodyHandlerTransformer::_defaultEncoding}, sink));
    }
  }
  class _HttpBodyHandlerTransformerSink extends core::Object implements asy::EventSink<_ht::HttpRequest> {
    final field con2::Encoding _defaultEncoding;
    final field asy::EventSink<htt7::HttpRequestBody> _outSink;
    field core::int _pending = 0;
    field core::bool _closed = false;
    constructor •(con2::Encoding _defaultEncoding, asy::EventSink<htt7::HttpRequestBody> _outSink) → void
      : htt8::_HttpBodyHandlerTransformerSink::_defaultEncoding = _defaultEncoding, htt8::_HttpBodyHandlerTransformerSink::_outSink = _outSink, super core::Object::•()
      ;
    method add(generic-covariant-impl _ht::HttpRequest request) → void {
      this.{htt8::_HttpBodyHandlerTransformerSink::_pending} = this.{htt8::_HttpBodyHandlerTransformerSink::_pending}.{core::num::+}(1);
      htt8::HttpBodyHandlerImpl::processRequest(request, this.{htt8::_HttpBodyHandlerTransformerSink::_defaultEncoding}).{asy::Future::then}<void>(this.{htt8::_HttpBodyHandlerTransformerSink::_outSink}.{asy::EventSink::add}, onError: this.{htt8::_HttpBodyHandlerTransformerSink::_outSink}.{asy::EventSink::addError}).{asy::Future::whenComplete}(() → core::Null {
        this.{htt8::_HttpBodyHandlerTransformerSink::_pending} = this.{htt8::_HttpBodyHandlerTransformerSink::_pending}.{core::num::-}(1);
        if(this.{htt8::_HttpBodyHandlerTransformerSink::_closed} && this.{htt8::_HttpBodyHandlerTransformerSink::_pending}.{core::num::==}(0))
          this.{htt8::_HttpBodyHandlerTransformerSink::_outSink}.{asy::EventSink::close}();
      });
    }
    method addError(core::Object error, [core::StackTrace stackTrace = null]) → void {
      this.{htt8::_HttpBodyHandlerTransformerSink::_outSink}.{asy::EventSink::addError}(error, stackTrace);
    }
    method close() → void {
      this.{htt8::_HttpBodyHandlerTransformerSink::_closed} = true;
      if(this.{htt8::_HttpBodyHandlerTransformerSink::_pending}.{core::num::==}(0))
        this.{htt8::_HttpBodyHandlerTransformerSink::_outSink}.{asy::EventSink::close}();
    }
  }
  class HttpBodyHandlerImpl extends core::Object {
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    static method processRequest(_ht::HttpRequest request, con2::Encoding defaultEncoding) → asy::Future<htt7::HttpRequestBody> {
      return htt8::HttpBodyHandlerImpl::process(request, request.{_ht::HttpRequest::headers}, defaultEncoding).{asy::Future::then}<htt7::HttpRequestBody>((htt7::HttpBody body) → htt8::_HttpRequestBody => new htt8::_HttpRequestBody::•(request, body), onError: (dynamic error) → core::Null {
        request.{_ht::HttpRequest::response}.{_ht::HttpResponse::statusCode} = _ht::HttpStatus::badRequest;
        request.{_ht::HttpRequest::response}.{io::IOSink::close}();
        throw error;
      });
    }
    static method processResponse(_ht::HttpClientResponse response, con2::Encoding defaultEncoding) → asy::Future<htt7::HttpClientResponseBody> {
      return htt8::HttpBodyHandlerImpl::process(response, response.{_ht::HttpClientResponse::headers}, defaultEncoding).{asy::Future::then}<htt7::HttpClientResponseBody>((htt7::HttpBody body) → htt8::_HttpClientResponseBody => new htt8::_HttpClientResponseBody::•(response, body));
    }
    static method process(asy::Stream<core::List<core::int>> stream, _ht::HttpHeaders headers, con2::Encoding defaultEncoding) → asy::Future<htt7::HttpBody> {
      _ht::ContentType contentType = headers.{_ht::HttpHeaders::contentType};
      function asBinary() → asy::Future<htt7::HttpBody> {
        return stream.{asy::Stream::fold}<dynamic>(io::BytesBuilder::•(), (dynamic builder, core::List<core::int> data) → dynamic => let final dynamic #t668 = builder in let final dynamic #t669 = #t668.add(data) in #t668).{asy::Future::then}<htt7::HttpBody>((dynamic builder) → htt8::_HttpBody => new htt8::_HttpBody::•("binary", builder.takeBytes()));
      }
      function asText(con2::Encoding defaultEncoding) → asy::Future<htt7::HttpBody> {
        con2::Encoding encoding;
        core::String charset = contentType.{_ht::ContentType::charset};
        if(!charset.{core::String::==}(null))
          encoding = con2::Encoding::getByName(charset);
        encoding.{core::Object::==}(null) ?{con2::Encoding} encoding = defaultEncoding : null;
        return stream.{asy::Stream::transform}<core::String>(encoding.{con2::Encoding::decoder}).{asy::Stream::fold}<dynamic>(new core::StringBuffer::•(), (dynamic buffer, core::String data) → dynamic => let final dynamic #t670 = buffer in let final dynamic #t671 = #t670.write(data) in #t670).{asy::Future::then}<htt7::HttpBody>((dynamic buffer) → htt8::_HttpBody => new htt8::_HttpBody::•("text", buffer.{core::Object::toString}()));
      }
      function asFormData() → asy::Future<htt7::HttpBody> {
        return stream.{asy::Stream::transform}<sha::MimeMultipart>(new mul::MimeMultipartTransformer::•(contentType.{_ht::HeaderValue::parameters}.{core::Map::[]}("boundary"))).{asy::Stream::map}<htt4::HttpMultipartFormData>((sha::MimeMultipart part) → htt4::HttpMultipartFormData => htt4::HttpMultipartFormData::parse(part, defaultEncoding: defaultEncoding)).{asy::Stream::map}<asy::Future<core::List<dynamic>>>((htt4::HttpMultipartFormData multipart) → asy::Future<core::List<dynamic>> {
          asy::Future<dynamic> future;
          if(multipart.{htt4::HttpMultipartFormData::isText}) {
            future = multipart.{asy::Stream::fold}<dynamic>(new core::StringBuffer::•(), (dynamic b, dynamic s) → dynamic => let final dynamic #t672 = b in let final dynamic #t673 = #t672.write(s) in #t672).{asy::Future::then}<dynamic>((dynamic b) → core::String => b.{core::Object::toString}());
          }
          else {
            future = multipart.{asy::Stream::fold}<dynamic>(io::BytesBuilder::•(), (dynamic b, dynamic d) → dynamic => let final dynamic #t674 = b in let final dynamic #t675 = #t674.add(d) in #t674).{asy::Future::then}<dynamic>((dynamic b) → dynamic => b.takeBytes());
          }
          return future.{asy::Future::then}<core::List<dynamic>>((dynamic data) → core::List<dynamic> {
            core::String filename = multipart.{htt4::HttpMultipartFormData::contentDisposition}.{_ht::HeaderValue::parameters}.{core::Map::[]}("filename");
            if(!filename.{core::String::==}(null)) {
              data = new htt8::_HttpBodyFileUpload::•(multipart.{htt4::HttpMultipartFormData::contentType}, filename, data);
            }
            return <dynamic>[multipart.{htt4::HttpMultipartFormData::contentDisposition}.{_ht::HeaderValue::parameters}.{core::Map::[]}("name"), data];
          });
        }).{asy::Stream::fold}<dynamic>(<dynamic>[], (dynamic l, asy::Future<core::List<dynamic>> f) → dynamic => let final dynamic #t676 = l in let final dynamic #t677 = #t676.add(f) in #t676).{asy::Future::then}<core::List<dynamic>>((dynamic values) → asy::Future<core::List<dynamic>> => asy::Future::wait<dynamic>(values as core::List<asy::Future<dynamic>>)).{asy::Future::then}<htt7::HttpBody>((core::List<dynamic> parts) → htt8::_HttpBody {
          core::Map<core::String, dynamic> map = <core::String, dynamic>{};
          for (dynamic part in parts) {
            map.{core::Map::[]=}(part.[](0) as core::String, part.[](1));
          }
          return new htt8::_HttpBody::•("form", map);
        });
      }
      if(contentType.{core::Object::==}(null)) {
        return asBinary.call();
      }
      #L116:
      switch(contentType.{_ht::ContentType::primaryType}) {
        #L117:
        case "text":
          {
            return asText.call(defaultEncoding);
          }
        #L118:
        case "application":
          {
            #L119:
            switch(contentType.{_ht::ContentType::subType}) {
              #L120:
              case "json":
                {
                  return asText.call(con2::utf8).{asy::Future::then}<htt7::HttpBody>((htt7::HttpBody body) → htt8::_HttpBody => new htt8::_HttpBody::•("json", con2::jsonDecode(body.{htt7::HttpBody::body} as{TypeError} core::String)));
                }
              #L121:
              case "x-www-form-urlencoded":
                {
                  return asText.call(con2::ascii).{asy::Future::then}<htt7::HttpBody>((htt7::HttpBody body) → htt8::_HttpBody {
                    core::Map<core::String, core::String> map = core::Uri::splitQueryString(body.{htt7::HttpBody::body} as{TypeError} core::String, encoding: defaultEncoding);
                    core::Map<dynamic, dynamic> result = <dynamic, dynamic>{};
                    for (core::String key in map.{core::Map::keys}) {
                      result.{core::Map::[]=}(key, map.{core::Map::[]}(key));
                    }
                    return new htt8::_HttpBody::•("form", result);
                  });
                }
              #L122:
              default:
                {
                  break #L119;
                }
            }
            break #L116;
          }
        #L123:
        case "multipart":
          {
            #L124:
            switch(contentType.{_ht::ContentType::subType}) {
              #L125:
              case "form-data":
                {
                  return asFormData.call();
                }
              #L126:
              default:
                {
                  break #L124;
                }
            }
            break #L116;
          }
        #L127:
        default:
          {
            break #L116;
          }
      }
      return asBinary.call();
    }
  }
  class _HttpBodyFileUpload extends core::Object implements htt7::HttpBodyFileUpload {
    final field _ht::ContentType contentType;
    final field core::String filename;
    final field dynamic content;
    constructor •(_ht::ContentType contentType, core::String filename, dynamic content) → void
      : htt8::_HttpBodyFileUpload::contentType = contentType, htt8::_HttpBodyFileUpload::filename = filename, htt8::_HttpBodyFileUpload::content = content, super core::Object::•()
      ;
  }
  class _HttpBody extends core::Object implements htt7::HttpBody {
    final field core::String type;
    final field dynamic body;
    constructor •(core::String type, dynamic body) → void
      : htt8::_HttpBody::type = type, htt8::_HttpBody::body = body, super core::Object::•()
      ;
  }
  class _HttpRequestBody extends htt8::_HttpBody implements htt7::HttpRequestBody {
    final field _ht::HttpRequest request;
    constructor •(_ht::HttpRequest request, htt7::HttpBody body) → void
      : htt8::_HttpRequestBody::request = request, super htt8::_HttpBody::•(body.{htt7::HttpBody::type}, body.{htt7::HttpBody::body})
      ;
  }
  class _HttpClientResponseBody extends htt8::_HttpBody implements htt7::HttpClientResponseBody {
    final field _ht::HttpClientResponse response;
    constructor •(_ht::HttpClientResponse response, htt7::HttpBody body) → void
      : htt8::_HttpClientResponseBody::response = response, super htt8::_HttpBody::•(body.{htt7::HttpBody::type}, body.{htt7::HttpBody::body})
      ;
  }
}
library http_server.http_multipart_form_data_impl from "package:http_server/src/http_multipart_form_data_impl.dart" as htt9 {
  import "dart:async";
  import "dart:convert";
  import "dart:io";
  import "package:mime/mime.dart";
  import "package:http_server/src/http_multipart_form_data.dart";
  class HttpMultipartFormDataImpl extends asy::Stream<dynamic> implements htt4::HttpMultipartFormData {
    final field _ht::ContentType contentType;
    final field _ht::HeaderValue contentDisposition;
    final field _ht::HeaderValue contentTransferEncoding;
    final field sha::MimeMultipart _mimeMultipart;
    field core::bool _isText = false;
    field asy::Stream<dynamic> _stream = null;
    constructor •(_ht::ContentType contentType, _ht::HeaderValue contentDisposition, _ht::HeaderValue contentTransferEncoding, sha::MimeMultipart _mimeMultipart, con2::Encoding defaultEncoding) → void
      : htt9::HttpMultipartFormDataImpl::contentType = contentType, htt9::HttpMultipartFormDataImpl::contentDisposition = contentDisposition, htt9::HttpMultipartFormDataImpl::contentTransferEncoding = contentTransferEncoding, htt9::HttpMultipartFormDataImpl::_mimeMultipart = _mimeMultipart, super asy::Stream::•() {
      this.{htt9::HttpMultipartFormDataImpl::_stream} = this.{htt9::HttpMultipartFormDataImpl::_mimeMultipart};
      if(!this.{htt9::HttpMultipartFormDataImpl::contentTransferEncoding}.{core::Object::==}(null)) {
        throw new _ht::HttpException::•("Unsupported contentTransferEncoding: ${this.{htt9::HttpMultipartFormDataImpl::contentTransferEncoding}.{_ht::HeaderValue::value}}");
      }
      if(this.{htt9::HttpMultipartFormDataImpl::contentType}.{core::Object::==}(null) || this.{htt9::HttpMultipartFormDataImpl::contentType}.{_ht::ContentType::primaryType}.{core::String::==}("text") || this.{htt9::HttpMultipartFormDataImpl::contentType}.{_ht::ContentType::mimeType}.{core::String::==}("application/json")) {
        this.{htt9::HttpMultipartFormDataImpl::_isText} = true;
        con2::Encoding encoding;
        if(!this.{htt9::HttpMultipartFormDataImpl::contentType}.{core::Object::==}(null) && !this.{htt9::HttpMultipartFormDataImpl::contentType}.{_ht::ContentType::charset}.{core::String::==}(null)) {
          encoding = con2::Encoding::getByName(this.{htt9::HttpMultipartFormDataImpl::contentType}.{_ht::ContentType::charset});
        }
        encoding.{core::Object::==}(null) ?{con2::Encoding} encoding = defaultEncoding : null;
        this.{htt9::HttpMultipartFormDataImpl::_stream} = this.{htt9::HttpMultipartFormDataImpl::_stream}.{asy::Stream::transform}<dynamic>(encoding.{con2::Encoding::decoder});
      }
    }
    get isText() → core::bool
      return this.{htt9::HttpMultipartFormDataImpl::_isText};
    get isBinary() → core::bool
      return !this.{htt9::HttpMultipartFormDataImpl::_isText};
    static method parse(sha::MimeMultipart multipart, con2::Encoding defaultEncoding) → htt4::HttpMultipartFormData {
      _ht::ContentType type;
      _ht::HeaderValue encoding;
      _ht::HeaderValue disposition;
      core::Map<core::String, core::String> remaining = <core::String, core::String>{};
      for (core::String key in multipart.{sha::MimeMultipart::headers}.{core::Map::keys}) {
        #L128:
        switch(key) {
          #L129:
          case "content-type":
            {
              type = _ht::ContentType::parse(multipart.{sha::MimeMultipart::headers}.{core::Map::[]}(key));
              break #L128;
            }
          #L130:
          case "content-transfer-encoding":
            {
              encoding = _ht::HeaderValue::parse(multipart.{sha::MimeMultipart::headers}.{core::Map::[]}(key));
              break #L128;
            }
          #L131:
          case "content-disposition":
            {
              disposition = _ht::HeaderValue::parse(multipart.{sha::MimeMultipart::headers}.{core::Map::[]}(key), preserveBackslash: true);
              break #L128;
            }
          #L132:
          default:
            {
              remaining.{core::Map::[]=}(key, multipart.{sha::MimeMultipart::headers}.{core::Map::[]}(key));
              break #L128;
            }
        }
      }
      if(disposition.{core::Object::==}(null)) {
        throw const _ht::HttpException::•("Mime Multipart doesn't contain a Content-Disposition header value");
      }
      return new htt9::HttpMultipartFormDataImpl::•(type, disposition, encoding, multipart, defaultEncoding);
    }
    method listen((dynamic) → void onData, {() → void onDone = null, core::Function onError = null, core::bool cancelOnError = null}) → asy::StreamSubscription<dynamic> {
      return this.{htt9::HttpMultipartFormDataImpl::_stream}.{asy::Stream::listen}(onData, onDone: onDone, onError: onError, cancelOnError: cancelOnError);
    }
    method value(core::String name) → core::String {
      return this.{htt9::HttpMultipartFormDataImpl::_mimeMultipart}.{sha::MimeMultipart::headers}.{core::Map::[]}(name);
    }
  }
}
library from "package:collection/src/utils.dart" as uti5 {
  class Pair<E extends core::Object = dynamic, F extends core::Object = dynamic> extends core::Object {
    generic-covariant-impl field uti5::Pair::E first;
    generic-covariant-impl field uti5::Pair::F last;
    constructor •(uti5::Pair::E first, uti5::Pair::F last) → void
      : uti5::Pair::first = first, uti5::Pair::last = last, super core::Object::•()
      ;
  }
  static method defaultCompare<T extends core::Object = dynamic>() → (uti5::defaultCompare::T, uti5::defaultCompare::T) → core::int
    return (uti5::defaultCompare::T value1, uti5::defaultCompare::T value2) → core::int => (value1 as core::Comparable<dynamic>).{core::Comparable::compareTo}(value2);
}
library from "package:collection/src/empty_unmodifiable_set.dart" as emp2 {
  import "dart:collection";
  import "package:collection/src/unmodifiable_wrappers.dart";
  class EmptyUnmodifiableSet<E extends core::Object = dynamic> extends col::IterableBase<emp2::EmptyUnmodifiableSet::E> implements unm::UnmodifiableSetView<emp2::EmptyUnmodifiableSet::E> {
    const constructor •() → void
      : super col::IterableBase::•()
      ;
    static method _throw<T extends core::Object = dynamic>() → emp2::EmptyUnmodifiableSet::_throw::T {
      throw new core::UnsupportedError::•("Cannot modify an unmodifiable Set");
    }
    get iterator() → core::Iterator<emp2::EmptyUnmodifiableSet::E>
      return new _in::EmptyIterable::•<emp2::EmptyUnmodifiableSet::E>().{core::Iterable::iterator};
    get length() → core::int
      return 0;
    method cast<T extends core::Object = dynamic>() → emp2::EmptyUnmodifiableSet<emp2::EmptyUnmodifiableSet::cast::T>
      return new emp2::EmptyUnmodifiableSet::•<emp2::EmptyUnmodifiableSet::cast::T>();
    method contains(core::Object element) → core::bool
      return false;
    method containsAll(core::Iterable<core::Object> other) → core::bool
      return other.{core::Iterable::isEmpty};
    method followedBy(generic-covariant-impl core::Iterable<emp2::EmptyUnmodifiableSet::E> other) → core::Iterable<emp2::EmptyUnmodifiableSet::E>
      return col::LinkedHashSet::from<emp2::EmptyUnmodifiableSet::E>(other);
    method lookup(core::Object element) → emp2::EmptyUnmodifiableSet::E
      return null;
    @core::deprecated
    method retype<T extends core::Object = dynamic>() → emp2::EmptyUnmodifiableSet<emp2::EmptyUnmodifiableSet::retype::T>
      return new emp2::EmptyUnmodifiableSet::•<emp2::EmptyUnmodifiableSet::retype::T>();
    method singleWhere((emp2::EmptyUnmodifiableSet::E) → core::bool test, {generic-covariant-impl () → emp2::EmptyUnmodifiableSet::E orElse = null}) → emp2::EmptyUnmodifiableSet::E
      return super.{core::Iterable::singleWhere}(test);
    method whereType<T extends core::Object = dynamic>() → core::Iterable<emp2::EmptyUnmodifiableSet::whereType::T>
      return new emp2::EmptyUnmodifiableSet::•<emp2::EmptyUnmodifiableSet::whereType::T>();
    method toSet() → core::Set<emp2::EmptyUnmodifiableSet::E>
      return col::LinkedHashSet::•<emp2::EmptyUnmodifiableSet::E>();
    method union(generic-covariant-impl core::Set<emp2::EmptyUnmodifiableSet::E> other) → core::Set<emp2::EmptyUnmodifiableSet::E>
      return col::LinkedHashSet::from<emp2::EmptyUnmodifiableSet::E>(other);
    method intersection(core::Set<core::Object> other) → core::Set<emp2::EmptyUnmodifiableSet::E>
      return col::LinkedHashSet::•<emp2::EmptyUnmodifiableSet::E>();
    method difference(core::Set<core::Object> other) → core::Set<emp2::EmptyUnmodifiableSet::E>
      return col::LinkedHashSet::•<emp2::EmptyUnmodifiableSet::E>();
    method add(generic-covariant-impl emp2::EmptyUnmodifiableSet::E value) → core::bool
      return emp2::EmptyUnmodifiableSet::_throw<core::bool>();
    method addAll(generic-covariant-impl core::Iterable<emp2::EmptyUnmodifiableSet::E> elements) → void
      return emp2::EmptyUnmodifiableSet::_throw<void>();
    method clear() → void
      return emp2::EmptyUnmodifiableSet::_throw<void>();
    method remove(core::Object element) → core::bool
      return emp2::EmptyUnmodifiableSet::_throw<core::bool>();
    method removeAll(core::Iterable<core::Object> elements) → void
      return emp2::EmptyUnmodifiableSet::_throw<void>();
    method removeWhere((emp2::EmptyUnmodifiableSet::E) → core::bool test) → void
      return emp2::EmptyUnmodifiableSet::_throw<void>();
    method retainWhere((emp2::EmptyUnmodifiableSet::E) → core::bool test) → void
      return emp2::EmptyUnmodifiableSet::_throw<void>();
    method retainAll(core::Iterable<core::Object> elements) → void
      return emp2::EmptyUnmodifiableSet::_throw<void>();
  }
}
library AES from "package:uuid/aes.dart" as AES {
  class AES extends core::Object {
    static const field core::List<core::int> _sBox = const <core::int>[99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    static const field core::List<core::List<core::int>> _rCon = const <core::List<core::int>>[const <core::int>[0, 0, 0, 0], const <core::int>[1, 0, 0, 0], const <core::int>[2, 0, 0, 0], const <core::int>[4, 0, 0, 0], const <core::int>[8, 0, 0, 0], const <core::int>[16, 0, 0, 0], const <core::int>[32, 0, 0, 0], const <core::int>[64, 0, 0, 0], const <core::int>[128, 0, 0, 0], const <core::int>[27, 0, 0, 0], const <core::int>[54, 0, 0, 0]];
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    static method cipher(core::List<dynamic> input, core::List<dynamic> keySchedule) → core::List<dynamic> {
      core::int blockSize = 4;
      core::int numRounds = keySchedule.{core::List::length}.{core::num::~/}(blockSize).{core::num::-}(1);
      core::List<core::List<core::int>> state = <core::List<core::int>>[core::List::•<core::int>(4), core::List::•<core::int>(4), core::List::•<core::int>(4), core::List::•<core::int>(4)];
      for (core::int i = 0; i.{core::num::<}(4.{core::num::*}(blockSize)); i = i.{core::num::+}(1)) {
        core::int r = i.{core::num::%}(4);
        core::int c = i.{core::num::~/}(4).{core::int::floor}();
        state.{core::List::[]}(r).{core::List::[]=}(c, input.{core::List::[]}(i) as{TypeError} core::int);
      }
      state = AES::AES::_addRoundKey(state, keySchedule, 0, blockSize);
      for (core::int round = 1; round.{core::num::<}(numRounds); round = round.{core::num::+}(1)) {
        state = AES::AES::_subBytes(state, blockSize);
        state = AES::AES::_shiftRows(state, blockSize);
        state = AES::AES::_mixColumns(state, blockSize);
        state = AES::AES::_addRoundKey(state, keySchedule, round, blockSize);
      }
      state = AES::AES::_subBytes(state, blockSize);
      state = AES::AES::_shiftRows(state, blockSize);
      state = AES::AES::_addRoundKey(state, keySchedule, numRounds, blockSize);
      core::List<dynamic> output = core::List::•<dynamic>(4.{core::num::*}(blockSize));
      for (core::int i = 0; i.{core::num::<}(4.{core::num::*}(blockSize)); i = i.{core::num::+}(1)) {
        output.{core::List::[]=}(i, state.{core::List::[]}(i.{core::num::%}(4)).{core::List::[]}(i.{core::num::~/}(4).{core::int::floor}()));
      }
      return output;
    }
    static method keyExpansion(core::List<dynamic> key) → core::List<dynamic> {
      core::int blockSize = 4;
      core::int keyLength = key.{core::List::length}.{core::num::~/}(4);
      core::int numRounds = keyLength.{core::num::+}(6);
      core::List<dynamic> keySchedule = core::List::•<dynamic>(blockSize.{core::num::*}(numRounds.{core::num::+}(1)).{core::num::toInt}());
      core::List<dynamic> temp = core::List::•<dynamic>(4);
      for (core::int i = 0; i.{core::num::<}(keyLength); i = i.{core::num::+}(1)) {
        core::List<dynamic> row = <dynamic>[key.{core::List::[]}(4.{core::num::*}(i)), key.{core::List::[]}(4.{core::num::*}(i).{core::num::+}(1)), key.{core::List::[]}(4.{core::num::*}(i).{core::num::+}(2)), key.{core::List::[]}(4.{core::num::*}(i).{core::num::+}(3))];
        keySchedule.{core::List::[]=}(i, row);
      }
      for (core::int i = keyLength; i.{core::num::<}(blockSize.{core::num::*}(numRounds.{core::num::+}(1))); i = i.{core::num::+}(1)) {
        keySchedule.{core::List::[]=}(i, core::List::•<dynamic>(4));
        for (core::int t = 0; t.{core::num::<}(4); t = t.{core::num::+}(1)) {
          temp.{core::List::[]=}(t, keySchedule.{core::List::[]}(i.{core::num::-}(1)).[](t));
        }
        if(i.{core::num::%}(keyLength).{core::num::==}(0)) {
          temp = AES::AES::_subWord(AES::AES::_rotWord(temp) as{TypeError} core::List<dynamic>) as{TypeError} core::List<dynamic>;
          for (core::int t = 0; t.{core::num::<}(4); t = t.{core::num::+}(1)) {
            let final core::List<dynamic> #t678 = temp in let final core::int #t679 = t in #t678.{core::List::[]=}(#t679, #t678.{core::List::[]}(#t679).^(AES::AES::_rCon.{core::List::[]}(i.{core::num::~/}(keyLength)).{core::List::[]}(t)));
          }
        }
        else
          if(keyLength.{core::num::>}(6) && i.{core::num::%}(keyLength).{core::num::==}(4)) {
            temp = AES::AES::_subWord(temp) as{TypeError} core::List<dynamic>;
          }
        for (core::int t = 0; t.{core::num::<}(4); t = t.{core::num::+}(1)) {
          keySchedule.{core::List::[]}(i).[]=(t, keySchedule.{core::List::[]}(i.{core::num::-}(keyLength)).[](t).^(temp.{core::List::[]}(t)));
        }
      }
      return keySchedule;
    }
    static method _subBytes(core::List<core::List<core::int>> state, core::int blockSize) → core::List<core::List<core::int>> {
      for (core::int row = 0; row.{core::num::<}(4); row = row.{core::num::+}(1)) {
        for (core::int column = 0; column.{core::num::<}(blockSize); column = column.{core::num::+}(1)) {
          state.{core::List::[]}(row).{core::List::[]=}(column, AES::AES::_sBox.{core::List::[]}(state.{core::List::[]}(row).{core::List::[]}(column)));
        }
      }
      return state;
    }
    static method _shiftRows(core::List<core::List<core::int>> state, core::int blockSize) → core::List<core::List<core::int>> {
      core::List<dynamic> temp = core::List::•<dynamic>(4);
      for (core::int row = 1; row.{core::num::<}(4); row = row.{core::num::+}(1)) {
        for (core::int column = 0; column.{core::num::<}(4); column = column.{core::num::+}(1)) {
          temp.{core::List::[]=}(column, state.{core::List::[]}(row).{core::List::[]}(column.{core::num::+}(row).{core::num::%}(blockSize)));
        }
        for (core::int column = 0; column.{core::num::<}(4); column = column.{core::num::+}(1)) {
          state.{core::List::[]}(row).{core::List::[]=}(column, temp.{core::List::[]}(column) as{TypeError} core::int);
        }
      }
      return state;
    }
    static method _mixColumns(core::List<core::List<core::int>> state, core::int blockSize) → core::List<core::List<core::int>> {
      for (core::int column = 0; column.{core::num::<}(4); column = column.{core::num::+}(1)) {
        core::List<dynamic> a = core::List::•<dynamic>(4);
        core::List<dynamic> b = core::List::•<dynamic>(4);
        for (core::int i = 0; i.{core::num::<}(4); i = i.{core::num::+}(1)) {
          a.{core::List::[]=}(i, state.{core::List::[]}(i).{core::List::[]}(column));
          b.{core::List::[]=}(i, !state.{core::List::[]}(i).{core::List::[]}(column).{core::int::&}(128).{core::num::==}(0) ?{core::int} state.{core::List::[]}(i).{core::List::[]}(column).{core::int::<<}(1).{core::int::^}(283) : state.{core::List::[]}(i).{core::List::[]}(column).{core::int::<<}(1));
        }
        state.{core::List::[]}(0).{core::List::[]=}(column, b.{core::List::[]}(0).^(a.{core::List::[]}(1)).^(b.{core::List::[]}(1)).^(a.{core::List::[]}(2)).^(a.{core::List::[]}(3)) as{TypeError} core::int);
        state.{core::List::[]}(1).{core::List::[]=}(column, a.{core::List::[]}(0).^(b.{core::List::[]}(1)).^(a.{core::List::[]}(2)).^(b.{core::List::[]}(2)).^(a.{core::List::[]}(3)) as{TypeError} core::int);
        state.{core::List::[]}(2).{core::List::[]=}(column, a.{core::List::[]}(0).^(a.{core::List::[]}(1)).^(b.{core::List::[]}(2)).^(a.{core::List::[]}(3)).^(b.{core::List::[]}(3)) as{TypeError} core::int);
        state.{core::List::[]}(3).{core::List::[]=}(column, a.{core::List::[]}(0).^(b.{core::List::[]}(0)).^(a.{core::List::[]}(1)).^(a.{core::List::[]}(2)).^(b.{core::List::[]}(3)) as{TypeError} core::int);
      }
      return state;
    }
    static method _addRoundKey(core::List<core::List<core::int>> state, core::List<dynamic> keySchedule, core::int round, core::int blockSize) → core::List<core::List<core::int>> {
      for (core::int row = 0; row.{core::num::<}(4); row = row.{core::num::+}(1)) {
        for (core::int column = 0; column.{core::num::<}(blockSize); column = column.{core::num::+}(1)) {
          let final core::List<core::int> #t680 = state.{core::List::[]}(row) in let final core::int #t681 = column in #t680.{core::List::[]=}(#t681, #t680.{core::List::[]}(#t681).{core::int::^}(keySchedule.{core::List::[]}(round.{core::num::*}(4).{core::num::+}(column)).[](row) as{TypeError} core::int));
        }
      }
      return state;
    }
    static method _subWord(core::List<dynamic> keySchedule) → dynamic {
      for (core::int i = 0; i.{core::num::<}(4); i = i.{core::num::+}(1)) {
        AES::AES::_sBox.{core::List::[]}(keySchedule.{core::List::[]}(i) as{TypeError} core::int);
      }
      return keySchedule;
    }
    static method _rotWord(core::List<dynamic> keySchedule) → dynamic {
      dynamic temp = keySchedule.{core::List::[]}(0);
      for (core::int i = 0; i.{core::num::<}(3); i = i.{core::num::+}(1)) {
        keySchedule.{core::List::[]=}(i, keySchedule.{core::List::[]}(i.{core::num::+}(1)));
      }
      keySchedule.{core::List::[]=}(3, temp);
      return keySchedule;
    }
  }
}
library from "package:crypto/src/digest.dart" as dig {
  import "package:collection/collection.dart";
  import "package:convert/convert.dart";
  class Digest extends core::Object {
    final field core::List<core::int> bytes;
    constructor •(core::List<core::int> bytes) → void
      : dig::Digest::bytes = bytes, super core::Object::•()
      ;
    @core::override
    operator ==(core::Object other) → core::bool
      return other is dig::Digest && const equ::ListEquality::•<dynamic>().{equ::ListEquality::equals}(this.{dig::Digest::bytes}, other{dig::Digest}.{dig::Digest::bytes});
    @core::override
    get hashCode() → core::int
      return const equ::ListEquality::•<dynamic>().{equ::ListEquality::hash}(this.{dig::Digest::bytes});
    @core::override
    method toString() → core::String
      return hex::hex.{con2::Codec::encode}(this.{dig::Digest::bytes});
  }
}
library from "package:crypto/src/hash.dart" as hash {
  import "dart:convert";
  import "package:crypto/src/digest.dart";
  import "package:crypto/src/digest_sink.dart";
  abstract class Hash extends con2::Converter<core::List<core::int>, dig::Digest> {
    const constructor •() → void
      : super con2::Converter::•()
      ;
    abstract get blockSize() → core::int;
    @core::override
    method convert(generic-covariant-impl core::List<core::int> data) → dig::Digest {
      dig2::DigestSink innerSink = new dig2::DigestSink::•();
      con2::ByteConversionSink outerSink = this.{hash::Hash::startChunkedConversion}(innerSink);
      outerSink.{con2::ChunkedConversionSink::add}(data);
      outerSink.{con2::ChunkedConversionSink::close}();
      return innerSink.{dig2::DigestSink::value};
    }
    @core::override
    forwarding-stub forwarding-semi-stub method startChunkedConversion(generic-covariant-impl core::Sink<dig::Digest> sink) → con2::ByteConversionSink
      return super.{con2::Converter::startChunkedConversion}(sink);
  }
}
library from "package:crypto/src/hmac.dart" as hmac {
  import "dart:convert";
  import "dart:typed_data";
  import "package:crypto/src/digest.dart";
  import "package:crypto/src/digest_sink.dart";
  import "package:crypto/src/hash.dart";
  class Hmac extends con2::Converter<core::List<core::int>, dig::Digest> {
    final field hash::Hash _hash;
    final field typ2::Uint8List _key;
    constructor •(hash::Hash hash, core::List<core::int> key) → void
      : hmac::Hmac::_hash = hash, hmac::Hmac::_key = imp::NativeUint8List::•(hash.{hash::Hash::blockSize}), super con2::Converter::•() {
      if(key.{core::List::length}.{core::num::>}(this.{hmac::Hmac::_hash}.{hash::Hash::blockSize}))
        key = this.{hmac::Hmac::_hash}.{hash::Hash::convert}(key).{dig::Digest::bytes};
      this.{hmac::Hmac::_key}.{core::List::setRange}(0, key.{core::List::length}, key);
    }
    @core::override
    method convert(generic-covariant-impl core::List<core::int> data) → dig::Digest {
      dig2::DigestSink innerSink = new dig2::DigestSink::•();
      con2::ByteConversionSink outerSink = this.{hmac::Hmac::startChunkedConversion}(innerSink);
      outerSink.{con2::ChunkedConversionSink::add}(data);
      outerSink.{con2::ChunkedConversionSink::close}();
      return innerSink.{dig2::DigestSink::value};
    }
    @core::override
    method startChunkedConversion(generic-covariant-impl core::Sink<dig::Digest> sink) → con2::ByteConversionSink
      return new hmac::_HmacSink::•(sink, this.{hmac::Hmac::_hash}, this.{hmac::Hmac::_key});
  }
  class _HmacSink extends con2::ByteConversionSink {
    final field con2::ByteConversionSink _outerSink;
    final field dig2::DigestSink _innerResultSink = new dig2::DigestSink::•();
    field con2::ByteConversionSink _innerSink = null;
    field core::bool _isClosed = false;
    constructor •(core::Sink<dig::Digest> sink, hash::Hash hash, core::List<core::int> key) → void
      : hmac::_HmacSink::_outerSink = hash.{hash::Hash::startChunkedConversion}(sink), super con2::ByteConversionSink::•() {
      this.{hmac::_HmacSink::_innerSink} = hash.{hash::Hash::startChunkedConversion}(this.{hmac::_HmacSink::_innerResultSink});
      typ2::Uint8List padding = imp::NativeUint8List::•(key.{core::List::length});
      for (core::int i = 0; i.{core::num::<}(padding.{core::List::length}); i = i.{core::num::+}(1)) {
        padding.{core::List::[]=}(i, 92.{core::int::^}(key.{core::List::[]}(i)));
      }
      this.{hmac::_HmacSink::_outerSink}.{con2::ChunkedConversionSink::add}(padding);
      for (core::int i = 0; i.{core::num::<}(padding.{core::List::length}); i = i.{core::num::+}(1)) {
        padding.{core::List::[]=}(i, 54.{core::int::^}(key.{core::List::[]}(i)));
      }
      this.{hmac::_HmacSink::_innerSink}.{con2::ChunkedConversionSink::add}(padding);
    }
    @core::override
    method add(generic-covariant-impl core::List<core::int> data) → void {
      if(this.{hmac::_HmacSink::_isClosed})
        throw new core::StateError::•("HMAC is closed");
      this.{hmac::_HmacSink::_innerSink}.{con2::ChunkedConversionSink::add}(data);
    }
    @core::override
    method addSlice(core::List<core::int> data, core::int start, core::int end, core::bool isLast) → void {
      if(this.{hmac::_HmacSink::_isClosed})
        throw new core::StateError::•("HMAC is closed");
      this.{hmac::_HmacSink::_innerSink}.{con2::ByteConversionSink::addSlice}(data, start, end, isLast);
    }
    @core::override
    method close() → void {
      if(this.{hmac::_HmacSink::_isClosed})
        return;
      this.{hmac::_HmacSink::_isClosed} = true;
      this.{hmac::_HmacSink::_innerSink}.{con2::ChunkedConversionSink::close}();
      this.{hmac::_HmacSink::_outerSink}.{con2::ChunkedConversionSink::add}(this.{hmac::_HmacSink::_innerResultSink}.{dig2::DigestSink::value}.{dig::Digest::bytes});
      this.{hmac::_HmacSink::_outerSink}.{con2::ChunkedConversionSink::close}();
    }
  }
}
library from "package:crypto/src/md5.dart" as md5 {
  import "dart:convert";
  import "dart:typed_data";
  import "package:crypto/src/digest.dart";
  import "package:crypto/src/hash.dart";
  import "package:crypto/src/hash_sink.dart";
  import "package:crypto/src/utils.dart";
  class MD5 extends hash::Hash {
    @core::override
    final field core::int blockSize = 16.{core::num::*}(uti7::bytesPerWord);
    constructor _() → void
      : super hash::Hash::•()
      ;
    @core::override
    method startChunkedConversion(generic-covariant-impl core::Sink<dig::Digest> sink) → con2::ByteConversionSink
      return new con2::_ByteAdapterSink::•(new md5::_MD5Sink::•(sink));
  }
  class _MD5Sink extends has::HashSink {
    @core::override
    final field typ2::Uint32List digest = imp::NativeUint32List::•(4);
    constructor •(core::Sink<dig::Digest> sink) → void
      : super has::HashSink::•(sink, 16, endian: typ2::Endian::little) {
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(0, 1732584193);
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(1, 4023233417);
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(2, 2562383102);
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(3, 271733878);
    }
    @core::override
    method updateHash(typ2::Uint32List chunk) → void {
      assert(chunk.{core::List::length}.{core::num::==}(16));
      core::int a = this.{md5::_MD5Sink::digest}.{core::List::[]}(0);
      core::int b = this.{md5::_MD5Sink::digest}.{core::List::[]}(1);
      core::int c = this.{md5::_MD5Sink::digest}.{core::List::[]}(2);
      core::int d = this.{md5::_MD5Sink::digest}.{core::List::[]}(3);
      core::int e;
      core::int f;
      for (core::int i = 0; i.{core::num::<}(64); i = i.{core::num::+}(1)) {
        if(i.{core::num::<}(16)) {
          e = b.{core::int::&}(c).{core::int::|}(b.{core::int::~}().{core::int::&}(uti7::mask32).{core::int::&}(d));
          f = i;
        }
        else
          if(i.{core::num::<}(32)) {
            e = d.{core::int::&}(b).{core::int::|}(d.{core::int::~}().{core::int::&}(uti7::mask32).{core::int::&}(c));
            f = 5.{core::num::*}(i).{core::num::+}(1).{core::num::%}(16);
          }
          else
            if(i.{core::num::<}(48)) {
              e = b.{core::int::^}(c).{core::int::^}(d);
              f = 3.{core::num::*}(i).{core::num::+}(5).{core::num::%}(16);
            }
            else {
              e = c.{core::int::^}(b.{core::int::|}(d.{core::int::~}().{core::int::&}(uti7::mask32)));
              f = 7.{core::num::*}(i).{core::num::%}(16);
            }
        core::int temp = d;
        d = c;
        c = b;
        b = uti7::add32(b, uti7::rotl32(uti7::add32(uti7::add32(a, e), uti7::add32(md5::_noise.{core::List::[]}(i), chunk.{core::List::[]}(f))), md5::_shiftAmounts.{core::List::[]}(i)));
        a = temp;
      }
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(0, uti7::add32(a, this.{md5::_MD5Sink::digest}.{core::List::[]}(0)));
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(1, uti7::add32(b, this.{md5::_MD5Sink::digest}.{core::List::[]}(1)));
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(2, uti7::add32(c, this.{md5::_MD5Sink::digest}.{core::List::[]}(2)));
      this.{md5::_MD5Sink::digest}.{core::List::[]=}(3, uti7::add32(d, this.{md5::_MD5Sink::digest}.{core::List::[]}(3)));
    }
  }
  static final field md5::MD5 md5 = new md5::MD5::_();
  static const field core::List<core::int> _noise = const <core::int>[3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745];
  static const field core::List<core::int> _shiftAmounts = const <core::int>[7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21];
}
library from "package:crypto/src/sha1.dart" as sha1 {
  import "dart:convert";
  import "dart:typed_data";
  import "package:crypto/src/digest.dart";
  import "package:crypto/src/hash.dart";
  import "package:crypto/src/hash_sink.dart";
  import "package:crypto/src/utils.dart";
  class Sha1 extends hash::Hash {
    @core::override
    final field core::int blockSize = 16.{core::num::*}(uti7::bytesPerWord);
    constructor _() → void
      : super hash::Hash::•()
      ;
    @core::override
    method startChunkedConversion(generic-covariant-impl core::Sink<dig::Digest> sink) → con2::ByteConversionSink
      return new con2::_ByteAdapterSink::•(new sha1::_Sha1Sink::•(sink));
  }
  class _Sha1Sink extends has::HashSink {
    @core::override
    final field typ2::Uint32List digest = imp::NativeUint32List::•(5);
    final field typ2::Uint32List _extended;
    constructor •(core::Sink<dig::Digest> sink) → void
      : sha1::_Sha1Sink::_extended = imp::NativeUint32List::•(80), super has::HashSink::•(sink, 16) {
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(0, 1732584193);
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(1, 4023233417);
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(2, 2562383102);
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(3, 271733878);
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(4, 3285377520);
    }
    @core::override
    method updateHash(typ2::Uint32List chunk) → void {
      assert(chunk.{core::List::length}.{core::num::==}(16));
      core::int a = this.{sha1::_Sha1Sink::digest}.{core::List::[]}(0);
      core::int b = this.{sha1::_Sha1Sink::digest}.{core::List::[]}(1);
      core::int c = this.{sha1::_Sha1Sink::digest}.{core::List::[]}(2);
      core::int d = this.{sha1::_Sha1Sink::digest}.{core::List::[]}(3);
      core::int e = this.{sha1::_Sha1Sink::digest}.{core::List::[]}(4);
      for (core::int i = 0; i.{core::num::<}(80); i = i.{core::num::+}(1)) {
        if(i.{core::num::<}(16)) {
          this.{sha1::_Sha1Sink::_extended}.{core::List::[]=}(i, chunk.{core::List::[]}(i));
        }
        else {
          this.{sha1::_Sha1Sink::_extended}.{core::List::[]=}(i, uti7::rotl32(this.{sha1::_Sha1Sink::_extended}.{core::List::[]}(i.{core::num::-}(3)).{core::int::^}(this.{sha1::_Sha1Sink::_extended}.{core::List::[]}(i.{core::num::-}(8))).{core::int::^}(this.{sha1::_Sha1Sink::_extended}.{core::List::[]}(i.{core::num::-}(14))).{core::int::^}(this.{sha1::_Sha1Sink::_extended}.{core::List::[]}(i.{core::num::-}(16))), 1));
        }
        core::int newA = uti7::add32(uti7::add32(uti7::rotl32(a, 5), e), this.{sha1::_Sha1Sink::_extended}.{core::List::[]}(i));
        if(i.{core::num::<}(20)) {
          newA = uti7::add32(uti7::add32(newA, b.{core::int::&}(c).{core::int::|}(b.{core::int::~}().{core::int::&}(d))), 1518500249);
        }
        else
          if(i.{core::num::<}(40)) {
            newA = uti7::add32(uti7::add32(newA, b.{core::int::^}(c).{core::int::^}(d)), 1859775393);
          }
          else
            if(i.{core::num::<}(60)) {
              newA = uti7::add32(uti7::add32(newA, b.{core::int::&}(c).{core::int::|}(b.{core::int::&}(d)).{core::int::|}(c.{core::int::&}(d))), 2400959708);
            }
            else {
              newA = uti7::add32(uti7::add32(newA, b.{core::int::^}(c).{core::int::^}(d)), 3395469782);
            }
        e = d;
        d = c;
        c = uti7::rotl32(b, 30);
        b = a;
        a = newA.{core::int::&}(uti7::mask32);
      }
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(0, uti7::add32(a, this.{sha1::_Sha1Sink::digest}.{core::List::[]}(0)));
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(1, uti7::add32(b, this.{sha1::_Sha1Sink::digest}.{core::List::[]}(1)));
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(2, uti7::add32(c, this.{sha1::_Sha1Sink::digest}.{core::List::[]}(2)));
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(3, uti7::add32(d, this.{sha1::_Sha1Sink::digest}.{core::List::[]}(3)));
      this.{sha1::_Sha1Sink::digest}.{core::List::[]=}(4, uti7::add32(e, this.{sha1::_Sha1Sink::digest}.{core::List::[]}(4)));
    }
  }
  static final field sha1::Sha1 sha1 = new sha1::Sha1::_();
}
library from "package:crypto/src/sha256.dart" as sha3 {
  import "dart:convert";
  import "dart:typed_data";
  import "package:crypto/src/digest.dart";
  import "package:crypto/src/hash.dart";
  import "package:crypto/src/hash_sink.dart";
  import "package:crypto/src/utils.dart";
  class Sha256 extends hash::Hash {
    @core::override
    final field core::int blockSize = 16.{core::num::*}(uti7::bytesPerWord);
    constructor _() → void
      : super hash::Hash::•()
      ;
    method newInstance() → sha3::Sha256
      return new sha3::Sha256::_();
    @core::override
    method startChunkedConversion(generic-covariant-impl core::Sink<dig::Digest> sink) → con2::ByteConversionSink
      return new con2::_ByteAdapterSink::•(new sha3::_Sha256Sink::•(sink));
  }
  class _Sha256Sink extends has::HashSink {
    @core::override
    final field typ2::Uint32List digest = imp::NativeUint32List::•(8);
    final field typ2::Uint32List _extended;
    constructor •(core::Sink<dig::Digest> sink) → void
      : sha3::_Sha256Sink::_extended = imp::NativeUint32List::•(64), super has::HashSink::•(sink, 16) {
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(0, 1779033703);
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(1, 3144134277);
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(2, 1013904242);
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(3, 2773480762);
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(4, 1359893119);
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(5, 2600822924);
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(6, 528734635);
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(7, 1541459225);
    }
    method _rotr32(core::int n, core::int x) → core::int
      return x.{core::int::>>}(n).{core::int::|}(x.{core::int::<<}(32.{core::num::-}(n)).{core::int::&}(uti7::mask32));
    method _ch(core::int x, core::int y, core::int z) → core::int
      return x.{core::int::&}(y).{core::int::^}(x.{core::int::~}().{core::int::&}(uti7::mask32).{core::int::&}(z));
    method _maj(core::int x, core::int y, core::int z) → core::int
      return x.{core::int::&}(y).{core::int::^}(x.{core::int::&}(z)).{core::int::^}(y.{core::int::&}(z));
    method _bsig0(core::int x) → core::int
      return this.{sha3::_Sha256Sink::_rotr32}(2, x).{core::int::^}(this.{sha3::_Sha256Sink::_rotr32}(13, x)).{core::int::^}(this.{sha3::_Sha256Sink::_rotr32}(22, x));
    method _bsig1(core::int x) → core::int
      return this.{sha3::_Sha256Sink::_rotr32}(6, x).{core::int::^}(this.{sha3::_Sha256Sink::_rotr32}(11, x)).{core::int::^}(this.{sha3::_Sha256Sink::_rotr32}(25, x));
    method _ssig0(core::int x) → core::int
      return this.{sha3::_Sha256Sink::_rotr32}(7, x).{core::int::^}(this.{sha3::_Sha256Sink::_rotr32}(18, x)).{core::int::^}(x.{core::int::>>}(3));
    method _ssig1(core::int x) → core::int
      return this.{sha3::_Sha256Sink::_rotr32}(17, x).{core::int::^}(this.{sha3::_Sha256Sink::_rotr32}(19, x)).{core::int::^}(x.{core::int::>>}(10));
    @core::override
    method updateHash(typ2::Uint32List chunk) → void {
      assert(chunk.{core::List::length}.{core::num::==}(16));
      for (core::int i = 0; i.{core::num::<}(16); i = i.{core::num::+}(1)) {
        this.{sha3::_Sha256Sink::_extended}.{core::List::[]=}(i, chunk.{core::List::[]}(i));
      }
      for (core::int i = 16; i.{core::num::<}(64); i = i.{core::num::+}(1)) {
        this.{sha3::_Sha256Sink::_extended}.{core::List::[]=}(i, uti7::add32(uti7::add32(this.{sha3::_Sha256Sink::_ssig1}(this.{sha3::_Sha256Sink::_extended}.{core::List::[]}(i.{core::num::-}(2))), this.{sha3::_Sha256Sink::_extended}.{core::List::[]}(i.{core::num::-}(7))), uti7::add32(this.{sha3::_Sha256Sink::_ssig0}(this.{sha3::_Sha256Sink::_extended}.{core::List::[]}(i.{core::num::-}(15))), this.{sha3::_Sha256Sink::_extended}.{core::List::[]}(i.{core::num::-}(16)))));
      }
      core::int a = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(0);
      core::int b = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(1);
      core::int c = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(2);
      core::int d = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(3);
      core::int e = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(4);
      core::int f = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(5);
      core::int g = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(6);
      core::int h = this.{sha3::_Sha256Sink::digest}.{core::List::[]}(7);
      for (core::int i = 0; i.{core::num::<}(64); i = i.{core::num::+}(1)) {
        core::int temp1 = uti7::add32(uti7::add32(h, this.{sha3::_Sha256Sink::_bsig1}(e)), uti7::add32(this.{sha3::_Sha256Sink::_ch}(e, f, g), uti7::add32(sha3::_noise.{core::List::[]}(i), this.{sha3::_Sha256Sink::_extended}.{core::List::[]}(i))));
        core::int temp2 = uti7::add32(this.{sha3::_Sha256Sink::_bsig0}(a), this.{sha3::_Sha256Sink::_maj}(a, b, c));
        h = g;
        g = f;
        f = e;
        e = uti7::add32(d, temp1);
        d = c;
        c = b;
        b = a;
        a = uti7::add32(temp1, temp2);
      }
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(0, uti7::add32(a, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(0)));
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(1, uti7::add32(b, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(1)));
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(2, uti7::add32(c, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(2)));
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(3, uti7::add32(d, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(3)));
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(4, uti7::add32(e, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(4)));
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(5, uti7::add32(f, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(5)));
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(6, uti7::add32(g, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(6)));
      this.{sha3::_Sha256Sink::digest}.{core::List::[]=}(7, uti7::add32(h, this.{sha3::_Sha256Sink::digest}.{core::List::[]}(7)));
    }
  }
  static final field sha3::Sha256 sha256 = new sha3::Sha256::_();
  static const field core::List<core::int> _noise = const <core::int>[1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
}
library from "package:convert/src/accumulator_sink.dart" as acc {
  import "dart:collection";
  class AccumulatorSink<T extends core::Object = dynamic> extends core::Object implements core::Sink<acc::AccumulatorSink::T> {
    final field core::List<acc::AccumulatorSink::T> _events = <acc::AccumulatorSink::T>[];
    field core::bool _isClosed = false;
    synthetic constructor •() → void
      : super core::Object::•()
      ;
    get events() → core::List<acc::AccumulatorSink::T>
      return new col::UnmodifiableListView::•<acc::AccumulatorSink::T>(this.{acc::AccumulatorSink::_events});
    get isClosed() → core::bool
      return this.{acc::AccumulatorSink::_isClosed};
    method clear() → void {
      this.{acc::AccumulatorSink::_events}.{core::List::clear}();
    }
    method add(generic-covariant-impl acc::AccumulatorSink::T event) → void {
      if(this.{acc::AccumulatorSink::_isClosed}) {
        throw new core::StateError::•("Can't add to a closed sink.");
      }
      this.{acc::AccumulatorSink::_events}.{core::List::add}(event);
    }
    method close() → void {
      this.{acc::AccumulatorSink::_isClosed} = true;
    }
  }
}
library from "package:convert/src/byte_accumulator_sink.dart" as byt {
  import "dart:convert";
  import "dart:typed_data";
  import "package:typed_data/typed_data.dart";
  class ByteAccumulatorSink extends con2::ByteConversionSinkBase {
    final field typ3::Uint8Buffer _buffer = new typ3::Uint8Buffer::•();
    field core::bool _isClosed = false;
    synthetic constructor •() → void
      : super con2::ByteConversionSinkBase::•()
      ;
    get bytes() → typ2::Uint8List
      return typ2::Uint8List::view(this.{byt::ByteAccumulatorSink::_buffer}.{typ3::_TypedDataBuffer::buffer}, 0, this.{byt::ByteAccumulatorSink::_buffer}.{typ3::_TypedDataBuffer::length});
    get isClosed() → core::bool
      return this.{byt::ByteAccumulatorSink::_isClosed};
    method clear() → void {
      this.{byt::ByteAccumulatorSink::_buffer}.{col::ListMixin::clear}();
    }
    method add(generic-covariant-impl core::List<core::int> bytes) → void {
      if(this.{byt::ByteAccumulatorSink::_isClosed}) {
        throw new core::StateError::•("Can't add to a closed sink.");
      }
      this.{byt::ByteAccumulatorSink::_buffer}.{typ3::_TypedDataBuffer::addAll}(bytes);
    }
    method addSlice(core::List<core::int> chunk, core::int start, core::int end, core::bool isLast) → void {
      if(this.{byt::ByteAccumulatorSink::_isClosed}) {
        throw new core::StateError::•("Can't add to a closed sink.");
      }
      this.{byt::ByteAccumulatorSink::_buffer}.{typ3::_TypedDataBuffer::addAll}(chunk, start, end);
      if(isLast)
        this.{byt::ByteAccumulatorSink::_isClosed} = true;
    }
    method close() → void {
      this.{byt::ByteAccumulatorSink::_isClosed} = true;
    }
  }
}
library convert.hex from "package:convert/src/hex.dart" as hex {
  import "dart:convert";
  import "package:convert/src/hex/encoder.dart";
  import "package:convert/src/hex/decoder.dart";
  export "package:convert/src/hex/encoder.dart";
  export "package:convert/src/hex/decoder.dart";
  class HexCodec extends con2::Codec<core::List<core::int>, core::String> {
    const constructor _() → void
      : super con2::Codec::•()
      ;
    get encoder() → enc2::HexEncoder
      return enc2::hexEncoder;
    get decoder() → dec2::HexDecoder
      return dec2::hexDecoder;
  }
  static const field hex::HexCodec hex = const hex::HexCodec::_();
}
library convert.percent from "package:convert/src/percent.dart" as per2 {
  import "dart:convert";
  import "package:convert/src/percent/encoder.dart";
  import "package:convert/src/percent/decoder.dart";
  export "package:convert/src/percent/encoder.dart";
  export "package:convert/src/percent/decoder.dart";
  class PercentCodec extends con2::Codec<core::List<core::int>, core::String> {
    const constructor _() → void
      : super con2::Codec::•()
      ;
    get encoder() → enc3::PercentEncoder
      return enc3::percentEncoder;
    get decoder() → dec3::PercentDecoder
      return dec3::percentDecoder;
  }
  static const field per2::PercentCodec percent = const per2::PercentCodec::_();
}
library from "package:convert/src/string_accumulator_sink.dart" as str5 {
  import "dart:convert";
  class StringAccumulatorSink extends con2::StringConversionSinkBase {
    final field core::StringBuffer _buffer = new core::StringBuffer::•();
    field core::bool _isClosed = false;
    synthetic constructor •() → void
      : super con2::StringConversionSinkBase::•()
      ;
    get string() → core::String
      return this.{str5::StringAccumulatorSink::_buffer}.{core::StringBuffer::toString}();
    get isClosed() → core::bool
      return this.{str5::StringAccumulatorSink::_isClosed};
    method clear() → void {
      this.{str5::StringAccumulatorSink::_buffer}.{core::StringBuffer::clear}();
    }
    method add(generic-covariant-impl core::String chunk) → void {
      if(this.{str5::StringAccumulatorSink::_isClosed}) {
        throw new core::StateError::•("Can't add to a closed sink.");
      }
      this.{str5::StringAccumulatorSink::_buffer}.{core::StringBuffer::write}(chunk);
    }
    method addSlice(core::String chunk, core::int start, core::int end, core::bool isLast) → void {
      if(this.{str5::StringAccumulatorSink::_isClosed}) {
        throw new core::StateError::•("Can't add to a closed sink.");
      }
      this.{str5::StringAccumulatorSink::_buffer}.{core::StringBuffer::write}(chunk.{core::String::substring}(start, end));
      if(isLast)
        this.{str5::StringAccumulatorSink::_isClosed} = true;
    }
    method close() → void {
      this.{str5::StringAccumulatorSink::_isClosed} = true;
    }
  }
}
library typed_data.typed_buffers from "package:typed_data/typed_buffers.dart" as typ3 {
  import "dart:collection";
  import "dart:typed_data";
  abstract class _TypedDataBuffer<E extends core::Object = dynamic> extends col::ListBase<typ3::_TypedDataBuffer::E> {
    static const field core::int INITIAL_LENGTH = 8;
    generic-covariant-impl field core::List<typ3::_TypedDataBuffer::E> _buffer;
    field core::int _length;
    constructor •(core::List<typ3::_TypedDataBuffer::E> buffer) → void
      : typ3::_TypedDataBuffer::_buffer = buffer, typ3::_TypedDataBuffer::_length = buffer.{core::List::length}, super col::ListBase::•()
      ;
    get _typedBuffer() → typ2::TypedData
      return this.{typ3::_TypedDataBuffer::_buffer} as typ2::TypedData;
    get length() → core::int
      return this.{typ3::_TypedDataBuffer::_length};
    operator [](core::int index) → typ3::_TypedDataBuffer::E {
      if(index.{core::num::>=}(this.{typ3::_TypedDataBuffer::length}))
        throw new core::IndexError::•(index, this);
      return this.{typ3::_TypedDataBuffer::_buffer}.{core::List::[]}(index);
    }
    operator []=(core::int index, generic-covariant-impl typ3::_TypedDataBuffer::E value) → void {
      if(index.{core::num::>=}(this.{typ3::_TypedDataBuffer::length}))
        throw new core::IndexError::•(index, this);
      this.{typ3::_TypedDataBuffer::_buffer}.{core::List::[]=}(index, value);
    }
    set length(core::int newLength) → void {
      if(newLength.{core::num::<}(this.{typ3::_TypedDataBuffer::_length})) {
        typ3::_TypedDataBuffer::E defaultValue = this.{typ3::_TypedDataBuffer::_defaultValue};
        for (core::int i = newLength; i.{core::num::<}(this.{typ3::_TypedDataBuffer::_length}); i = i.{core::num::+}(1)) {
          this.{typ3::_TypedDataBuffer::_buffer}.{core::List::[]=}(i, defaultValue);
        }
      }
      else
        if(newLength.{core::num::>}(this.{typ3::_TypedDataBuffer::_buffer}.{core::List::length})) {
          core::List<typ3::_TypedDataBuffer::E> newBuffer;
          if(this.{typ3::_TypedDataBuffer::_buffer}.{core::List::length}.{core::num::==}(0)) {
            newBuffer = this.{typ3::_TypedDataBuffer::_createBuffer}(newLength);
          }
          else {
            newBuffer = this.{typ3::_TypedDataBuffer::_createBiggerBuffer}(newLength);
          }
          newBuffer.{core::List::setRange}(0, this.{typ3::_TypedDataBuffer::_length}, this.{typ3::_TypedDataBuffer::_buffer});
          this.{typ3::_TypedDataBuffer::_buffer} = newBuffer;
        }
      this.{typ3::_TypedDataBuffer::_length} = newLength;
    }
    method _add(generic-covariant-impl typ3::_TypedDataBuffer::E value) → void {
      if(this.{typ3::_TypedDataBuffer::_length}.{core::num::==}(this.{typ3::_TypedDataBuffer::_buffer}.{core::List::length}))
        this.{typ3::_TypedDataBuffer::_grow}(this.{typ3::_TypedDataBuffer::_length});
      this.{typ3::_TypedDataBuffer::_buffer}.{core::List::[]=}(let final core::int #t682 = this.{typ3::_TypedDataBuffer::_length} in let final core::int #t683 = this.{typ3::_TypedDataBuffer::_length} = #t682.{core::num::+}(1) in #t682, value);
    }
    method add(generic-covariant-impl typ3::_TypedDataBuffer::E value) → void {
      this.{typ3::_TypedDataBuffer::_add}(value);
    }
    method addAll(generic-covariant-impl core::Iterable<typ3::_TypedDataBuffer::E> values, [core::int start = 0, core::int end = null]) → void {
      core::RangeError::checkNotNegative(start, "start");
      if(!end.{core::num::==}(null) && start.{core::num::>}(end)) {
        throw new core::RangeError::range(end, start, null, "end");
      }
      this.{typ3::_TypedDataBuffer::_addAll}(values, start, end);
    }
    method insertAll(core::int index, generic-covariant-impl core::Iterable<typ3::_TypedDataBuffer::E> values, [core::int start = 0, core::int end = null]) → void {
      core::RangeError::checkValidIndex(index, this, "index", this.{typ3::_TypedDataBuffer::_length}.{core::num::+}(1));
      core::RangeError::checkNotNegative(start, "start");
      if(!end.{core::num::==}(null)) {
        if(start.{core::num::>}(end)) {
          throw new core::RangeError::range(end, start, null, "end");
        }
        if(start.{core::num::==}(end))
          return;
      }
      if(index.{core::num::==}(this.{typ3::_TypedDataBuffer::_length})) {
        this.{typ3::_TypedDataBuffer::_addAll}(values, start, end);
        return;
      }
      if(end.{core::num::==}(null) && values is core::List<dynamic>) {
        end = values.{core::Iterable::length};
      }
      if(!end.{core::num::==}(null)) {
        this.{typ3::_TypedDataBuffer::_insertKnownLength}(index, values, start, end);
        return;
      }
      core::int writeIndex = this.{typ3::_TypedDataBuffer::_length};
      core::int skipCount = start;
      for (typ3::_TypedDataBuffer::E value in values)
        #L133:
        {
          if(skipCount.{core::num::>}(0)) {
            skipCount = skipCount.{core::num::-}(1);
            break #L133;
          }
          if(writeIndex.{core::num::==}(this.{typ3::_TypedDataBuffer::_buffer}.{core::List::length})) {
            this.{typ3::_TypedDataBuffer::_grow}(writeIndex);
          }
          this.{typ3::_TypedDataBuffer::_buffer}.{core::List::[]=}(let final core::int #t684 = writeIndex in let final core::int #t685 = writeIndex = #t684.{core::num::+}(1) in #t684, value);
        }
      if(skipCount.{core::num::>}(0)) {
        throw new core::StateError::•("Too few elements");
      }
      if(!end.{core::num::==}(null) && writeIndex.{core::num::<}(end)) {
        throw new core::RangeError::range(end, start, writeIndex, "end");
      }
      typ3::_TypedDataBuffer::_reverse(this.{typ3::_TypedDataBuffer::_buffer}, index, this.{typ3::_TypedDataBuffer::_length});
      typ3::_TypedDataBuffer::_reverse(this.{typ3::_TypedDataBuffer::_buffer}, this.{typ3::_TypedDataBuffer::_length}, writeIndex);
      typ3::_TypedDataBuffer::_reverse(this.{typ3::_TypedDataBuffer::_buffer}, index, writeIndex);
      this.{typ3::_TypedDataBuffer::_length} = writeIndex;
      return;
    }
    static method _reverse(core::List<dynamic> buffer, core::int start, core::int end) → void {
      end = end.{core::num::-}(1);
      while (start.{core::num::<}(end)) {
        dynamic first = buffer.{core::List::[]}(start);
        dynamic last = buffer.{core::List::[]}(end);
        buffer.{core::List::[]=}(end, first);
        buffer.{core::List::[]=}(start, last);
        start = start.{core::num::+}(1);
        end = end.{core::num::-}(1);
      }
    }
    method _addAll(generic-covariant-impl core::Iterable<typ3::_TypedDataBuffer::E> values, [core::int start = 0, core::int end = null]) → void {
      if(values is core::List<dynamic>)
        end.{core::num::==}(null) ?{core::int} end = values.{core::Iterable::length} : null;
      if(!end.{core::num::==}(null)) {
        this.{typ3::_TypedDataBuffer::_insertKnownLength}(this.{typ3::_TypedDataBuffer::_length}, values, start, end);
        return;
      }
      core::int i = 0;
      for (typ3::_TypedDataBuffer::E value in values) {
        if(i.{core::num::>=}(start))
          this.{typ3::_TypedDataBuffer::add}(value);
        i = i.{core::num::+}(1);
      }
      if(i.{core::num::<}(start))
        throw new core::StateError::•("Too few elements");
    }
    method _insertKnownLength(core::int index, generic-covariant-impl core::Iterable<typ3::_TypedDataBuffer::E> values, core::int start, core::int end) → void {
      if(values is core::List<dynamic>) {
        end.{core::num::==}(null) ?{core::int} end = values.{core::Iterable::length} : null;
        if(start.{core::num::>}(values.{core::Iterable::length}) || end.{core::num::>}(values.{core::Iterable::length})) {
          throw new core::StateError::•("Too few elements");
        }
      }
      else {
        assert(!end.{core::num::==}(null));
      }
      core::int valuesLength = end.{core::num::-}(start);
      core::int newLength = this.{typ3::_TypedDataBuffer::_length}.{core::num::+}(valuesLength);
      this.{typ3::_TypedDataBuffer::_ensureCapacity}(newLength);
      this.{typ3::_TypedDataBuffer::_buffer}.{core::List::setRange}(index.{core::num::+}(valuesLength), this.{typ3::_TypedDataBuffer::_length}.{core::num::+}(valuesLength), this.{typ3::_TypedDataBuffer::_buffer}, index);
      this.{typ3::_TypedDataBuffer::_buffer}.{core::List::setRange}(index, index.{core::num::+}(valuesLength), values, start);
      this.{typ3::_TypedDataBuffer::_length} = newLength;
    }
    method insert(core::int index, generic-covariant-impl typ3::_TypedDataBuffer::E element) → void {
      if(index.{core::num::<}(0) || index.{core::num::>}(this.{typ3::_TypedDataBuffer::_length})) {
        throw new core::RangeError::range(index, 0, this.{typ3::_TypedDataBuffer::_length});
      }
      if(this.{typ3::_TypedDataBuffer::_length}.{core::num::<}(this.{typ3::_TypedDataBuffer::_buffer}.{core::List::length})) {
        this.{typ3::_TypedDataBuffer::_buffer}.{core::List::setRange}(index.{core::num::+}(1), this.{typ3::_TypedDataBuffer::_length}.{core::num::+}(1), this.{typ3::_TypedDataBuffer::_buffer}, index);
        this.{typ3::_TypedDataBuffer::_buffer}.{core::List::[]=}(index, element);
        this.{typ3::_TypedDataBuffer::_length} = this.{typ3::_TypedDataBuffer::_length}.{core::num::+}(1);
        return;
      }
      core::List<typ3::_TypedDataBuffer::E> newBuffer = this.{typ3::_TypedDataBuffer::_createBiggerBuffer}(null);
      newBuffer.{core::List::setRange}(0, index, this.{typ3::_TypedDataBuffer::_buffer});
      newBuffer.{core::List::setRange}(index.{core::num::+}(1), this.{typ3::_TypedDataBuffer::_length}.{core::num::+}(1), this.{typ3::_TypedDataBuffer::_buffer}, index);
      newBuffer.{core::List::[]=}(index, element);
      this.{typ3::_TypedDataBuffer::_length} = this.{typ3::_TypedDataBuffer::_length}.{core::num::+}(1);
      this.{typ3::_TypedDataBuffer::_buffer} = newBuffer;
    }
    method _ensureCapacity(core::int requiredCapacity) → void {
      if(requiredCapacity.{core::num::<=}(this.{typ3::_TypedDataBuffer::_buffer}.{core::List::length}))
        return;
      core::List<typ3::_TypedDataBuffer::E> newBuffer = this.{typ3::_TypedDataBuffer::_createBiggerBuffer}(requiredCapacity);
      newBuffer.{core::List::setRange}(0, this.{typ3::_TypedDataBuffer::_length}, this.{typ3::_TypedDataBuffer::_buffer});
      this.{typ3::_TypedDataBuffer::_buffer} = newBuffer;
    }
    method _createBiggerBuffer(core::int requiredCapacity) → core::List<typ3::_TypedDataBuffer::E> {
      core::int newLength = this.{typ3::_TypedDataBuffer::_buffer}.{core::List::length}.{core::num::*}(2);
      if(!requiredCapacity.{core::num::==}(null) && newLength.{core::num::<}(requiredCapacity)) {
        newLength = requiredCapacity;
      }
      else
        if(newLength.{core::num::<}(typ3::_TypedDataBuffer::INITIAL_LENGTH)) {
          newLength = typ3::_TypedDataBuffer::INITIAL_LENGTH;
        }
      return this.{typ3::_TypedDataBuffer::_createBuffer}(newLength);
    }
    method _grow(core::int length) → void {
      this.{typ3::_TypedDataBuffer::_buffer} = let final core::List<typ3::_TypedDataBuffer::E> #t686 = this.{typ3::_TypedDataBuffer::_createBiggerBuffer}(null) in let final dynamic #t687 = #t686.{core::List::setRange}(0, length, this.{typ3::_TypedDataBuffer::_buffer}) in #t686;
    }
    method setRange(core::int start, core::int end, generic-covariant-impl core::Iterable<typ3::_TypedDataBuffer::E> source, [core::int skipCount = 0]) → void {
      if(end.{core::num::>}(this.{typ3::_TypedDataBuffer::_length}))
        throw new core::RangeError::range(end, 0, this.{typ3::_TypedDataBuffer::_length});
      this.{typ3::_TypedDataBuffer::_setRange}(start, end, source, skipCount);
    }
    method _setRange(core::int start, core::int end, generic-covariant-impl core::Iterable<typ3::_TypedDataBuffer::E> source, core::int skipCount) → void {
      if(source is typ3::_TypedDataBuffer<typ3::_TypedDataBuffer::E>) {
        this.{typ3::_TypedDataBuffer::_buffer}.{core::List::setRange}(start, end, source{typ3::_TypedDataBuffer<typ3::_TypedDataBuffer::E>}.{typ3::_TypedDataBuffer::_buffer}, skipCount);
      }
      else {
        this.{typ3::_TypedDataBuffer::_buffer}.{core::List::setRange}(start, end, source, skipCount);
      }
    }
    get elementSizeInBytes() → core::int
      return this.{typ3::_TypedDataBuffer::_typedBuffer}.{typ2::TypedData::elementSizeInBytes};
    get lengthInBytes() → core::int
      return this.{typ3::_TypedDataBuffer::_length}.{core::num::*}(this.{typ3::_TypedDataBuffer::_typedBuffer}.{typ2::TypedData::elementSizeInBytes});
    get offsetInBytes() → core::int
      return this.{typ3::_TypedDataBuffer::_typedBuffer}.{typ2::TypedData::offsetInBytes};
    get buffer() → typ2::ByteBuffer
      return this.{typ3::_TypedDataBuffer::_typedBuffer}.{typ2::TypedData::buffer};
    abstract get _defaultValue() → typ3::_TypedDataBuffer::E;
    abstract method _createBuffer(core::int size) → core::List<typ3::_TypedDataBuffer::E>;
  }
  abstract class _IntBuffer extends typ3::_TypedDataBuffer<core::int> {
    constructor •(core::List<core::int> buffer) → void
      : super typ3::_TypedDataBuffer::•(buffer)
      ;
    get _defaultValue() → core::int
      return 0;
  }
  abstract class _FloatBuffer extends typ3::_TypedDataBuffer<core::double> {
    constructor •(core::List<core::double> buffer) → void
      : super typ3::_TypedDataBuffer::•(buffer)
      ;
    get _defaultValue() → core::double
      return 0.0;
  }
  class Uint8Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(imp::NativeUint8List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Uint8List
      return imp::NativeUint8List::•(size);
  }
  class Int8Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(imp::NativeInt8List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Int8List
      return imp::NativeInt8List::•(size);
  }
  class Uint8ClampedBuffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(imp::NativeUint8ClampedList::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Uint8ClampedList
      return imp::NativeUint8ClampedList::•(size);
  }
  class Uint16Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(imp::NativeUint16List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Uint16List
      return imp::NativeUint16List::•(size);
  }
  class Int16Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(imp::NativeInt16List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Int16List
      return imp::NativeInt16List::•(size);
  }
  class Uint32Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(imp::NativeUint32List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Uint32List
      return imp::NativeUint32List::•(size);
  }
  class Int32Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(imp::NativeInt32List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Int32List
      return imp::NativeInt32List::•(size);
  }
  class Uint64Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(typ2::Uint64List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Uint64List
      return typ2::Uint64List::•(size);
  }
  class Int64Buffer extends typ3::_IntBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_IntBuffer::•(typ2::Int64List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Int64List
      return typ2::Int64List::•(size);
  }
  class Float32Buffer extends typ3::_FloatBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_FloatBuffer::•(imp::NativeFloat32List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Float32List
      return imp::NativeFloat32List::•(size);
  }
  class Float64Buffer extends typ3::_FloatBuffer {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_FloatBuffer::•(imp::NativeFloat64List::•(initialLength))
      ;
    method _createBuffer(core::int size) → typ2::Float64List
      return imp::NativeFloat64List::•(size);
  }
  class Int32x4Buffer extends typ3::_TypedDataBuffer<typ2::Int32x4> {
    static field typ2::Int32x4 _zero = new imp::NativeInt32x4::•(0, 0, 0, 0);
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_TypedDataBuffer::•(new imp::NativeInt32x4List::•(initialLength))
      ;
    get _defaultValue() → typ2::Int32x4
      return typ3::Int32x4Buffer::_zero;
    method _createBuffer(core::int size) → typ2::Int32x4List
      return new imp::NativeInt32x4List::•(size);
  }
  class Float32x4Buffer extends typ3::_TypedDataBuffer<typ2::Float32x4> {
    constructor •([core::int initialLength = 0]) → void
      : super typ3::_TypedDataBuffer::•(new imp::NativeFloat32x4List::•(initialLength))
      ;
    get _defaultValue() → typ2::Float32x4
      return new imp::NativeFloat32x4::zero();
    method _createBuffer(core::int size) → typ2::Float32x4List
      return new imp::NativeFloat32x4List::•(size);
  }
}
library from "package:matcher/src/feature_matcher.dart" as fea {
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/type_matcher.dart";
  abstract class FeatureMatcher<T extends core::Object = dynamic> extends typ5::TypeMatcher<fea::FeatureMatcher::T> {
    const constructor •() → void
      : super typ5::TypeMatcher::•()
      ;
    method matches(core::Object item, core::Map<dynamic, dynamic> matchState) → core::bool
      return super.{typ5::TypeMatcher::matches}(item, matchState) && this.{fea::FeatureMatcher::typedMatches}(item as{TypeError} fea::FeatureMatcher::T, matchState);
    abstract method typedMatches(generic-covariant-impl fea::FeatureMatcher::T item, core::Map<dynamic, dynamic> matchState) → core::bool;
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      if(item is fea::FeatureMatcher::T) {
        return this.{fea::FeatureMatcher::describeTypedMismatch}(item{fea::FeatureMatcher::T}, mismatchDescription, matchState, verbose);
      }
      return super.{typ5::TypeMatcher::describe}(mismatchDescription.{int3::Description::add}("not an "));
    }
    method describeTypedMismatch(generic-covariant-impl fea::FeatureMatcher::T item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description
      return mismatchDescription;
  }
}
library from "package:matcher/src/pretty_print.dart" as pre {
  import "package:matcher/src/description.dart";
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/util.dart";
  static method prettyPrint(dynamic object, {core::int maxLineLength = null, core::int maxItems = null}) → core::String {
    function _prettyPrint(dynamic object, core::int indent, core::Set<dynamic> seen, core::bool top) → core::String {
      if(object is int3::Matcher) {
        des::StringDescription description = new des::StringDescription::•();
        object{int3::Matcher}.{int3::Matcher::describe}(description);
        return "<${description}>";
      }
      if(seen.{core::Set::contains}(object))
        return "(recursive)";
      seen = seen.{core::Set::union}(col::LinkedHashSet::from<dynamic>(<dynamic>[object]));
      function pp(dynamic child) → core::String
        return _prettyPrint.call(child, indent.{core::num::+}(2), seen, false);
      if(object is core::Iterable<dynamic>) {
        core::String type = object{core::Iterable<dynamic>} is core::List<dynamic> ?{core::String} "" : pre::_typeName(object{core::Iterable<dynamic>}).{core::String::+}(":");
        core::List<core::String> strings = object{core::Iterable<dynamic>}.{core::Iterable::map}<core::String>(pp).{core::Iterable::toList}();
        if(!maxItems.{core::num::==}(null) && strings.{core::List::length}.{core::num::>}(maxItems)) {
          strings.{core::List::replaceRange}(maxItems.{core::num::-}(1), strings.{core::List::length}, <core::String>["..."]);
        }
        core::String singleLine = "${type}[${strings.{core::Iterable::join}(", ")}]";
        if((maxLineLength.{core::num::==}(null) || singleLine.{core::String::length}.{core::num::+}(indent).{core::num::<=}(maxLineLength)) && !singleLine.{core::String::contains}("\n")) {
          return singleLine;
        }
        return "${type}[\n".{core::String::+}(strings.{core::Iterable::map}<core::String>((core::String string) → core::String {
          return pre::_indent(indent.{core::num::+}(2)).{core::String::+}(string);
        }).{core::Iterable::join}(",\n")).{core::String::+}("\n").{core::String::+}(pre::_indent(indent)).{core::String::+}("]");
      }
      else
        if(object is core::Map<dynamic, dynamic>) {
          core::List<core::String> strings = object{core::Map<dynamic, dynamic>}.{core::Map::keys}.{core::Iterable::map}<core::String>((dynamic key) → core::String {
            return "${pp.call(key)}: ${pp.call(object{core::Map<dynamic, dynamic>}.{core::Map::[]}(key))}";
          }).{core::Iterable::toList}();
          if(!maxItems.{core::num::==}(null) && strings.{core::List::length}.{core::num::>}(maxItems)) {
            strings.{core::List::replaceRange}(maxItems.{core::num::-}(1), strings.{core::List::length}, <core::String>["..."]);
          }
          core::String singleLine = "{${strings.{core::Iterable::join}(", ")}}";
          if((maxLineLength.{core::num::==}(null) || singleLine.{core::String::length}.{core::num::+}(indent).{core::num::<=}(maxLineLength)) && !singleLine.{core::String::contains}("\n")) {
            return singleLine;
          }
          return "{\n".{core::String::+}(strings.{core::Iterable::map}<core::String>((core::String string) → core::String {
            return pre::_indent(indent.{core::num::+}(2)).{core::String::+}(string);
          }).{core::Iterable::join}(",\n")).{core::String::+}("\n").{core::String::+}(pre::_indent(indent)).{core::String::+}("}");
        }
        else
          if(object is core::String) {
            core::List<core::String> lines = object{core::String}.{core::String::split}("\n");
            return "'".{core::String::+}(lines.{core::Iterable::map}<core::String>(pre::_escapeString).{core::Iterable::join}("\\n'\n${pre::_indent(indent.{core::num::+}(2))}'")).{core::String::+}("'");
          }
          else {
            core::String value = object.{core::Object::toString}().{core::String::replaceAll}("\n", pre::_indent(indent).{core::String::+}("\n"));
            core::bool defaultToString = value.{core::String::startsWith}("Instance of ");
            if(top)
              value = "<${value}>";
            if(object is core::num || object is core::bool || object is core::Function || object.{core::Object::==}(null) || defaultToString) {
              return value;
            }
            else {
              return "${pre::_typeName(object)}:${value}";
            }
          }
    }
    return _prettyPrint.call(object, 0, col::LinkedHashSet::•<dynamic>(), true);
  }
  static method _indent(core::int length) → core::String
    return core::List::filled<core::String>(length, " ").{core::Iterable::join}("");
  static method _typeName(dynamic x) → core::String {
    try {
      if(x.{core::Object::==}(null))
        return "null";
      if(x is core::Type)
        return "Type";
      core::String type = x.{core::Object::runtimeType}.{core::Object::toString}();
      return type.{core::String::startsWith}("_") ?{core::String} "?" : type;
    }
    on dynamic catch(final dynamic e) {
      return "?";
    }
  }
  static method _escapeString(core::String source) → core::String
    return util2::escape(source).{core::String::replaceAll}("'", "\\'");
}
library from "package:matcher/src/having_matcher.dart" as hav {
  import "package:matcher/src/custom_matcher.dart";
  import "package:matcher/src/interfaces.dart";
  import "package:matcher/src/type_matcher.dart";
  import "package:matcher/src/util.dart";
  class HavingMatcher<T extends core::Object = dynamic> extends core::Object implements typ5::TypeMatcher<hav::HavingMatcher::T> {
    final field typ5::TypeMatcher<hav::HavingMatcher::T> _parent;
    final field core::List<hav::_FunctionMatcher<dynamic>> _functionMatchers;
    constructor •(typ5::TypeMatcher<hav::HavingMatcher::T> parent, core::String description, (hav::HavingMatcher::T) → core::Object feature, core::Object matcher, [core::Iterable<hav::_FunctionMatcher<dynamic>> existing = null]) → void
      : hav::HavingMatcher::_parent = parent, hav::HavingMatcher::_functionMatchers = let final core::List<hav::_FunctionMatcher<dynamic>> #t688 = <hav::_FunctionMatcher<dynamic>>[] in let final dynamic #t689 = #t688.{core::List::addAll}(let final core::Iterable<hav::_FunctionMatcher<dynamic>> #t690 = existing in #t690.==(null) ?{core::Iterable<hav::_FunctionMatcher<dynamic>>} <hav::_FunctionMatcher<dynamic>>[] : #t690) in let final dynamic #t691 = #t688.{core::List::add}(new hav::_FunctionMatcher::•<hav::HavingMatcher::T>(description, feature, matcher)) in #t688, super core::Object::•()
      ;
    method having((hav::HavingMatcher::T) → core::Object feature, core::String description, core::Object matcher) → typ5::TypeMatcher<hav::HavingMatcher::T>
      return new hav::HavingMatcher::•<hav::HavingMatcher::T>(this.{hav::HavingMatcher::_parent}, description, feature, matcher, this.{hav::HavingMatcher::_functionMatchers});
    method matches(core::Object item, core::Map<dynamic, dynamic> matchState) → core::bool {
      for (int3::Matcher matcher in <int3::Matcher>[this.{hav::HavingMatcher::_parent}].{core::Iterable::followedBy}(this.{hav::HavingMatcher::_functionMatchers})) {
        if(!matcher.{int3::Matcher::matches}(item, matchState)) {
          util2::addStateInfo(matchState, <dynamic, dynamic>{"matcher": matcher});
          return false;
        }
      }
      return true;
    }
    method describeMismatch(dynamic item, int3::Description mismatchDescription, core::Map<dynamic, dynamic> matchState, core::bool verbose) → int3::Description {
      int3::Matcher matcher = matchState.{core::Map::[]}("matcher") as int3::Matcher;
      matcher.{int3::Matcher::describeMismatch}(item, mismatchDescription, matchState.{core::Map::[]}("state") as core::Map<dynamic, dynamic>, verbose);
      return mismatchDescription;
    }
    method describe(int3::Description description) → int3::Description
      return description.{int3::Description::add}("").{int3::Description::addDescriptionOf}(this.{hav::HavingMatcher::_parent}).{int3::Description::add}(" with ").{int3::Description::addAll}("", " and ", "", this.{hav::HavingMatcher::_functionMatchers});
  }
  class _FunctionMatcher<T extends core::Object = dynamic> extends cus::CustomMatcher {
    final field (hav::_FunctionMatcher::T) → dynamic _feature;
    constructor •(core::String name, (hav::_FunctionMatcher::T) → dynamic _feature, dynamic matcher) → void
      : hav::_FunctionMatcher::_feature = _feature, super cus::CustomMatcher::•("`${name}`:", "`${name}`", matcher)
      ;
    @core::override
    method featureValueOf(covariant generic-covariant-impl hav::_FunctionMatcher::T actual) → core::Object
      return this.{hav::_FunctionMatcher::_feature}(actual);
  }
}
library from "package:source_span/src/colors.dart" as col3 {
  static const field core::String RED = "\u0027[31m";
  static const field core::String YELLOW = "\u0027[33m";
  static const field core::String NONE = "\u0027[0m";
}
library from "package:source_span/src/utils.dart" as uti6 {
  static method min(core::Comparable<dynamic> obj1, core::Comparable<dynamic> obj2) → core::Comparable<dynamic>
    return obj1.{core::Comparable::compareTo}(obj2).{core::num::>}(0) ?{core::Comparable<dynamic>} obj2 : obj1;
  static method max(core::Comparable<dynamic> obj1, core::Comparable<dynamic> obj2) → core::Comparable<dynamic>
    return obj1.{core::Comparable::compareTo}(obj2).{core::num::>}(0) ?{core::Comparable<dynamic>} obj1 : obj2;
  static method findLineStart(core::String context, core::String text, core::int column) → core::int {
    core::bool isEmpty = text.{core::String::==}("");
    core::int index = context.{core::String::indexOf}(text);
    while (!index.{core::num::==}(1.{core::int::unary-}())) {
      core::int lineStart = context.{core::String::lastIndexOf}("\n", index).{core::num::+}(1);
      core::int textColumn = index.{core::num::-}(lineStart);
      if(column.{core::num::==}(textColumn) || isEmpty && column.{core::num::==}(textColumn.{core::num::+}(1))) {
        return lineStart;
      }
      index = context.{core::String::indexOf}(text, index.{core::num::+}(1));
    }
    return null;
  }
}
library from "package:crypto/src/digest_sink.dart" as dig2 {
  import "package:crypto/src/digest.dart";
  class DigestSink extends core::Sink<dig::Digest> {
    field dig::Digest _value = null;
    synthetic constructor •() → void
      : super core::Sink::•()
      ;
    get value() → dig::Digest {
      assert(!this.{dig2::DigestSink::_value}.{dig::Digest::==}(null));
      return this.{dig2::DigestSink::_value};
    }
    @core::override
    method add(generic-covariant-impl dig::Digest value) → void {
      assert(this.{dig2::DigestSink::_value}.{dig::Digest::==}(null));
      this.{dig2::DigestSink::_value} = value;
    }
    @core::override
    method close() → void {
      assert(!this.{dig2::DigestSink::_value}.{dig::Digest::==}(null));
    }
  }
}
library from "package:crypto/src/hash_sink.dart" as has {
  import "dart:typed_data";
  import "package:typed_data/typed_data.dart";
  import "package:crypto/src/digest.dart";
  import "package:crypto/src/utils.dart";
  abstract class HashSink extends core::Object implements core::Sink<core::List<core::int>> {
    final field core::Sink<dig::Digest> _sink;
    final field typ2::Endian _endian;
    final field typ2::Uint32List _currentChunk;
    static const field core::int _maxMessageLengthInBytes = 1125899906842623;
    field core::int _lengthInBytes = 0;
    final field typ3::Uint8Buffer _pendingData = new typ3::Uint8Buffer::•();
    field core::bool _isClosed = false;
    constructor •(core::Sink<dig::Digest> _sink, core::int chunkSizeInWords, {typ2::Endian endian = typ2::Endian::big}) → void
      : has::HashSink::_sink = _sink, has::HashSink::_endian = endian, has::HashSink::_currentChunk = imp::NativeUint32List::•(chunkSizeInWords), super core::Object::•()
      ;
    abstract get digest() → typ2::Uint32List;
    abstract method updateHash(typ2::Uint32List chunk) → void;
    @core::override
    method add(generic-covariant-impl core::List<core::int> data) → void {
      if(this.{has::HashSink::_isClosed})
        throw new core::StateError::•("Hash.add() called after close().");
      this.{has::HashSink::_lengthInBytes} = this.{has::HashSink::_lengthInBytes}.{core::num::+}(data.{core::List::length});
      this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::addAll}(data);
      this.{has::HashSink::_iterate}();
    }
    @core::override
    method close() → void {
      if(this.{has::HashSink::_isClosed})
        return;
      this.{has::HashSink::_isClosed} = true;
      this.{has::HashSink::_finalizeData}();
      this.{has::HashSink::_iterate}();
      assert(this.{has::HashSink::_pendingData}.{col::ListMixin::isEmpty});
      this.{has::HashSink::_sink}.{core::Sink::add}(new dig::Digest::•(this.{has::HashSink::_byteDigest}()));
      this.{has::HashSink::_sink}.{core::Sink::close}();
    }
    method _byteDigest() → typ2::Uint8List {
      if(this.{has::HashSink::_endian}.{core::Object::==}(typ2::Endian::host))
        return this.{has::HashSink::digest}.{typ2::TypedData::buffer}.{typ2::ByteBuffer::asUint8List}();
      typ2::Uint8List byteDigest = imp::NativeUint8List::•(this.{has::HashSink::digest}.{typ2::TypedData::lengthInBytes});
      typ2::ByteData byteData = byteDigest.{typ2::TypedData::buffer}.{typ2::ByteBuffer::asByteData}();
      for (core::int i = 0; i.{core::num::<}(this.{has::HashSink::digest}.{core::List::length}); i = i.{core::num::+}(1)) {
        byteData.{typ2::ByteData::setUint32}(i.{core::num::*}(uti7::bytesPerWord), this.{has::HashSink::digest}.{core::List::[]}(i));
      }
      return byteDigest;
    }
    method _iterate() → void {
      typ2::ByteData pendingDataBytes = this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::buffer}.{typ2::ByteBuffer::asByteData}();
      core::int pendingDataChunks = this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::length}.{core::num::~/}(this.{has::HashSink::_currentChunk}.{typ2::TypedData::lengthInBytes});
      for (core::int i = 0; i.{core::num::<}(pendingDataChunks); i = i.{core::num::+}(1)) {
        for (core::int j = 0; j.{core::num::<}(this.{has::HashSink::_currentChunk}.{core::List::length}); j = j.{core::num::+}(1)) {
          this.{has::HashSink::_currentChunk}.{core::List::[]=}(j, pendingDataBytes.{typ2::ByteData::getUint32}(i.{core::num::*}(this.{has::HashSink::_currentChunk}.{typ2::TypedData::lengthInBytes}).{core::num::+}(j.{core::num::*}(uti7::bytesPerWord)), this.{has::HashSink::_endian}));
        }
        this.{has::HashSink::updateHash}(this.{has::HashSink::_currentChunk});
      }
      this.{has::HashSink::_pendingData}.{col::ListMixin::removeRange}(0, pendingDataChunks.{core::num::*}(this.{has::HashSink::_currentChunk}.{typ2::TypedData::lengthInBytes}));
    }
    method _finalizeData() → void {
      this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::add}(128);
      core::int contentsLength = this.{has::HashSink::_lengthInBytes}.{core::num::+}(9);
      core::int finalizedLength = this.{has::HashSink::_roundUp}(contentsLength, this.{has::HashSink::_currentChunk}.{typ2::TypedData::lengthInBytes});
      for (core::int i = 0; i.{core::num::<}(finalizedLength.{core::num::-}(contentsLength)); i = i.{core::num::+}(1)) {
        this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::add}(0);
      }
      if(this.{has::HashSink::_lengthInBytes}.{core::num::>}(has::HashSink::_maxMessageLengthInBytes)) {
        throw new core::UnsupportedError::•("Hashing is unsupported for messages with more than 2^53 bits.");
      }
      core::int lengthInBits = this.{has::HashSink::_lengthInBytes}.{core::num::*}(uti7::bitsPerByte);
      core::int offset = this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::length};
      this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::addAll}(imp::NativeUint8List::•(8));
      typ2::ByteData byteData = this.{has::HashSink::_pendingData}.{typ3::_TypedDataBuffer::buffer}.{typ2::ByteBuffer::asByteData}();
      core::int highBits = lengthInBits.{core::int::>>}(32);
      core::int lowBits = lengthInBits.{core::int::&}(uti7::mask32);
      if(this.{has::HashSink::_endian}.{core::Object::==}(typ2::Endian::big)) {
        byteData.{typ2::ByteData::setUint32}(offset, highBits, this.{has::HashSink::_endian});
        byteData.{typ2::ByteData::setUint32}(offset.{core::num::+}(uti7::bytesPerWord), lowBits, this.{has::HashSink::_endian});
      }
      else {
        byteData.{typ2::ByteData::setUint32}(offset, lowBits, this.{has::HashSink::_endian});
        byteData.{typ2::ByteData::setUint32}(offset.{core::num::+}(uti7::bytesPerWord), highBits, this.{has::HashSink::_endian});
      }
    }
    method _roundUp(core::int val, core::int n) → core::int
      return val.{core::num::+}(n).{core::num::-}(1).{core::int::&}(n.{core::int::unary-}());
  }
}
library from "package:crypto/src/utils.dart" as uti7 {
  static const field core::int mask32 = 4294967295;
  static const field core::int bitsPerByte = 8;
  static const field core::int bytesPerWord = 4;
  static method add32(core::int x, core::int y) → core::int
    return x.{core::num::+}(y).{core::int::&}(uti7::mask32);
  static method rotl32(core::int val, core::int shift) → core::int {
    core::int modShift = shift.{core::int::&}(31);
    return val.{core::int::<<}(modShift).{core::int::&}(uti7::mask32).{core::int::|}(val.{core::int::&}(uti7::mask32).{core::int::>>}(32.{core::num::-}(modShift)));
  }
}
library convert.hex.encoder from "package:convert/src/hex/encoder.dart" as enc2 {
  import "dart:convert";
  import "dart:typed_data";
  import "package:charcode/ascii.dart";
  class HexEncoder extends con2::Converter<core::List<core::int>, core::String> {
    const constructor _() → void
      : super con2::Converter::•()
      ;
    method convert(generic-covariant-impl core::List<core::int> bytes) → core::String
      return enc2::_convert(bytes, 0, bytes.{core::List::length});
    method startChunkedConversion(generic-covariant-impl core::Sink<core::String> sink) → con2::ByteConversionSink
      return new enc2::_HexEncoderSink::•(sink);
  }
  class _HexEncoderSink extends con2::ByteConversionSinkBase {
    final field core::Sink<core::String> _sink;
    constructor •(core::Sink<core::String> _sink) → void
      : enc2::_HexEncoderSink::_sink = _sink, super con2::ByteConversionSinkBase::•()
      ;
    method add(generic-covariant-impl core::List<core::int> chunk) → void {
      this.{enc2::_HexEncoderSink::_sink}.{core::Sink::add}(enc2::_convert(chunk, 0, chunk.{core::List::length}));
    }
    method addSlice(core::List<core::int> chunk, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, chunk.{core::List::length});
      this.{enc2::_HexEncoderSink::_sink}.{core::Sink::add}(enc2::_convert(chunk, start, end));
      if(isLast)
        this.{enc2::_HexEncoderSink::_sink}.{core::Sink::close}();
    }
    method close() → void {
      this.{enc2::_HexEncoderSink::_sink}.{core::Sink::close}();
    }
  }
  static const field enc2::HexEncoder hexEncoder = const enc2::HexEncoder::_();
  static method _convert(core::List<core::int> bytes, core::int start, core::int end) → core::String {
    typ2::Uint8List buffer = imp::NativeUint8List::•(end.{core::num::-}(start).{core::num::*}(2));
    core::int bufferIndex = 0;
    core::int byteOr = 0;
    for (core::int i = start; i.{core::num::<}(end); i = i.{core::num::+}(1)) {
      core::int byte = bytes.{core::List::[]}(i);
      byteOr = byteOr.{core::int::|}(byte);
      buffer.{core::List::[]=}(let final core::int #t692 = bufferIndex in let final core::int #t693 = bufferIndex = #t692.{core::num::+}(1) in #t692, enc2::_codeUnitForDigit(byte.{core::int::&}(240).{core::int::>>}(4)));
      buffer.{core::List::[]=}(let final core::int #t694 = bufferIndex in let final core::int #t695 = bufferIndex = #t694.{core::num::+}(1) in #t694, enc2::_codeUnitForDigit(byte.{core::int::&}(15)));
    }
    if(byteOr.{core::num::>=}(0) && byteOr.{core::num::<=}(255))
      return core::String::fromCharCodes(buffer);
    for (core::int i = start; i.{core::num::<}(end); i = i.{core::num::+}(1))
      #L134:
      {
        core::int byte = bytes.{core::List::[]}(i);
        if(byte.{core::num::>=}(0) && byte.{core::num::<=}(255))
          break #L134;
        throw new core::FormatException::•("Invalid byte ${byte.{core::num::<}(0) ?{core::String} "-" : ""}0x${byte.{core::int::abs}().{core::int::toRadixString}(16)}.", bytes, i);
      }
    throw "unreachable";
  }
  static method _codeUnitForDigit(core::int digit) → core::int
    return digit.{core::num::<}(10) ?{core::int} digit.{core::num::+}(dol::$0) : digit.{core::num::+}(dol::$a).{core::num::-}(10);
}
library convert.hex.decoder from "package:convert/src/hex/decoder.dart" as dec2 {
  import "dart:convert";
  import "dart:typed_data";
  import "package:convert/src/utils.dart";
  class HexDecoder extends con2::Converter<core::String, core::List<core::int>> {
    const constructor _() → void
      : super con2::Converter::•()
      ;
    method convert(generic-covariant-impl core::String string) → core::List<core::int> {
      if(!string.{core::String::length}.{core::int::isEven}) {
        throw new core::FormatException::•("Invalid input length, must be even.", string, string.{core::String::length});
      }
      typ2::Uint8List bytes = imp::NativeUint8List::•(string.{core::String::length}.{core::num::~/}(2));
      dec2::_decode(string.{core::String::codeUnits}, 0, string.{core::String::length}, bytes, 0);
      return bytes;
    }
    method startChunkedConversion(generic-covariant-impl core::Sink<core::List<core::int>> sink) → con2::StringConversionSink
      return new dec2::_HexDecoderSink::•(sink);
  }
  class _HexDecoderSink extends con2::StringConversionSinkBase {
    final field core::Sink<core::List<core::int>> _sink;
    field core::int _lastDigit = null;
    constructor •(core::Sink<core::List<core::int>> _sink) → void
      : dec2::_HexDecoderSink::_sink = _sink, super con2::StringConversionSinkBase::•()
      ;
    method addSlice(core::String string, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, string.{core::String::length});
      if(start.{core::num::==}(end)) {
        if(isLast)
          this.{dec2::_HexDecoderSink::_close}(string, end);
        return;
      }
      core::List<core::int> codeUnits = string.{core::String::codeUnits};
      typ2::Uint8List bytes;
      core::int bytesStart;
      if(this.{dec2::_HexDecoderSink::_lastDigit}.{core::num::==}(null)) {
        bytes = imp::NativeUint8List::•(end.{core::num::-}(start).{core::num::~/}(2));
        bytesStart = 0;
      }
      else {
        core::int hexPairs = end.{core::num::-}(start).{core::num::-}(1).{core::num::~/}(2);
        bytes = imp::NativeUint8List::•(1.{core::num::+}(hexPairs));
        bytes.{core::List::[]=}(0, this.{dec2::_HexDecoderSink::_lastDigit}.{core::num::+}(uti8::digitForCodeUnit(codeUnits, start)));
        start = start.{core::num::+}(1);
        bytesStart = 1;
      }
      this.{dec2::_HexDecoderSink::_lastDigit} = dec2::_decode(codeUnits, start, end, bytes, bytesStart);
      this.{dec2::_HexDecoderSink::_sink}.{core::Sink::add}(bytes);
      if(isLast)
        this.{dec2::_HexDecoderSink::_close}(string, end);
    }
    method asUtf8Sink(core::bool allowMalformed) → con2::ByteConversionSink
      return new dec2::_HexDecoderByteSink::•(this.{dec2::_HexDecoderSink::_sink});
    method close() → void
      return this.{dec2::_HexDecoderSink::_close}();
    method _close([core::String string = null, core::int index = null]) → void {
      if(!this.{dec2::_HexDecoderSink::_lastDigit}.{core::num::==}(null)) {
        throw new core::FormatException::•("Input ended with incomplete encoded byte.", string, index);
      }
      this.{dec2::_HexDecoderSink::_sink}.{core::Sink::close}();
    }
  }
  class _HexDecoderByteSink extends con2::ByteConversionSinkBase {
    final field core::Sink<core::List<core::int>> _sink;
    field core::int _lastDigit = null;
    constructor •(core::Sink<core::List<core::int>> _sink) → void
      : dec2::_HexDecoderByteSink::_sink = _sink, super con2::ByteConversionSinkBase::•()
      ;
    method add(generic-covariant-impl core::List<core::int> chunk) → void
      return this.{dec2::_HexDecoderByteSink::addSlice}(chunk, 0, chunk.{core::List::length}, false);
    method addSlice(core::List<core::int> chunk, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, chunk.{core::List::length});
      if(start.{core::num::==}(end)) {
        if(isLast)
          this.{dec2::_HexDecoderByteSink::_close}(chunk, end);
        return;
      }
      typ2::Uint8List bytes;
      core::int bytesStart;
      if(this.{dec2::_HexDecoderByteSink::_lastDigit}.{core::num::==}(null)) {
        bytes = imp::NativeUint8List::•(end.{core::num::-}(start).{core::num::~/}(2));
        bytesStart = 0;
      }
      else {
        core::int hexPairs = end.{core::num::-}(start).{core::num::-}(1).{core::num::~/}(2);
        bytes = imp::NativeUint8List::•(1.{core::num::+}(hexPairs));
        bytes.{core::List::[]=}(0, this.{dec2::_HexDecoderByteSink::_lastDigit}.{core::num::+}(uti8::digitForCodeUnit(chunk, start)));
        start = start.{core::num::+}(1);
        bytesStart = 1;
      }
      this.{dec2::_HexDecoderByteSink::_lastDigit} = dec2::_decode(chunk, start, end, bytes, bytesStart);
      this.{dec2::_HexDecoderByteSink::_sink}.{core::Sink::add}(bytes);
      if(isLast)
        this.{dec2::_HexDecoderByteSink::_close}(chunk, end);
    }
    method close() → void
      return this.{dec2::_HexDecoderByteSink::_close}();
    method _close([core::List<core::int> chunk = null, core::int index = null]) → void {
      if(!this.{dec2::_HexDecoderByteSink::_lastDigit}.{core::num::==}(null)) {
        throw new core::FormatException::•("Input ended with incomplete encoded byte.", chunk, index);
      }
      this.{dec2::_HexDecoderByteSink::_sink}.{core::Sink::close}();
    }
  }
  static const field dec2::HexDecoder hexDecoder = const dec2::HexDecoder::_();
  static method _decode(core::List<core::int> codeUnits, core::int sourceStart, core::int sourceEnd, core::List<core::int> destination, core::int destinationStart) → core::int {
    core::int destinationIndex = destinationStart;
    for (core::int i = sourceStart; i.{core::num::<}(sourceEnd.{core::num::-}(1)); i = i.{core::num::+}(2)) {
      core::int firstDigit = uti8::digitForCodeUnit(codeUnits, i);
      core::int secondDigit = uti8::digitForCodeUnit(codeUnits, i.{core::num::+}(1));
      destination.{core::List::[]=}(let final core::int #t696 = destinationIndex in let final core::int #t697 = destinationIndex = #t696.{core::num::+}(1) in #t696, 16.{core::num::*}(firstDigit).{core::num::+}(secondDigit));
    }
    if(sourceEnd.{core::num::-}(sourceStart).{core::int::isEven})
      return null;
    return 16.{core::num::*}(uti8::digitForCodeUnit(codeUnits, sourceEnd.{core::num::-}(1)));
  }
}
library convert.percent.encoder from "package:convert/src/percent/encoder.dart" as enc3 {
  import "dart:convert";
  import "package:charcode/ascii.dart";
  class PercentEncoder extends con2::Converter<core::List<core::int>, core::String> {
    const constructor _() → void
      : super con2::Converter::•()
      ;
    method convert(generic-covariant-impl core::List<core::int> bytes) → core::String
      return enc3::_convert(bytes, 0, bytes.{core::List::length});
    method startChunkedConversion(generic-covariant-impl core::Sink<core::String> sink) → con2::ByteConversionSink
      return new enc3::_PercentEncoderSink::•(sink);
  }
  class _PercentEncoderSink extends con2::ByteConversionSinkBase {
    final field core::Sink<core::String> _sink;
    constructor •(core::Sink<core::String> _sink) → void
      : enc3::_PercentEncoderSink::_sink = _sink, super con2::ByteConversionSinkBase::•()
      ;
    method add(generic-covariant-impl core::List<core::int> chunk) → void {
      this.{enc3::_PercentEncoderSink::_sink}.{core::Sink::add}(enc3::_convert(chunk, 0, chunk.{core::List::length}));
    }
    method addSlice(core::List<core::int> chunk, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, chunk.{core::List::length});
      this.{enc3::_PercentEncoderSink::_sink}.{core::Sink::add}(enc3::_convert(chunk, start, end));
      if(isLast)
        this.{enc3::_PercentEncoderSink::_sink}.{core::Sink::close}();
    }
    method close() → void {
      this.{enc3::_PercentEncoderSink::_sink}.{core::Sink::close}();
    }
  }
  static const field enc3::PercentEncoder percentEncoder = const enc3::PercentEncoder::_();
  static method _convert(core::List<core::int> bytes, core::int start, core::int end) → core::String {
    core::StringBuffer buffer = new core::StringBuffer::•();
    core::int byteOr = 0;
    for (core::int i = start; i.{core::num::<}(end); i = i.{core::num::+}(1))
      #L135:
      {
        core::int byte = bytes.{core::List::[]}(i);
        byteOr = byteOr.{core::int::|}(byte);
        core::int letter = 32.{core::int::|}(byte);
        if(letter.{core::num::>=}(dol::$a) && letter.{core::num::<=}(dol::$z) || byte.{core::num::>=}(dol::$0) && byte.{core::num::<=}(dol::$9) || byte.{core::num::==}(dol::$dash) || byte.{core::num::==}(dol::$dot) || byte.{core::num::==}(dol::$underscore) || byte.{core::num::==}(dol::$tilde)) {
          buffer.{core::StringBuffer::writeCharCode}(byte);
          break #L135;
        }
        buffer.{core::StringBuffer::writeCharCode}(dol::$percent);
        buffer.{core::StringBuffer::writeCharCode}(enc3::_codeUnitForDigit(byte.{core::int::&}(240).{core::int::>>}(4)));
        buffer.{core::StringBuffer::writeCharCode}(enc3::_codeUnitForDigit(byte.{core::int::&}(15)));
      }
    if(byteOr.{core::num::>=}(0) && byteOr.{core::num::<=}(255))
      return buffer.{core::StringBuffer::toString}();
    for (core::int i = start; i.{core::num::<}(end); i = i.{core::num::+}(1))
      #L136:
      {
        core::int byte = bytes.{core::List::[]}(i);
        if(byte.{core::num::>=}(0) && byte.{core::num::<=}(255))
          break #L136;
        throw new core::FormatException::•("Invalid byte ${byte.{core::num::<}(0) ?{core::String} "-" : ""}0x${byte.{core::int::abs}().{core::int::toRadixString}(16)}.", bytes, i);
      }
    throw "unreachable";
  }
  static method _codeUnitForDigit(core::int digit) → core::int
    return digit.{core::num::<}(10) ?{core::int} digit.{core::num::+}(dol::$0) : digit.{core::num::+}(dol::$A).{core::num::-}(10);
}
library convert.percent.decoder from "package:convert/src/percent/decoder.dart" as dec3 {
  import "dart:convert";
  import "package:charcode/ascii.dart";
  import "package:typed_data/typed_data.dart";
  import "package:convert/src/utils.dart";
  class PercentDecoder extends con2::Converter<core::String, core::List<core::int>> {
    const constructor _() → void
      : super con2::Converter::•()
      ;
    method convert(generic-covariant-impl core::String string) → core::List<core::int> {
      typ3::Uint8Buffer buffer = new typ3::Uint8Buffer::•();
      core::int lastDigit = dec3::_decode(string.{core::String::codeUnits}, 0, string.{core::String::length}, buffer);
      if(!lastDigit.{core::num::==}(null)) {
        throw new core::FormatException::•("Input ended with incomplete encoded byte.", string, string.{core::String::length});
      }
      return buffer.{typ3::_TypedDataBuffer::buffer}.{typ2::ByteBuffer::asUint8List}(0, buffer.{typ3::_TypedDataBuffer::length});
    }
    method startChunkedConversion(generic-covariant-impl core::Sink<core::List<core::int>> sink) → con2::StringConversionSink
      return new dec3::_PercentDecoderSink::•(sink);
  }
  class _PercentDecoderSink extends con2::StringConversionSinkBase {
    final field core::Sink<core::List<core::int>> _sink;
    field core::int _lastDigit = null;
    constructor •(core::Sink<core::List<core::int>> _sink) → void
      : dec3::_PercentDecoderSink::_sink = _sink, super con2::StringConversionSinkBase::•()
      ;
    method addSlice(core::String string, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, string.{core::String::length});
      if(start.{core::num::==}(end)) {
        if(isLast)
          this.{dec3::_PercentDecoderSink::_close}(string, end);
        return;
      }
      typ3::Uint8Buffer buffer = new typ3::Uint8Buffer::•();
      core::List<core::int> codeUnits = string.{core::String::codeUnits};
      if(this.{dec3::_PercentDecoderSink::_lastDigit}.{core::num::==}(dec3::_lastPercent)) {
        this.{dec3::_PercentDecoderSink::_lastDigit} = 16.{core::num::*}(uti8::digitForCodeUnit(codeUnits, start));
        start = start.{core::num::+}(1);
        if(start.{core::num::==}(end)) {
          if(isLast)
            this.{dec3::_PercentDecoderSink::_close}(string, end);
          return;
        }
      }
      if(!this.{dec3::_PercentDecoderSink::_lastDigit}.{core::num::==}(null)) {
        buffer.{typ3::_TypedDataBuffer::add}(this.{dec3::_PercentDecoderSink::_lastDigit}.{core::num::+}(uti8::digitForCodeUnit(codeUnits, start)));
        start = start.{core::num::+}(1);
      }
      this.{dec3::_PercentDecoderSink::_lastDigit} = dec3::_decode(codeUnits, start, end, buffer);
      this.{dec3::_PercentDecoderSink::_sink}.{core::Sink::add}(buffer.{typ3::_TypedDataBuffer::buffer}.{typ2::ByteBuffer::asUint8List}(0, buffer.{typ3::_TypedDataBuffer::length}));
      if(isLast)
        this.{dec3::_PercentDecoderSink::_close}(string, end);
    }
    method asUtf8Sink(core::bool allowMalformed) → con2::ByteConversionSink
      return new dec3::_PercentDecoderByteSink::•(this.{dec3::_PercentDecoderSink::_sink});
    method close() → void
      return this.{dec3::_PercentDecoderSink::_close}();
    method _close([core::String string = null, core::int index = null]) → void {
      if(!this.{dec3::_PercentDecoderSink::_lastDigit}.{core::num::==}(null)) {
        throw new core::FormatException::•("Input ended with incomplete encoded byte.", string, index);
      }
      this.{dec3::_PercentDecoderSink::_sink}.{core::Sink::close}();
    }
  }
  class _PercentDecoderByteSink extends con2::ByteConversionSinkBase {
    final field core::Sink<core::List<core::int>> _sink;
    field core::int _lastDigit = null;
    constructor •(core::Sink<core::List<core::int>> _sink) → void
      : dec3::_PercentDecoderByteSink::_sink = _sink, super con2::ByteConversionSinkBase::•()
      ;
    method add(generic-covariant-impl core::List<core::int> chunk) → void
      return this.{dec3::_PercentDecoderByteSink::addSlice}(chunk, 0, chunk.{core::List::length}, false);
    method addSlice(core::List<core::int> chunk, core::int start, core::int end, core::bool isLast) → void {
      core::RangeError::checkValidRange(start, end, chunk.{core::List::length});
      if(start.{core::num::==}(end)) {
        if(isLast)
          this.{dec3::_PercentDecoderByteSink::_close}(chunk, end);
        return;
      }
      typ3::Uint8Buffer buffer = new typ3::Uint8Buffer::•();
      if(this.{dec3::_PercentDecoderByteSink::_lastDigit}.{core::num::==}(dec3::_lastPercent)) {
        this.{dec3::_PercentDecoderByteSink::_lastDigit} = 16.{core::num::*}(uti8::digitForCodeUnit(chunk, start));
        start = start.{core::num::+}(1);
        if(start.{core::num::==}(end)) {
          if(isLast)
            this.{dec3::_PercentDecoderByteSink::_close}(chunk, end);
          return;
        }
      }
      if(!this.{dec3::_PercentDecoderByteSink::_lastDigit}.{core::num::==}(null)) {
        buffer.{typ3::_TypedDataBuffer::add}(this.{dec3::_PercentDecoderByteSink::_lastDigit}.{core::num::+}(uti8::digitForCodeUnit(chunk, start)));
        start = start.{core::num::+}(1);
      }
      this.{dec3::_PercentDecoderByteSink::_lastDigit} = dec3::_decode(chunk, start, end, buffer);
      this.{dec3::_PercentDecoderByteSink::_sink}.{core::Sink::add}(buffer.{typ3::_TypedDataBuffer::buffer}.{typ2::ByteBuffer::asUint8List}(0, buffer.{typ3::_TypedDataBuffer::length}));
      if(isLast)
        this.{dec3::_PercentDecoderByteSink::_close}(chunk, end);
    }
    method close() → void
      return this.{dec3::_PercentDecoderByteSink::_close}();
    method _close([core::List<core::int> chunk = null, core::int index = null]) → void {
      if(!this.{dec3::_PercentDecoderByteSink::_lastDigit}.{core::num::==}(null)) {
        throw new core::FormatException::•("Input ended with incomplete encoded byte.", chunk, index);
      }
      this.{dec3::_PercentDecoderByteSink::_sink}.{core::Sink::close}();
    }
  }
  static const field dec3::PercentDecoder percentDecoder = const dec3::PercentDecoder::_();
  static const field core::int _lastPercent = 1.{core::int::unary-}();
  static method _decode(core::List<core::int> codeUnits, core::int start, core::int end, typ3::Uint8Buffer buffer) → core::int {
    core::int codeUnitOr = 0;
    core::int sliceStart = start;
    for (core::int i = start; i.{core::num::<}(end); i = i.{core::num::+}(1))
      #L137:
      {
        core::int codeUnit = codeUnits.{core::List::[]}(i);
        if(!codeUnits.{core::List::[]}(i).{core::num::==}(dol::$percent)) {
          codeUnitOr = codeUnitOr.{core::int::|}(codeUnit);
          break #L137;
        }
        if(i.{core::num::>}(sliceStart)) {
          dec3::_checkForInvalidCodeUnit(codeUnitOr, codeUnits, sliceStart, i);
          buffer.{typ3::_TypedDataBuffer::addAll}(codeUnits, sliceStart, i);
        }
        i = i.{core::num::+}(1);
        if(i.{core::num::>=}(end))
          return dec3::_lastPercent;
        core::int firstDigit = uti8::digitForCodeUnit(codeUnits, i);
        i = i.{core::num::+}(1);
        if(i.{core::num::>=}(end))
          return 16.{core::num::*}(firstDigit);
        core::int secondDigit = uti8::digitForCodeUnit(codeUnits, i);
        buffer.{typ3::_TypedDataBuffer::add}(16.{core::num::*}(firstDigit).{core::num::+}(secondDigit));
        sliceStart = i.{core::num::+}(1);
      }
    if(end.{core::num::>}(sliceStart)) {
      dec3::_checkForInvalidCodeUnit(codeUnitOr, codeUnits, sliceStart, end);
      if(start.{core::num::==}(sliceStart)) {
        buffer.{typ3::_TypedDataBuffer::addAll}(codeUnits);
      }
      else {
        buffer.{typ3::_TypedDataBuffer::addAll}(codeUnits, sliceStart, end);
      }
    }
    return null;
  }
  static method _checkForInvalidCodeUnit(core::int codeUnitOr, core::List<core::int> codeUnits, core::int start, core::int end) → void {
    if(codeUnitOr.{core::num::>=}(0) && codeUnitOr.{core::num::<=}(127))
      return;
    for (core::int i = start; i.{core::num::<}(end); i = i.{core::num::+}(1))
      #L138:
      {
        core::int codeUnit = codeUnits.{core::List::[]}(i);
        if(codeUnit.{core::num::>=}(0) && codeUnit.{core::num::<=}(127))
          break #L138;
        throw new core::FormatException::•("Non-ASCII code unit U+${codeUnit.{core::int::toRadixString}(16).{core::String::padLeft}(4, "0")}", codeUnits, i);
      }
  }
}
library convert.utils from "package:convert/src/utils.dart" as uti8 {
  import "package:charcode/ascii.dart";
  static method digitForCodeUnit(core::List<core::int> codeUnits, core::int index) → core::int {
    core::int codeUnit = codeUnits.{core::List::[]}(index);
    core::int digit = dol::$0.{core::int::^}(codeUnit);
    if(digit.{core::num::<=}(9)) {
      if(digit.{core::num::>=}(0))
        return digit;
    }
    else {
      core::int letter = 32.{core::int::|}(codeUnit);
      if(dol::$a.{core::num::<=}(letter) && letter.{core::num::<=}(dol::$f))
        return letter.{core::num::-}(dol::$a).{core::num::+}(10);
    }
    throw new core::FormatException::•("Invalid hexadecimal code unit U+${codeUnit.{core::int::toRadixString}(16).{core::String::padLeft}(4, "0")}.", codeUnits, index);
  }
}
constants  {
}
